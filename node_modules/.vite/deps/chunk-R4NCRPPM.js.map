{
  "version": 3,
  "sources": ["../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/plugins/utils/utils-array.ts", "../../.pnpm/js-base64@3.7.7/node_modules/js-base64/base64.mjs", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/plugins/utils/utils-base64.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/plugins/utils/utils-blob.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/plugins/utils/utils-revision.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/plugins/utils/utils-object.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/plugins/utils/utils-document.ts", "../../.pnpm/ohash@1.1.4/node_modules/ohash/dist/index.mjs", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/plugins/utils/utils-hash.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/plugins/utils/utils-promise.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/plugins/utils/utils-regex.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/plugins/utils/utils-string.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/plugins/utils/utils-object-deep-equal.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/plugins/utils/utils-object-dot-prop.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/plugins/utils/utils-map.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/plugins/utils/utils-error.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/plugins/utils/utils-time.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/plugins/utils/utils-other.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/plugins/utils/utils-rxdb-version.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/plugins/utils/utils-global.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/overwritable.ts", "../../.pnpm/@babel+runtime@7.26.0/node_modules/@babel/runtime/helpers/esm/typeof.js", "../../.pnpm/@babel+runtime@7.26.0/node_modules/@babel/runtime/helpers/esm/toPrimitive.js", "../../.pnpm/@babel+runtime@7.26.0/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js", "../../.pnpm/@babel+runtime@7.26.0/node_modules/@babel/runtime/helpers/esm/createClass.js", "../../.pnpm/@babel+runtime@7.26.0/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js", "../../.pnpm/@babel+runtime@7.26.0/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js", "../../.pnpm/@babel+runtime@7.26.0/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js", "../../.pnpm/@babel+runtime@7.26.0/node_modules/@babel/runtime/helpers/esm/isNativeFunction.js", "../../.pnpm/@babel+runtime@7.26.0/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js", "../../.pnpm/@babel+runtime@7.26.0/node_modules/@babel/runtime/helpers/esm/construct.js", "../../.pnpm/@babel+runtime@7.26.0/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/rx-error.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/rx-schema-helper.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/query-planner.ts", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/util.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/core.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/lazy.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/aggregator.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/cursor.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/query.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/date/_internal.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/window/_internal.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/pipeline/sort.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/_predicates.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/array/nin.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/bitwise/_internal.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/bitwise/bitAnd.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/bitwise/bitOr.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/bitwise/bitXor.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/boolean/index.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/boolean/and.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/boolean/not.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/boolean/or.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/comparison/index.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/comparison/cmp.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/comparison/eq.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/comparison/gt.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/comparison/gte.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/comparison/lt.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/comparison/lte.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/comparison/ne.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/date/dateFromString.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/_internal.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/acos.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/acosh.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/asin.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/asinh.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/atan.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/atanh.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/cos.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/cosh.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/degreesToRadians.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/radiansToDegrees.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/sin.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/sinh.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/tan.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/pipeline/project.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/logical/and.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/logical/or.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/logical/nor.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/logical/not.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/comparison/eq.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/comparison/gt.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/comparison/gte.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/comparison/in.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/comparison/lt.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/comparison/lte.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/comparison/ne.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/comparison/nin.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/evaluation/expr.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/evaluation/jsonSchema.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/evaluation/mod.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/evaluation/regex.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/evaluation/where.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/array/all.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/array/elemMatch.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/array/size.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/element/exists.js", "../../.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/element/type.js", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/rx-query-mingo.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/rx-query-helper.ts"],
  "sourcesContent": ["import type {\n    MaybePromise,\n    MaybeReadonly\n} from '../../types/index.d.ts';\n\nexport function lastOfArray<T>(ar: T[]): T | undefined {\n    return ar[ar.length - 1];\n}\n\n/**\n * shuffle the given array\n */\nexport function shuffleArray<T>(arr: T[]): T[] {\n    return arr.slice(0).sort(() => (Math.random() - 0.5));\n}\n\nexport function randomOfArray<T>(arr: T[]): T {\n    const randomElement = arr[Math.floor(Math.random() * arr.length)];\n    return randomElement;\n}\n\n\nexport function toArray<T>(input: T | T[] | Readonly<T> | Readonly<T[]>): T[] {\n    return Array.isArray(input) ? (input as any[]).slice(0) : [input];\n}\n\n/**\n * Split array with items into smaller arrays with items\n * @link https://stackoverflow.com/a/7273794/3443137\n */\nexport function batchArray<T>(array: T[], batchSize: number): T[][] {\n    array = array.slice(0);\n    const ret: T[][] = [];\n    while (array.length) {\n        const batch = array.splice(0, batchSize);\n        ret.push(batch);\n    }\n    return ret;\n}\n\n/**\n * @link https://stackoverflow.com/a/15996017\n */\nexport function removeOneFromArrayIfMatches<T>(ar: T[], condition: (x: T) => boolean): T[] {\n    ar = ar.slice();\n    let i = ar.length;\n    let done = false;\n    while (i-- && !done) {\n        if (condition(ar[i])) {\n            done = true;\n            ar.splice(i, 1);\n        }\n    }\n    return ar;\n}\n\n/**\n * returns true if the supplied argument is either an Array<T> or a Readonly<Array<T>>\n */\nexport function isMaybeReadonlyArray(x: any): x is MaybeReadonly<any[]> {\n    // While this looks strange, it's a workaround for an issue in TypeScript:\n    // https://github.com/microsoft/TypeScript/issues/17002\n    //\n    // The problem is that `Array.isArray` as a type guard returns `false` for a readonly array,\n    // but at runtime the object is an array and the runtime call to `Array.isArray` would return `true`.\n    // The type predicate here allows for both `Array<T>` and `Readonly<Array<T>>` to pass a type check while\n    // still performing runtime type inspection.\n    return Array.isArray(x);\n}\n\n\n\nexport function isOneItemOfArrayInOtherArray<T>(ar1: T[], ar2: T[]): boolean {\n    for (let i = 0; i < ar1.length; i++) {\n        const el = ar1[i];\n        const has = ar2.includes(el);\n        if (has) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n/**\n * Use this in array.filter() to remove all empty slots\n * and have the correct typings afterwards.\n * @link https://stackoverflow.com/a/46700791/3443137\n */\nexport function arrayFilterNotEmpty<TValue>(value: TValue | null | undefined): value is TValue {\n    if (value === null || value === undefined) {\n        return false;\n    }\n    return true;\n}\n\nexport function countUntilNotMatching<T>(\n    ar: T[],\n    matchingFn: (v: T, idx: number) => boolean\n): number {\n    let count = 0;\n    let idx = -1;\n    for (const item of ar) {\n        idx = idx + 1;\n        const matching = matchingFn(item, idx);\n        if (matching) {\n            count = count + 1;\n        } else {\n            break;\n        }\n    }\n    return count;\n}\n\nexport async function asyncFilter<T>(array: T[], predicate: (item: T, index: number, a: T[]) => MaybePromise<boolean>): Promise<T[]> {\n    const filters = await Promise.all(\n        array.map(predicate)\n    );\n\n    return array.filter((...[, index]) => filters[index]);\n}\n\n/**\n * @link https://stackoverflow.com/a/3762735\n */\nexport function sumNumberArray(array: number[]): number {\n    let count = 0;\n    for (let i = array.length; i--;) {\n        count += array[i];\n    }\n    return count;\n}\n\nexport function maxOfNumbers(arr: number[]): number {\n    return Math.max(...arr);\n}\n\n\n/**\n * Appends the given documents to the given array.\n * This will mutate the first given array.\n * Mostly used as faster alternative to Array.concat()\n * because .concat() is so slow.\n * @link https://www.measurethat.net/Benchmarks/Show/4223/0/array-concat-vs-spread-operator-vs-push#latest_results_block\n * \n * TODO it turns out that in mid 2024 v8 has optimized Array.concat()\n * so it might be faster to just use concat() again:\n * @link https://jsperf.app/qiqawa/10\n */\nexport function appendToArray<T>(ar: T[], add: T[] | readonly T[]): void {\n    /**\n     * Pre-increasing the array size has turned out\n     * to be way faster when big arrays must be handled.\n     * @link https://dev.to/uilicious/javascript-array-push-is-945x-faster-than-array-concat-1oki\n     */\n    const addSize = add.length;\n    if (addSize === 0) {\n        return;\n    }\n    const baseSize = ar.length;\n    ar.length = baseSize + add.length;\n    for (let i = 0; i < addSize; ++i) {\n        ar[baseSize + i] = add[i];\n    }\n}\n\n/**\n * @link https://gist.github.com/telekosmos/3b62a31a5c43f40849bb\n */\nexport function uniqueArray(arrArg: string[]): string[] {\n    return arrArg.filter(function (elem, pos, arr) {\n        return arr.indexOf(elem) === pos;\n    });\n}\n\n\nexport function sortByObjectNumberProperty<T>(property: keyof T) {\n    return (a: T, b: T) => {\n        return (b as any)[property] - (a as any)[property];\n    }\n}\n", "/**\n *  base64.ts\n *\n *  Licensed under the BSD 3-Clause License.\n *    http://opensource.org/licenses/BSD-3-Clause\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n *\n * @author Dan Kogai (https://github.com/dankogai)\n */\nconst version = '3.7.7';\n/**\n * @deprecated use lowercase `version`.\n */\nconst VERSION = version;\nconst _hasBuffer = typeof Buffer === 'function';\nconst _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;\nconst _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;\nconst b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nconst b64chs = Array.prototype.slice.call(b64ch);\nconst b64tab = ((a) => {\n    let tab = {};\n    a.forEach((c, i) => tab[c] = i);\n    return tab;\n})(b64chs);\nconst b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\nconst _fromCC = String.fromCharCode.bind(String);\nconst _U8Afrom = typeof Uint8Array.from === 'function'\n    ? Uint8Array.from.bind(Uint8Array)\n    : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));\nconst _mkUriSafe = (src) => src\n    .replace(/=/g, '').replace(/[+\\/]/g, (m0) => m0 == '+' ? '-' : '_');\nconst _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\\+\\/]/g, '');\n/**\n * polyfill version of `btoa`\n */\nconst btoaPolyfill = (bin) => {\n    // console.log('polyfilled');\n    let u32, c0, c1, c2, asc = '';\n    const pad = bin.length % 3;\n    for (let i = 0; i < bin.length;) {\n        if ((c0 = bin.charCodeAt(i++)) > 255 ||\n            (c1 = bin.charCodeAt(i++)) > 255 ||\n            (c2 = bin.charCodeAt(i++)) > 255)\n            throw new TypeError('invalid character found');\n        u32 = (c0 << 16) | (c1 << 8) | c2;\n        asc += b64chs[u32 >> 18 & 63]\n            + b64chs[u32 >> 12 & 63]\n            + b64chs[u32 >> 6 & 63]\n            + b64chs[u32 & 63];\n    }\n    return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n};\n/**\n * does what `window.btoa` of web browsers do.\n * @param {String} bin binary string\n * @returns {string} Base64-encoded string\n */\nconst _btoa = typeof btoa === 'function' ? (bin) => btoa(bin)\n    : _hasBuffer ? (bin) => Buffer.from(bin, 'binary').toString('base64')\n        : btoaPolyfill;\nconst _fromUint8Array = _hasBuffer\n    ? (u8a) => Buffer.from(u8a).toString('base64')\n    : (u8a) => {\n        // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326\n        const maxargs = 0x1000;\n        let strs = [];\n        for (let i = 0, l = u8a.length; i < l; i += maxargs) {\n            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n        }\n        return _btoa(strs.join(''));\n    };\n/**\n * converts a Uint8Array to a Base64 string.\n * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 ยง5\n * @returns {string} Base64 string\n */\nconst fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const utob = (src: string) => unescape(encodeURIComponent(src));\n// reverting good old fationed regexp\nconst cb_utob = (c) => {\n    if (c.length < 2) {\n        var cc = c.charCodeAt(0);\n        return cc < 0x80 ? c\n            : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))\n                + _fromCC(0x80 | (cc & 0x3f)))\n                : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))\n                    + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n                    + _fromCC(0x80 | (cc & 0x3f)));\n    }\n    else {\n        var cc = 0x10000\n            + (c.charCodeAt(0) - 0xD800) * 0x400\n            + (c.charCodeAt(1) - 0xDC00);\n        return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))\n            + _fromCC(0x80 | ((cc >>> 12) & 0x3f))\n            + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n            + _fromCC(0x80 | (cc & 0x3f)));\n    }\n};\nconst re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-8 string\n * @returns {string} UTF-16 string\n */\nconst utob = (u) => u.replace(re_utob, cb_utob);\n//\nconst _encode = _hasBuffer\n    ? (s) => Buffer.from(s, 'utf8').toString('base64')\n    : _TE\n        ? (s) => _fromUint8Array(_TE.encode(s))\n        : (s) => _btoa(utob(s));\n/**\n * converts a UTF-8-encoded string to a Base64 string.\n * @param {boolean} [urlsafe] if `true` make the result URL-safe\n * @returns {string} Base64 string\n */\nconst encode = (src, urlsafe = false) => urlsafe\n    ? _mkUriSafe(_encode(src))\n    : _encode(src);\n/**\n * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 ยง5.\n * @returns {string} Base64 string\n */\nconst encodeURI = (src) => encode(src, true);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const btou = (src: string) => decodeURIComponent(escape(src));\n// reverting good old fationed regexp\nconst re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\nconst cb_btou = (cccc) => {\n    switch (cccc.length) {\n        case 4:\n            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                | ((0x3f & cccc.charCodeAt(1)) << 12)\n                | ((0x3f & cccc.charCodeAt(2)) << 6)\n                | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;\n            return (_fromCC((offset >>> 10) + 0xD800)\n                + _fromCC((offset & 0x3FF) + 0xDC00));\n        case 3:\n            return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)\n                | ((0x3f & cccc.charCodeAt(1)) << 6)\n                | (0x3f & cccc.charCodeAt(2)));\n        default:\n            return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)\n                | (0x3f & cccc.charCodeAt(1)));\n    }\n};\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-16 string\n * @returns {string} UTF-8 string\n */\nconst btou = (b) => b.replace(re_btou, cb_btou);\n/**\n * polyfill version of `atob`\n */\nconst atobPolyfill = (asc) => {\n    // console.log('polyfilled');\n    asc = asc.replace(/\\s+/g, '');\n    if (!b64re.test(asc))\n        throw new TypeError('malformed base64.');\n    asc += '=='.slice(2 - (asc.length & 3));\n    let u24, bin = '', r1, r2;\n    for (let i = 0; i < asc.length;) {\n        u24 = b64tab[asc.charAt(i++)] << 18\n            | b64tab[asc.charAt(i++)] << 12\n            | (r1 = b64tab[asc.charAt(i++)]) << 6\n            | (r2 = b64tab[asc.charAt(i++)]);\n        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)\n            : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)\n                : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n    }\n    return bin;\n};\n/**\n * does what `window.atob` of web browsers do.\n * @param {String} asc Base64-encoded string\n * @returns {string} binary string\n */\nconst _atob = typeof atob === 'function' ? (asc) => atob(_tidyB64(asc))\n    : _hasBuffer ? (asc) => Buffer.from(asc, 'base64').toString('binary')\n        : atobPolyfill;\n//\nconst _toUint8Array = _hasBuffer\n    ? (a) => _U8Afrom(Buffer.from(a, 'base64'))\n    : (a) => _U8Afrom(_atob(a).split('').map(c => c.charCodeAt(0)));\n/**\n * converts a Base64 string to a Uint8Array.\n */\nconst toUint8Array = (a) => _toUint8Array(_unURI(a));\n//\nconst _decode = _hasBuffer\n    ? (a) => Buffer.from(a, 'base64').toString('utf8')\n    : _TD\n        ? (a) => _TD.decode(_toUint8Array(a))\n        : (a) => btou(_atob(a));\nconst _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));\n/**\n * converts a Base64 string to a UTF-8 string.\n * @param {String} src Base64 string.  Both normal and URL-safe are supported\n * @returns {string} UTF-8 string\n */\nconst decode = (src) => _decode(_unURI(src));\n/**\n * check if a value is a valid Base64 string\n * @param {String} src a value to check\n  */\nconst isValid = (src) => {\n    if (typeof src !== 'string')\n        return false;\n    const s = src.replace(/\\s+/g, '').replace(/={0,2}$/, '');\n    return !/[^\\s0-9a-zA-Z\\+/]/.test(s) || !/[^\\s0-9a-zA-Z\\-_]/.test(s);\n};\n//\nconst _noEnum = (v) => {\n    return {\n        value: v, enumerable: false, writable: true, configurable: true\n    };\n};\n/**\n * extend String.prototype with relevant methods\n */\nconst extendString = function () {\n    const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));\n    _add('fromBase64', function () { return decode(this); });\n    _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });\n    _add('toBase64URI', function () { return encode(this, true); });\n    _add('toBase64URL', function () { return encode(this, true); });\n    _add('toUint8Array', function () { return toUint8Array(this); });\n};\n/**\n * extend Uint8Array.prototype with relevant methods\n */\nconst extendUint8Array = function () {\n    const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));\n    _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });\n    _add('toBase64URI', function () { return fromUint8Array(this, true); });\n    _add('toBase64URL', function () { return fromUint8Array(this, true); });\n};\n/**\n * extend Builtin prototypes with relevant methods\n */\nconst extendBuiltins = () => {\n    extendString();\n    extendUint8Array();\n};\nconst gBase64 = {\n    version: version,\n    VERSION: VERSION,\n    atob: _atob,\n    atobPolyfill: atobPolyfill,\n    btoa: _btoa,\n    btoaPolyfill: btoaPolyfill,\n    fromBase64: decode,\n    toBase64: encode,\n    encode: encode,\n    encodeURI: encodeURI,\n    encodeURL: encodeURI,\n    utob: utob,\n    btou: btou,\n    decode: decode,\n    isValid: isValid,\n    fromUint8Array: fromUint8Array,\n    toUint8Array: toUint8Array,\n    extendString: extendString,\n    extendUint8Array: extendUint8Array,\n    extendBuiltins: extendBuiltins\n};\n// makecjs:CUT //\nexport { version };\nexport { VERSION };\nexport { _atob as atob };\nexport { atobPolyfill };\nexport { _btoa as btoa };\nexport { btoaPolyfill };\nexport { decode as fromBase64 };\nexport { encode as toBase64 };\nexport { utob };\nexport { encode };\nexport { encodeURI };\nexport { encodeURI as encodeURL };\nexport { btou };\nexport { decode };\nexport { isValid };\nexport { fromUint8Array };\nexport { toUint8Array };\nexport { extendString };\nexport { extendUint8Array };\nexport { extendBuiltins };\n// and finally,\nexport { gBase64 as Base64 };\n", "\n/**\n * NO! We cannot just use btoa() and atob()\n * because they do not work correctly with binary data.\n * @link https://stackoverflow.com/q/30106476/3443137\n */\nimport { encode, decode } from 'js-base64';\n\n/**\n * atob() and btoa() do not work well with non ascii chars,\n * so we have to use these helper methods instead.\n * @link https://stackoverflow.com/a/30106551/3443137\n */\n// Encoding UTF8 -> base64\nexport function b64EncodeUnicode(str: string) {\n    return encode(str);\n}\n\n// Decoding base64 -> UTF8\nexport function b64DecodeUnicode(str: string) {\n    return decode(str);\n}\n\n/**\n * @link https://stackoverflow.com/a/9458996/3443137\n */\nexport function arrayBufferToBase64(buffer: ArrayBuffer) {\n    let binary = '';\n    const bytes = new Uint8Array(buffer);\n    const len = bytes.byteLength;\n    for (let i = 0; i < len; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\n\n\n/**\n * @link https://stackoverflow.com/a/21797381\n */\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\n    const binary_string = atob(base64);\n    const len = binary_string.length;\n    const bytes = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n        bytes[i] = binary_string.charCodeAt(i);\n    }\n    return bytes.buffer;\n}\n", "import { arrayBufferToBase64 } from './utils-base64.ts';\n\n/**\n * Since RxDB 13.0.0 we only use Blob instead of falling back to Buffer,\n * because Node.js >18 supports Blobs anyway.\n */\n/**\n * depending if we are on node or browser,\n * we have to use Buffer(node) or Blob(browser)\n */\nexport function createBlob(\n    data: string,\n    type: string\n): Blob {\n    const blob = new Blob([data], {\n        type\n    });\n    return blob;\n}\n\nexport async function createBlobFromBase64(\n    base64String: string,\n    type: string\n): Promise<Blob> {\n    const base64Response = await fetch(`data:${type};base64,${base64String}`);\n    const blob = await base64Response.blob();\n    return blob;\n}\n\nexport function blobToString(blob: Blob | string): Promise<string> {\n    /**\n     * in the electron-renderer we have a typed array instead of a blob\n     * so we have to transform it.\n     * @link https://github.com/pubkey/rxdb/issues/1371\n     */\n    const blobType = Object.prototype.toString.call(blob);\n    if (blobType === '[object Uint8Array]') {\n        blob = new Blob([blob]);\n    }\n    if (typeof blob === 'string') {\n        return Promise.resolve(blob);\n    }\n\n    return blob.text();\n}\n\nexport async function blobToBase64String(blob: Blob | string): Promise<string> {\n    if (typeof blob === 'string') {\n        return blob;\n    }\n\n    /**\n     * in the electron-renderer we have a typed array instead of a blob\n     * so we have to transform it.\n     * @link https://github.com/pubkey/rxdb/issues/1371\n     */\n    const blobType = Object.prototype.toString.call(blob);\n    if (blobType === '[object Uint8Array]') {\n        blob = new Blob([blob]);\n    }\n\n    const arrayBuffer = await blob.arrayBuffer();\n    return arrayBufferToBase64(arrayBuffer);\n}\n\nexport function getBlobSize(blob: Blob): number {\n    return blob.size;\n}\n", "import type {\n    RxDocumentData\n} from '../../types/index.d.ts';\n\n/**\n * Parses the full revision.\n * Do NOT use this if you only need the revision height,\n * then use getHeightOfRevision() instead which is faster.\n */\nexport function parseRevision(revision: string): { height: number; hash: string; } {\n    const split = revision.split('-');\n    if (split.length !== 2) {\n        throw new Error('malformatted revision: ' + revision);\n    }\n    return {\n        height: parseInt(split[0], 10),\n        hash: split[1]\n    };\n}\n\n/**\n * @hotPath Performance is very important here\n * because we need to parse the revision height very often.\n * Do not use `parseInt(revision.split('-')[0], 10)` because\n * only fetching the start-number chars is faster.\n */\nexport function getHeightOfRevision(revision: string): number {\n    let useChars = '';\n    for (let index = 0; index < revision.length; index++) {\n        const char = revision[index];\n        if (char === '-') {\n            return parseInt(useChars, 10);\n        }\n        useChars += char;\n    }\n    throw new Error('malformatted revision: ' + revision);\n}\n\n\n/**\n * Creates the next write revision for a given document.\n */\nexport function createRevision<RxDocType>(\n    databaseInstanceToken: string,\n    previousDocData?: RxDocumentData<RxDocType>\n): string {\n    const newRevisionHeight = !previousDocData ? 1 : getHeightOfRevision(previousDocData._rev) + 1\n    return newRevisionHeight + '-' + databaseInstanceToken;\n}\n\n", "import type {\n    DeepReadonlyObject\n} from '../../types/index.d.ts';\n\nexport function deepFreeze<T>(o: T): T {\n    Object.freeze(o);\n    Object.getOwnPropertyNames(o).forEach(function (prop) {\n        if (\n            Object.prototype.hasOwnProperty.call(o, prop) &&\n            (o as any)[prop] !== null &&\n            (\n                typeof (o as any)[prop] === 'object'\n                ||\n                typeof (o as any)[prop] === 'function'\n            ) &&\n            !Object.isFrozen((o as any)[prop])\n        ) {\n            deepFreeze((o as any)[prop]);\n        }\n    });\n    return o;\n}\n\n\n\n/**\n * To get specific nested path values from objects,\n * RxDB normally uses the 'dot-prop' npm module.\n * But when performance is really relevant, this is not fast enough.\n * Instead we use a monad that can prepare some stuff up front\n * and we can reuse the generated function.\n */\nexport type ObjectPathMonadFunction<T, R = any> = (obj: T) => R;\nexport function objectPathMonad<T, R = any>(objectPath: string): ObjectPathMonadFunction<T, R> {\n    const split = objectPath.split('.');\n\n    // reuse this variable for better performance.\n    const splitLength = split.length;\n\n    /**\n     * Performance shortcut,\n     * if no nested path is used,\n     * directly return the field of the object.\n     */\n    if (splitLength === 1) {\n        return (obj: T) => (obj as any)[objectPath];\n    }\n\n\n    return (obj: T) => {\n        let currentVal: any = obj;\n        for (let i = 0; i < splitLength; ++i) {\n            const subPath = split[i];\n            currentVal = currentVal[subPath];\n            if (typeof currentVal === 'undefined') {\n                return currentVal;\n            }\n        }\n        return currentVal;\n    };\n}\n\n\nexport function getFromObjectOrThrow<V>(\n    obj: { [k: string]: V; },\n    key: string\n): V {\n    const val = obj[key];\n    if (!val) {\n        throw new Error('missing value from object ' + key);\n    }\n    return val;\n}\n\n/**\n * returns a flattened object\n * @link https://gist.github.com/penguinboy/762197\n */\nexport function flattenObject(ob: any) {\n    const toReturn: any = {};\n\n    for (const i in ob) {\n        if (!Object.prototype.hasOwnProperty.call(ob, i)) continue;\n        if ((typeof ob[i]) === 'object') {\n            const flatObject = flattenObject(ob[i]);\n            for (const x in flatObject) {\n                if (!Object.prototype.hasOwnProperty.call(flatObject, x)) continue;\n                toReturn[i + '.' + x] = flatObject[x];\n            }\n        } else {\n            toReturn[i] = ob[i];\n        }\n    }\n    return toReturn;\n}\n\n\n/**\n * does a flat copy on the objects,\n * is about 3 times faster then using deepClone\n * @link https://jsperf.com/object-rest-spread-vs-clone/2\n */\nexport function flatClone<T>(obj: T | DeepReadonlyObject<T> | Readonly<T>): T {\n    return Object.assign({}, obj) as any;\n}\n\n/**\n * @link https://stackoverflow.com/a/11509718/3443137\n */\nexport function firstPropertyNameOfObject(obj: any): string {\n    return Object.keys(obj)[0];\n}\nexport function firstPropertyValueOfObject<T>(obj: { [k: string]: T; }): T {\n    const key = Object.keys(obj)[0];\n    return obj[key];\n}\n\n\n/**\n * deep-sort an object so its attributes are in lexical order.\n * Also sorts the arrays inside of the object if no-array-sort not set\n */\nexport function sortObject(obj: any, noArraySort = false): any {\n    if (!obj) return obj; // do not sort null, false or undefined\n\n    // array\n    if (!noArraySort && Array.isArray(obj)) {\n        return obj\n            .sort((a, b) => {\n                if (typeof a === 'string' && typeof b === 'string')\n                    return a.localeCompare(b);\n\n                if (typeof a === 'object') return 1;\n                else return -1;\n            })\n            .map(i => sortObject(i, noArraySort));\n    }\n\n    // object\n    // array is also of type object\n    if (typeof obj === 'object' && !Array.isArray(obj)) {\n        const out: any = {};\n        Object.keys(obj)\n            .sort((a, b) => a.localeCompare(b))\n            .forEach(key => {\n                out[key] = sortObject(obj[key], noArraySort);\n            });\n        return out;\n    }\n\n    // everything else\n    return obj;\n}\n\n\n\n/**\n * Deep clone a plain json object.\n * Does not work with recursive stuff\n * or non-plain-json.\n * IMPORTANT: Performance of this is very important,\n * do not change it without running performance tests!\n *\n * @link https://github.com/zxdong262/deep-copy/blob/master/src/index.ts\n */\nfunction deepClone<T>(src: T | DeepReadonlyObject<T>): T {\n    if (!src) {\n        return src;\n    }\n    if (src === null || typeof (src) !== 'object') {\n        return src;\n    }\n    if (Array.isArray(src)) {\n        const ret = new Array(src.length);\n        let i = ret.length;\n        while (i--) {\n            ret[i] = deepClone(src[i]);\n        }\n        return ret as any;\n    }\n    const dest: any = {};\n    // eslint-disable-next-line guard-for-in\n    for (const key in src) {\n        dest[key] = deepClone(src[key]);\n    }\n    return dest;\n}\nexport const clone = deepClone;\n\n\n\n/**\n * overwrites the getter with the actual value\n * Mostly used for caching stuff on the first run\n */\nexport function overwriteGetterForCaching<ValueType = any>(\n    obj: any,\n    getterName: string,\n    value: ValueType\n): ValueType {\n    Object.defineProperty(obj, getterName, {\n        get: function () {\n            return value;\n        }\n    });\n    return value;\n}\n\n\nexport function hasDeepProperty(obj: any, property: string): boolean {\n    if (obj.hasOwnProperty(property)) {\n        return true;\n    }\n\n    if (Array.isArray(obj)) {\n        const has = !!obj.find(item => hasDeepProperty(item, property));\n        return has;\n    }\n\n    // Recursively check for property in nested objects\n    for (const key in obj) {\n        if (typeof obj[key] === 'object' && obj[key] !== null) {\n            if (hasDeepProperty(obj[key], property)) {\n                return true;\n            }\n        }\n    }\n\n    // Return false if 'foobar' is not found at any level\n    return false;\n}\n", "import type {\n    DeepReadonly,\n    RxDocumentData,\n    RxDocumentMeta,\n    StringKeys,\n    WithDeleted,\n    WithDeletedAndAttachments\n} from '../../types/index.d.ts';\nimport { flatClone } from './utils-object.ts';\n/**\n * We use 1 as minimum so that the value is never falsy.\n * This const is used in several places because querying\n * with a value lower then the minimum could give false results.\n */\nexport const RX_META_LWT_MINIMUM = 1;\n\nexport function getDefaultRxDocumentMeta(): RxDocumentMeta {\n    return {\n        /**\n         * Set this to 1 to not waste performance\n         * while calling new Date()..\n         * The storage wrappers will anyway update\n         * the lastWrite time while calling transformDocumentDataFromRxDBToRxStorage()\n         */\n        lwt: RX_META_LWT_MINIMUM\n    };\n}\n\n/**\n * Returns a revision that is not valid.\n * Use this to have correct typings\n * while the storage wrapper anyway will overwrite the revision.\n */\nexport function getDefaultRevision(): string {\n    /**\n     * Use a non-valid revision format,\n     * to ensure that the RxStorage will throw\n     * when the revision is not replaced downstream.\n     */\n    return '';\n}\n\n\nexport function stripMetaDataFromDocument<RxDocType>(docData: RxDocumentData<RxDocType>): RxDocType {\n    return Object.assign({}, docData, {\n        _meta: undefined,\n        _deleted: undefined,\n        _rev: undefined\n    });\n}\n\n\n/**\n * Faster way to check the equality of document lists\n * compared to doing a deep-equal.\n * Here we only check the ids and revisions.\n */\nexport function areRxDocumentArraysEqual<RxDocType>(\n    primaryPath: StringKeys<RxDocumentData<RxDocType>>,\n    ar1: RxDocumentData<RxDocType>[],\n    ar2: RxDocumentData<RxDocType>[]\n): boolean {\n    if (ar1.length !== ar2.length) {\n        return false;\n    }\n    let i = 0;\n    const len = ar1.length;\n    while (i < len) {\n        const row1 = ar1[i];\n        const row2 = ar2[i];\n        i++;\n\n        if (\n            row1._rev !== row2._rev ||\n            row1[primaryPath] !== row2[primaryPath]\n        ) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\nexport function getSortDocumentsByLastWriteTimeComparator<RxDocType>(primaryPath: string) {\n    return (a: RxDocumentData<RxDocType>, b: RxDocumentData<RxDocType>) => {\n        if (a._meta.lwt === b._meta.lwt) {\n            if ((b as any)[primaryPath] < (a as any)[primaryPath]) {\n                return 1;\n            } else {\n                return -1;\n            }\n        } else {\n            return a._meta.lwt - b._meta.lwt;\n        }\n    };\n}\nexport function sortDocumentsByLastWriteTime<RxDocType>(\n    primaryPath: string,\n    docs: RxDocumentData<RxDocType>[]\n): RxDocumentData<RxDocType>[] {\n    return docs.sort(getSortDocumentsByLastWriteTimeComparator(primaryPath));\n}\n\ntype AnyDocFormat<RxDocType> = RxDocType | WithDeleted<RxDocType> | RxDocumentData<RxDocType> | WithDeletedAndAttachments<RxDocType>;\nexport function toWithDeleted<RxDocType>(\n    docData: AnyDocFormat<RxDocType> | DeepReadonly<AnyDocFormat<RxDocType>>\n): WithDeleted<RxDocType> {\n    docData = flatClone(docData);\n    (docData as any)._deleted = !!(docData as any)._deleted;\n    return Object.assign(docData as any, {\n        _attachments: undefined,\n        _meta: undefined,\n        _rev: undefined\n    }) as any;\n}\n", "const defaults = Object.freeze({\n  ignoreUnknown: false,\n  respectType: false,\n  respectFunctionNames: false,\n  respectFunctionProperties: false,\n  unorderedObjects: true,\n  unorderedArrays: false,\n  unorderedSets: false,\n  excludeKeys: void 0,\n  excludeValues: void 0,\n  replacer: void 0\n});\nfunction objectHash(object, options) {\n  if (options) {\n    options = { ...defaults, ...options };\n  } else {\n    options = defaults;\n  }\n  const hasher = createHasher(options);\n  hasher.dispatch(object);\n  return hasher.toString();\n}\nconst defaultPrototypesKeys = Object.freeze([\n  \"prototype\",\n  \"__proto__\",\n  \"constructor\"\n]);\nfunction createHasher(options) {\n  let buff = \"\";\n  let context = /* @__PURE__ */ new Map();\n  const write = (str) => {\n    buff += str;\n  };\n  return {\n    toString() {\n      return buff;\n    },\n    getContext() {\n      return context;\n    },\n    dispatch(value) {\n      if (options.replacer) {\n        value = options.replacer(value);\n      }\n      const type = value === null ? \"null\" : typeof value;\n      return this[type](value);\n    },\n    object(object) {\n      if (object && typeof object.toJSON === \"function\") {\n        return this.object(object.toJSON());\n      }\n      const objString = Object.prototype.toString.call(object);\n      let objType = \"\";\n      const objectLength = objString.length;\n      if (objectLength < 10) {\n        objType = \"unknown:[\" + objString + \"]\";\n      } else {\n        objType = objString.slice(8, objectLength - 1);\n      }\n      objType = objType.toLowerCase();\n      let objectNumber = null;\n      if ((objectNumber = context.get(object)) === void 0) {\n        context.set(object, context.size);\n      } else {\n        return this.dispatch(\"[CIRCULAR:\" + objectNumber + \"]\");\n      }\n      if (typeof Buffer !== \"undefined\" && Buffer.isBuffer && Buffer.isBuffer(object)) {\n        write(\"buffer:\");\n        return write(object.toString(\"utf8\"));\n      }\n      if (objType !== \"object\" && objType !== \"function\" && objType !== \"asyncfunction\") {\n        if (this[objType]) {\n          this[objType](object);\n        } else if (!options.ignoreUnknown) {\n          this.unkown(object, objType);\n        }\n      } else {\n        let keys = Object.keys(object);\n        if (options.unorderedObjects) {\n          keys = keys.sort();\n        }\n        let extraKeys = [];\n        if (options.respectType !== false && !isNativeFunction(object)) {\n          extraKeys = defaultPrototypesKeys;\n        }\n        if (options.excludeKeys) {\n          keys = keys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n          extraKeys = extraKeys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n        }\n        write(\"object:\" + (keys.length + extraKeys.length) + \":\");\n        const dispatchForKey = (key) => {\n          this.dispatch(key);\n          write(\":\");\n          if (!options.excludeValues) {\n            this.dispatch(object[key]);\n          }\n          write(\",\");\n        };\n        for (const key of keys) {\n          dispatchForKey(key);\n        }\n        for (const key of extraKeys) {\n          dispatchForKey(key);\n        }\n      }\n    },\n    array(arr, unordered) {\n      unordered = unordered === void 0 ? options.unorderedArrays !== false : unordered;\n      write(\"array:\" + arr.length + \":\");\n      if (!unordered || arr.length <= 1) {\n        for (const entry of arr) {\n          this.dispatch(entry);\n        }\n        return;\n      }\n      const contextAdditions = /* @__PURE__ */ new Map();\n      const entries = arr.map((entry) => {\n        const hasher = createHasher(options);\n        hasher.dispatch(entry);\n        for (const [key, value] of hasher.getContext()) {\n          contextAdditions.set(key, value);\n        }\n        return hasher.toString();\n      });\n      context = contextAdditions;\n      entries.sort();\n      return this.array(entries, false);\n    },\n    date(date) {\n      return write(\"date:\" + date.toJSON());\n    },\n    symbol(sym) {\n      return write(\"symbol:\" + sym.toString());\n    },\n    unkown(value, type) {\n      write(type);\n      if (!value) {\n        return;\n      }\n      write(\":\");\n      if (value && typeof value.entries === \"function\") {\n        return this.array(\n          Array.from(value.entries()),\n          true\n          /* ordered */\n        );\n      }\n    },\n    error(err) {\n      return write(\"error:\" + err.toString());\n    },\n    boolean(bool) {\n      return write(\"bool:\" + bool);\n    },\n    string(string) {\n      write(\"string:\" + string.length + \":\");\n      write(string);\n    },\n    function(fn) {\n      write(\"fn:\");\n      if (isNativeFunction(fn)) {\n        this.dispatch(\"[native]\");\n      } else {\n        this.dispatch(fn.toString());\n      }\n      if (options.respectFunctionNames !== false) {\n        this.dispatch(\"function-name:\" + String(fn.name));\n      }\n      if (options.respectFunctionProperties) {\n        this.object(fn);\n      }\n    },\n    number(number) {\n      return write(\"number:\" + number);\n    },\n    xml(xml) {\n      return write(\"xml:\" + xml.toString());\n    },\n    null() {\n      return write(\"Null\");\n    },\n    undefined() {\n      return write(\"Undefined\");\n    },\n    regexp(regex) {\n      return write(\"regex:\" + regex.toString());\n    },\n    uint8array(arr) {\n      write(\"uint8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint8clampedarray(arr) {\n      write(\"uint8clampedarray:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int8array(arr) {\n      write(\"int8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint16array(arr) {\n      write(\"uint16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int16array(arr) {\n      write(\"int16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint32array(arr) {\n      write(\"uint32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int32array(arr) {\n      write(\"int32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float32array(arr) {\n      write(\"float32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float64array(arr) {\n      write(\"float64array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    arraybuffer(arr) {\n      write(\"arraybuffer:\");\n      return this.dispatch(new Uint8Array(arr));\n    },\n    url(url) {\n      return write(\"url:\" + url.toString());\n    },\n    map(map) {\n      write(\"map:\");\n      const arr = [...map];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    set(set) {\n      write(\"set:\");\n      const arr = [...set];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    file(file) {\n      write(\"file:\");\n      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);\n    },\n    blob() {\n      if (options.ignoreUnknown) {\n        return write(\"[blob]\");\n      }\n      throw new Error(\n        'Hashing Blob objects is currently not supported\\nUse \"options.replacer\" or \"options.ignoreUnknown\"\\n'\n      );\n    },\n    domwindow() {\n      return write(\"domwindow\");\n    },\n    bigint(number) {\n      return write(\"bigint:\" + number.toString());\n    },\n    /* Node.js standard native objects */\n    process() {\n      return write(\"process\");\n    },\n    timer() {\n      return write(\"timer\");\n    },\n    pipe() {\n      return write(\"pipe\");\n    },\n    tcp() {\n      return write(\"tcp\");\n    },\n    udp() {\n      return write(\"udp\");\n    },\n    tty() {\n      return write(\"tty\");\n    },\n    statwatcher() {\n      return write(\"statwatcher\");\n    },\n    securecontext() {\n      return write(\"securecontext\");\n    },\n    connection() {\n      return write(\"connection\");\n    },\n    zlib() {\n      return write(\"zlib\");\n    },\n    context() {\n      return write(\"context\");\n    },\n    nodescript() {\n      return write(\"nodescript\");\n    },\n    httpparser() {\n      return write(\"httpparser\");\n    },\n    dataview() {\n      return write(\"dataview\");\n    },\n    signal() {\n      return write(\"signal\");\n    },\n    fsevent() {\n      return write(\"fsevent\");\n    },\n    tlswrap() {\n      return write(\"tlswrap\");\n    }\n  };\n}\nconst nativeFunc = \"[native code] }\";\nconst nativeFuncLength = nativeFunc.length;\nfunction isNativeFunction(f) {\n  if (typeof f !== \"function\") {\n    return false;\n  }\n  return Function.prototype.toString.call(f).slice(-nativeFuncLength) === nativeFunc;\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass WordArray {\n  constructor(words, sigBytes) {\n    __publicField$1(this, \"words\");\n    __publicField$1(this, \"sigBytes\");\n    words = this.words = words || [];\n    this.sigBytes = sigBytes === void 0 ? words.length * 4 : sigBytes;\n  }\n  toString(encoder) {\n    return (encoder || Hex).stringify(this);\n  }\n  concat(wordArray) {\n    this.clamp();\n    if (this.sigBytes % 4) {\n      for (let i = 0; i < wordArray.sigBytes; i++) {\n        const thatByte = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n        this.words[this.sigBytes + i >>> 2] |= thatByte << 24 - (this.sigBytes + i) % 4 * 8;\n      }\n    } else {\n      for (let j = 0; j < wordArray.sigBytes; j += 4) {\n        this.words[this.sigBytes + j >>> 2] = wordArray.words[j >>> 2];\n      }\n    }\n    this.sigBytes += wordArray.sigBytes;\n    return this;\n  }\n  clamp() {\n    this.words[this.sigBytes >>> 2] &= 4294967295 << 32 - this.sigBytes % 4 * 8;\n    this.words.length = Math.ceil(this.sigBytes / 4);\n  }\n  clone() {\n    return new WordArray([...this.words]);\n  }\n}\nconst Hex = {\n  stringify(wordArray) {\n    const hexChars = [];\n    for (let i = 0; i < wordArray.sigBytes; i++) {\n      const bite = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      hexChars.push((bite >>> 4).toString(16), (bite & 15).toString(16));\n    }\n    return hexChars.join(\"\");\n  }\n};\nconst Base64 = {\n  stringify(wordArray) {\n    const keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const base64Chars = [];\n    for (let i = 0; i < wordArray.sigBytes; i += 3) {\n      const byte1 = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      const byte2 = wordArray.words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;\n      const byte3 = wordArray.words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;\n      const triplet = byte1 << 16 | byte2 << 8 | byte3;\n      for (let j = 0; j < 4 && i * 8 + j * 6 < wordArray.sigBytes * 8; j++) {\n        base64Chars.push(keyStr.charAt(triplet >>> 6 * (3 - j) & 63));\n      }\n    }\n    return base64Chars.join(\"\");\n  }\n};\nconst Latin1 = {\n  parse(latin1Str) {\n    const latin1StrLength = latin1Str.length;\n    const words = [];\n    for (let i = 0; i < latin1StrLength; i++) {\n      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;\n    }\n    return new WordArray(words, latin1StrLength);\n  }\n};\nconst Utf8 = {\n  parse(utf8Str) {\n    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n  }\n};\nclass BufferedBlockAlgorithm {\n  constructor() {\n    __publicField$1(this, \"_data\", new WordArray());\n    __publicField$1(this, \"_nDataBytes\", 0);\n    __publicField$1(this, \"_minBufferSize\", 0);\n    __publicField$1(this, \"blockSize\", 512 / 32);\n  }\n  reset() {\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n  }\n  _append(data) {\n    if (typeof data === \"string\") {\n      data = Utf8.parse(data);\n    }\n    this._data.concat(data);\n    this._nDataBytes += data.sigBytes;\n  }\n  _doProcessBlock(_dataWords, _offset) {\n  }\n  _process(doFlush) {\n    let processedWords;\n    let nBlocksReady = this._data.sigBytes / (this.blockSize * 4);\n    if (doFlush) {\n      nBlocksReady = Math.ceil(nBlocksReady);\n    } else {\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n    }\n    const nWordsReady = nBlocksReady * this.blockSize;\n    const nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);\n    if (nWordsReady) {\n      for (let offset = 0; offset < nWordsReady; offset += this.blockSize) {\n        this._doProcessBlock(this._data.words, offset);\n      }\n      processedWords = this._data.words.splice(0, nWordsReady);\n      this._data.sigBytes -= nBytesReady;\n    }\n    return new WordArray(processedWords, nBytesReady);\n  }\n}\nclass Hasher extends BufferedBlockAlgorithm {\n  update(messageUpdate) {\n    this._append(messageUpdate);\n    this._process();\n    return this;\n  }\n  finalize(messageUpdate) {\n    if (messageUpdate) {\n      this._append(messageUpdate);\n    }\n  }\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst H = [\n  1779033703,\n  -1150833019,\n  1013904242,\n  -1521486534,\n  1359893119,\n  -1694144372,\n  528734635,\n  1541459225\n];\nconst K = [\n  1116352408,\n  1899447441,\n  -1245643825,\n  -373957723,\n  961987163,\n  1508970993,\n  -1841331548,\n  -1424204075,\n  -670586216,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  -2132889090,\n  -1680079193,\n  -1046744716,\n  -459576895,\n  -272742522,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  -1740746414,\n  -1473132947,\n  -1341970488,\n  -1084653625,\n  -958395405,\n  -710438585,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  -2117940946,\n  -1838011259,\n  -1564481375,\n  -1474664885,\n  -1035236496,\n  -949202525,\n  -778901479,\n  -694614492,\n  -200395387,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  -2067236844,\n  -1933114872,\n  -1866530822,\n  -1538233109,\n  -1090935817,\n  -965641998\n];\nconst W = [];\nclass SHA256 extends Hasher {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"_hash\", new WordArray([...H]));\n  }\n  /**\n   * Resets the internal state of the hash object to initial values.\n   */\n  reset() {\n    super.reset();\n    this._hash = new WordArray([...H]);\n  }\n  _doProcessBlock(M, offset) {\n    const H2 = this._hash.words;\n    let a = H2[0];\n    let b = H2[1];\n    let c = H2[2];\n    let d = H2[3];\n    let e = H2[4];\n    let f = H2[5];\n    let g = H2[6];\n    let h = H2[7];\n    for (let i = 0; i < 64; i++) {\n      if (i < 16) {\n        W[i] = M[offset + i] | 0;\n      } else {\n        const gamma0x = W[i - 15];\n        const gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;\n        const gamma1x = W[i - 2];\n        const gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;\n        W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n      }\n      const ch = e & f ^ ~e & g;\n      const maj = a & b ^ a & c ^ b & c;\n      const sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);\n      const sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);\n      const t1 = h + sigma1 + ch + K[i] + W[i];\n      const t2 = sigma0 + maj;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t1 | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t1 + t2 | 0;\n    }\n    H2[0] = H2[0] + a | 0;\n    H2[1] = H2[1] + b | 0;\n    H2[2] = H2[2] + c | 0;\n    H2[3] = H2[3] + d | 0;\n    H2[4] = H2[4] + e | 0;\n    H2[5] = H2[5] + f | 0;\n    H2[6] = H2[6] + g | 0;\n    H2[7] = H2[7] + h | 0;\n  }\n  /**\n   * Finishes the hash calculation and returns the hash as a WordArray.\n   *\n   * @param {string} messageUpdate - Additional message content to include in the hash.\n   * @returns {WordArray} The finalised hash as a WordArray.\n   */\n  finalize(messageUpdate) {\n    super.finalize(messageUpdate);\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = this._data.sigBytes * 8;\n    this._data.words[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(\n      nBitsTotal / 4294967296\n    );\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n    this._data.sigBytes = this._data.words.length * 4;\n    this._process();\n    return this._hash;\n  }\n}\nfunction sha256(message) {\n  return new SHA256().finalize(message).toString();\n}\nfunction sha256base64(message) {\n  return new SHA256().finalize(message).toString(Base64);\n}\n\nfunction hash(object, options = {}) {\n  const hashed = typeof object === \"string\" ? object : objectHash(object, options);\n  return sha256base64(hashed).slice(0, 10);\n}\n\nfunction murmurHash(key, seed = 0) {\n  if (typeof key === \"string\") {\n    key = createBuffer(key);\n  }\n  let i = 0;\n  let h1 = seed;\n  let k1;\n  let h1b;\n  const remainder = key.length & 3;\n  const bytes = key.length - remainder;\n  const c1 = 3432918353;\n  const c2 = 461845907;\n  while (i < bytes) {\n    k1 = key[i] & 255 | (key[++i] & 255) << 8 | (key[++i] & 255) << 16 | (key[++i] & 255) << 24;\n    ++i;\n    k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;\n    k1 = k1 << 15 | k1 >>> 17;\n    k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;\n    h1 ^= k1;\n    h1 = h1 << 13 | h1 >>> 19;\n    h1b = (h1 & 65535) * 5 + (((h1 >>> 16) * 5 & 65535) << 16) & 4294967295;\n    h1 = (h1b & 65535) + 27492 + (((h1b >>> 16) + 58964 & 65535) << 16);\n  }\n  k1 = 0;\n  switch (remainder) {\n    case 3: {\n      k1 ^= (key[i + 2] & 255) << 16;\n    }\n    case 2: {\n      k1 ^= (key[i + 1] & 255) << 8;\n    }\n    case 1: {\n      k1 ^= key[i] & 255;\n      k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;\n      k1 = k1 << 15 | k1 >>> 17;\n      k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;\n      h1 ^= k1;\n    }\n  }\n  h1 ^= key.length;\n  h1 ^= h1 >>> 16;\n  h1 = (h1 & 65535) * 2246822507 + (((h1 >>> 16) * 2246822507 & 65535) << 16) & 4294967295;\n  h1 ^= h1 >>> 13;\n  h1 = (h1 & 65535) * 3266489909 + (((h1 >>> 16) * 3266489909 & 65535) << 16) & 4294967295;\n  h1 ^= h1 >>> 16;\n  return h1 >>> 0;\n}\nfunction createBuffer(val) {\n  return new TextEncoder().encode(val);\n}\n\nfunction isEqual(object1, object2, hashOptions = {}) {\n  if (object1 === object2) {\n    return true;\n  }\n  if (objectHash(object1, hashOptions) === objectHash(object2, hashOptions)) {\n    return true;\n  }\n  return false;\n}\n\nfunction diff(obj1, obj2, opts = {}) {\n  const h1 = _toHashedObject(obj1, opts);\n  const h2 = _toHashedObject(obj2, opts);\n  return _diff(h1, h2, opts);\n}\nfunction _diff(h1, h2, opts = {}) {\n  const diffs = [];\n  const allProps = /* @__PURE__ */ new Set([\n    ...Object.keys(h1.props || {}),\n    ...Object.keys(h2.props || {})\n  ]);\n  if (h1.props && h2.props) {\n    for (const prop of allProps) {\n      const p1 = h1.props[prop];\n      const p2 = h2.props[prop];\n      if (p1 && p2) {\n        diffs.push(..._diff(h1.props?.[prop], h2.props?.[prop], opts));\n      } else if (p1 || p2) {\n        diffs.push(\n          new DiffEntry((p2 || p1).key, p1 ? \"removed\" : \"added\", p2, p1)\n        );\n      }\n    }\n  }\n  if (allProps.size === 0 && h1.hash !== h2.hash) {\n    diffs.push(new DiffEntry((h2 || h1).key, \"changed\", h2, h1));\n  }\n  return diffs;\n}\nfunction _toHashedObject(obj, opts, key = \"\") {\n  if (obj && typeof obj !== \"object\") {\n    return new DiffHashedObject(key, obj, objectHash(obj, opts));\n  }\n  const props = {};\n  const hashes = [];\n  for (const _key in obj) {\n    props[_key] = _toHashedObject(\n      obj[_key],\n      opts,\n      key ? `${key}.${_key}` : _key\n    );\n    hashes.push(props[_key].hash);\n  }\n  return new DiffHashedObject(key, obj, `{${hashes.join(\":\")}}`, props);\n}\nclass DiffEntry {\n  constructor(key, type, newValue, oldValue) {\n    this.key = key;\n    this.type = type;\n    this.newValue = newValue;\n    this.oldValue = oldValue;\n  }\n  toString() {\n    return this.toJSON();\n  }\n  toJSON() {\n    switch (this.type) {\n      case \"added\": {\n        return `Added   \\`${this.key}\\``;\n      }\n      case \"removed\": {\n        return `Removed \\`${this.key}\\``;\n      }\n      case \"changed\": {\n        return `Changed \\`${this.key}\\` from \\`${this.oldValue?.toString() || \"-\"}\\` to \\`${this.newValue.toString()}\\``;\n      }\n    }\n  }\n}\nclass DiffHashedObject {\n  constructor(key, value, hash, props) {\n    this.key = key;\n    this.value = value;\n    this.hash = hash;\n    this.props = props;\n  }\n  toString() {\n    if (this.props) {\n      return `{${Object.keys(this.props).join(\",\")}}`;\n    } else {\n      return JSON.stringify(this.value);\n    }\n  }\n  toJSON() {\n    const k = this.key || \".\";\n    if (this.props) {\n      return `${k}({${Object.keys(this.props).join(\",\")}})`;\n    }\n    return `${k}(${this.value})`;\n  }\n}\n\nexport { diff, hash, isEqual, murmurHash, objectHash, sha256, sha256base64 };\n", "import { sha256 } from 'ohash';\nimport type { HashFunction } from '../../types/index.d.ts';\n\n\n/**\n * TODO in the future we should no longer provide a\n * fallback to crypto.subtle.digest.\n * Instead users without crypto.subtle.digest support, should have to provide their own\n * hash function.\n */\nexport function jsSha256(input: string) {\n    return Promise.resolve(sha256(input));\n}\n\nexport async function nativeSha256(input: string) {\n    const data = new TextEncoder().encode(input);\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    /**\n     * @link https://jameshfisher.com/2017/10/30/web-cryptography-api-hello-world/\n     */\n    const hash = Array.prototype.map.call(\n        new Uint8Array(hashBuffer),\n        x => (('00' + x.toString(16)).slice(-2))\n    ).join('');\n    return hash;\n}\n\n\nexport const canUseCryptoSubtle = typeof crypto !== 'undefined' &&\n    typeof crypto.subtle !== 'undefined' &&\n    typeof crypto.subtle.digest === 'function';\n\n/**\n * Default hash method used to hash\n * strings and do equal comparisons.\n *\n * IMPORTANT: Changing the default hashing method\n * requires a BREAKING change!\n */\n\nexport const defaultHashSha256: HashFunction = canUseCryptoSubtle ? nativeSha256 : jsSha256;\n\n\nexport function hashStringToNumber(str: string): number {\n    let nr = 0;\n    const len = str.length;\n    for (let i = 0; i < len; i++) {\n        nr = nr + str.charCodeAt(i);\n        nr |= 0; // Convert to 32bit integer, improves performance\n    }\n    return nr;\n}\n", "/**\n * returns a promise that resolves on the next tick\n */\nexport function nextTick(): Promise<void> {\n    return new Promise(res => setTimeout(res, 0));\n}\n\nexport function promiseWait(ms: number = 0): Promise<void> {\n    return new Promise(res => setTimeout(res, ms));\n}\n\nexport function toPromise<T>(maybePromise: Promise<T> | T): Promise<T> {\n    if (maybePromise && typeof (maybePromise as any).then === 'function') {\n        // is promise\n        return maybePromise as any;\n    } else {\n        return Promise.resolve(maybePromise);\n    }\n}\n\n/**\n * returns true if promise is given\n */\nexport function isPromise(value: any): boolean {\n    if (\n        typeof value !== 'undefined' &&\n        typeof value.then === 'function'\n    ) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * Reusing resolved promises has a better\n * performance than creating new ones each time.\n */\nexport const PROMISE_RESOLVE_TRUE: Promise<true> = Promise.resolve(true);\nexport const PROMISE_RESOLVE_FALSE: Promise<false> = Promise.resolve(false);\nexport const PROMISE_RESOLVE_NULL: Promise<null> = Promise.resolve(null);\nexport const PROMISE_RESOLVE_VOID: Promise<void> = Promise.resolve();\n\n\nexport function requestIdlePromiseNoQueue(\n    /**\n     * We always set a timeout!\n     * RxDB might be used on the server side where the\n     * server runs 24/4 on 99% CPU. So without a timeout\n     * this would never resolve which could cause a memory leak.\n     */\n    timeout: number | undefined = 10000\n) {\n    /**\n     * Do not use window.requestIdleCallback\n     * because some javascript runtimes like react-native,\n     * do not have a window object, but still have a global\n     * requestIdleCallback function.\n     * @link https://github.com/pubkey/rxdb/issues/4804\n    */\n    if (\n        typeof requestIdleCallback === 'function'\n    ) {\n        return new Promise<void>(res => {\n            requestIdleCallback(\n                () => res(),\n                {\n                    timeout\n                }\n            );\n        });\n    } else {\n        return promiseWait(0);\n    }\n}\n\n/**\n * If multiple operations wait for an requestIdlePromise\n * we do not want them to resolve all at the same time.\n * So we have to queue the calls.\n */\nlet idlePromiseQueue = PROMISE_RESOLVE_VOID;\nexport function requestIdlePromise(\n    timeout: number | undefined = undefined\n) {\n    idlePromiseQueue = idlePromiseQueue.then(() => {\n        return requestIdlePromiseNoQueue(timeout);\n    });\n    return idlePromiseQueue;\n}\n\n\n/**\n * run the callback if requestIdleCallback available\n * do nothing if not\n * @link https://developer.mozilla.org/de/docs/Web/API/Window/requestIdleCallback\n */\nexport function requestIdleCallbackIfAvailable(fun: Function): void {\n    /**\n     * Do not use window.requestIdleCallback\n     * because some javascript runtimes like react-native,\n     * do not have a window object, but still have a global\n     * requestIdleCallback function.\n     * @link https://github.com/pubkey/rxdb/issues/4804\n    */\n    if (\n        typeof requestIdleCallback === 'function'\n    ) {\n        requestIdleCallback(() => {\n            fun();\n        });\n    }\n}\n\n\n/**\n * like Promise.all() but runs in series instead of parallel\n * @link https://github.com/egoist/promise.series/blob/master/index.js\n * @param tasks array with functions that return a promise\n */\nexport function promiseSeries(\n    tasks: Function[],\n    initial?: any\n): Promise<any[]> {\n    return tasks\n        .reduce(\n            (current, next) => (current as any).then(next),\n            Promise.resolve(initial)\n        );\n}\n", "export const REGEX_ALL_DOTS = /\\./g;\nexport const REGEX_ALL_PIPES = /\\|/g;\n", "const COUCH_NAME_CHARS = 'abcdefghijklmnopqrstuvwxyz';\n/**\n * get a random string which can be used with couchdb\n * @link http://stackoverflow.com/a/1349426/3443137\n */\nexport function randomCouchString(length: number = 10): string {\n    let text = '';\n\n    for (let i = 0; i < length; i++) {\n        text += COUCH_NAME_CHARS.charAt(Math.floor(Math.random() * COUCH_NAME_CHARS.length));\n    }\n\n    return text;\n}\n\n\n/**\n * A random string that is never inside of any storage\n */\nexport const RANDOM_STRING = 'Fz7SZXPmYJujkzjY1rpXWvlWBqoGAfAX';\n\n/**\n * uppercase first char\n */\nexport function ucfirst(str: string): string {\n    str += '';\n    const f = str.charAt(0)\n        .toUpperCase();\n    return f + str.substr(1);\n}\n\n/**\n * removes trailing and ending dots from the string\n */\nexport function trimDots(str: string): string {\n    // start\n    while (str.charAt(0) === '.') {\n        str = str.substr(1);\n    }\n\n    // end\n    while (str.slice(-1) === '.') {\n        str = str.slice(0, -1);\n    }\n\n    return str;\n}\n\n/**\n * @link https://stackoverflow.com/a/44950500/3443137\n */\nexport function lastCharOfString(str: string): string {\n    return str.charAt(str.length - 1);\n}\n\n/**\n * returns true if the given name is likely a folder path\n */\nexport function isFolderPath(name: string) {\n    // do not check, if foldername is given\n    if (\n        name.includes('/') || // unix\n        name.includes('\\\\') // windows\n    ) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n/**\n * @link https://gist.github.com/andreburgaud/6f73fd2d690b629346b8\n * @link https://stackoverflow.com/a/76240378/3443137\n */\nexport function arrayBufferToString(arrayBuffer: ArrayBuffer): string {\n    return new TextDecoder().decode(arrayBuffer);\n}\n\nexport function stringToArrayBuffer(str: string): ArrayBuffer {\n    return new TextEncoder().encode(str);\n}\n\n\nexport function normalizeString(str: string): string {\n    return str.trim().replace(/[\\n\\s]+/g, '');\n}\n", "\n/**\n * Copied from the fast-deep-equal package\n * because it does not support es modules and causes optimization bailouts.\n * TODO use the npm package again when this is merged:\n * @link https://github.com/epoberezkin/fast-deep-equal/pull/105\n */\nexport function deepEqual(a: any, b: any): boolean {\n    if (a === b) return true;\n\n    if (a && b && typeof a == 'object' && typeof b == 'object') {\n        if (a.constructor !== b.constructor) return false;\n\n        let length;\n        let i;\n        if (Array.isArray(a)) {\n            length = a.length;\n            if (length !== b.length) return false;\n            for (i = length; i-- !== 0;)\n                if (!deepEqual(a[i], b[i])) return false;\n            return true;\n        }\n\n\n        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n        const keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) return false;\n\n        for (i = length; i-- !== 0;)\n            if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n        for (i = length; i-- !== 0;) {\n            const key = keys[i];\n            if (!deepEqual(a[key], b[key])) return false;\n        }\n\n        return true;\n    }\n\n    // true if both NaN, false otherwise\n    return a !== a && b !== b;\n}\n", "/**\n * Copied from\n * @link https://github.com/sindresorhus/dot-prop/blob/main/index.js\n * because it is currently an esm only module.\n * TODO use the npm package again when RxDB is also fully esm.\n */\n\nconst isObject = (value: null) => {\n    const type = typeof value;\n    return value !== null && (type === 'object' || type === 'function');\n};\n\nconst disallowedKeys = new Set([\n    '__proto__',\n    'prototype',\n    'constructor',\n]);\n\nconst digits = new Set('0123456789');\n\nfunction getPathSegments(path: string) {\n    const parts = [];\n    let currentSegment = '';\n    let currentPart = 'start';\n    let isIgnoring = false;\n\n    for (const character of path) {\n        switch (character) {\n            case '\\\\': {\n                if (currentPart === 'index') {\n                    throw new Error('Invalid character in an index');\n                }\n\n                if (currentPart === 'indexEnd') {\n                    throw new Error('Invalid character after an index');\n                }\n\n                if (isIgnoring) {\n                    currentSegment += character;\n                }\n\n                currentPart = 'property';\n                isIgnoring = !isIgnoring;\n                break;\n            }\n\n            case '.': {\n                if (currentPart === 'index') {\n                    throw new Error('Invalid character in an index');\n                }\n\n                if (currentPart === 'indexEnd') {\n                    currentPart = 'property';\n                    break;\n                }\n\n                if (isIgnoring) {\n                    isIgnoring = false;\n                    currentSegment += character;\n                    break;\n                }\n\n                if (disallowedKeys.has(currentSegment)) {\n                    return [];\n                }\n\n                parts.push(currentSegment);\n                currentSegment = '';\n                currentPart = 'property';\n                break;\n            }\n\n            case '[': {\n                if (currentPart === 'index') {\n                    throw new Error('Invalid character in an index');\n                }\n\n                if (currentPart === 'indexEnd') {\n                    currentPart = 'index';\n                    break;\n                }\n\n                if (isIgnoring) {\n                    isIgnoring = false;\n                    currentSegment += character;\n                    break;\n                }\n\n                if (currentPart === 'property') {\n                    if (disallowedKeys.has(currentSegment)) {\n                        return [];\n                    }\n\n                    parts.push(currentSegment);\n                    currentSegment = '';\n                }\n\n                currentPart = 'index';\n                break;\n            }\n\n            case ']': {\n                if (currentPart === 'index') {\n                    parts.push(Number.parseInt(currentSegment, 10));\n                    currentSegment = '';\n                    currentPart = 'indexEnd';\n                    break;\n                }\n\n                if (currentPart === 'indexEnd') {\n                    throw new Error('Invalid character after an index');\n                }\n\n                // Falls through\n            }\n\n            default: {\n                if (currentPart === 'index' && !digits.has(character)) {\n                    throw new Error('Invalid character in an index');\n                }\n\n                if (currentPart === 'indexEnd') {\n                    throw new Error('Invalid character after an index');\n                }\n\n                if (currentPart === 'start') {\n                    currentPart = 'property';\n                }\n\n                if (isIgnoring) {\n                    isIgnoring = false;\n                    currentSegment += '\\\\';\n                }\n\n                currentSegment += character;\n            }\n        }\n    }\n\n    if (isIgnoring) {\n        currentSegment += '\\\\';\n    }\n\n    switch (currentPart) {\n        case 'property': {\n            if (disallowedKeys.has(currentSegment)) {\n                return [];\n            }\n\n            parts.push(currentSegment);\n\n            break;\n        }\n\n        case 'index': {\n            throw new Error('Index was not closed');\n        }\n\n        case 'start': {\n            parts.push('');\n\n            break;\n        }\n        // No default\n    }\n\n    return parts;\n}\n\nfunction isStringIndex(object: any[], key: string) {\n    if (typeof key !== 'number' && Array.isArray(object)) {\n        const index = Number.parseInt(key, 10);\n        return Number.isInteger(index) && object[index] === object[key as any];\n    }\n\n    return false;\n}\n\nfunction assertNotStringIndex(object: any, key: string | number) {\n    if (isStringIndex(object, key as any)) {\n        throw new Error('Cannot use string index');\n    }\n}\n\n/**\n * TODO we need some performance tests and improvements here.\n */\nexport function getProperty(object: any, path: string | string[], value?: any) {\n    if (Array.isArray(path)) {\n        path = path.join('.');\n    }\n\n    /**\n     * Performance shortcut.\n     * In most cases we just have a simple property name\n     * so we can directly return it.\n     */\n    if (\n        !path.includes('.') &&\n        !path.includes('[')\n    ) {\n        return object[path];\n    }\n\n    if (!isObject(object as any) || typeof path !== 'string') {\n        return value === undefined ? object : value;\n    }\n\n    const pathArray = getPathSegments(path);\n    if (pathArray.length === 0) {\n        return value;\n    }\n\n    for (let index = 0; index < pathArray.length; index++) {\n        const key = pathArray[index];\n\n        if (isStringIndex(object as any, key as any)) {\n            object = index === pathArray.length - 1 ? undefined : null;\n        } else {\n            object = (object as any)[key];\n        }\n\n        if (object === undefined || object === null) {\n            // `object` is either `undefined` or `null` so we want to stop the loop, and\n            // if this is not the last bit of the path, and\n            // if it didn't return `undefined`\n            // it would return `null` if `object` is `null`\n            // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n            if (index !== pathArray.length - 1) {\n                return value;\n            }\n\n            break;\n        }\n    }\n\n    return object === undefined ? value : object;\n}\n\nexport function setProperty(object: any, path: string, value: any) {\n    if (Array.isArray(path)) {\n        path = path.join('.');\n    }\n\n    if (!isObject(object as any) || typeof path !== 'string') {\n        return object;\n    }\n\n    const root = object;\n    const pathArray = getPathSegments(path);\n\n    for (let index = 0; index < pathArray.length; index++) {\n        const key = pathArray[index];\n\n        assertNotStringIndex(object, key);\n\n        if (index === pathArray.length - 1) {\n            object[key] = value;\n        } else if (!isObject(object[key])) {\n            object[key] = typeof pathArray[index + 1] === 'number' ? [] : {};\n        }\n\n        object = object[key];\n    }\n\n    return root;\n}\n\nexport function deleteProperty(object: any, path: string) {\n    if (!isObject(object as any) || typeof path !== 'string') {\n        return false;\n    }\n\n    const pathArray = getPathSegments(path);\n\n    for (let index = 0; index < pathArray.length; index++) {\n        const key = pathArray[index];\n\n        assertNotStringIndex(object, key);\n\n        if (index === pathArray.length - 1) {\n            delete object[key];\n            return true;\n        }\n\n        object = object[key];\n\n        if (!isObject(object as any)) {\n            return false;\n        }\n    }\n}\n\nexport function hasProperty(object: any, path: string) {\n    if (!isObject(object) || typeof path !== 'string') {\n        return false;\n    }\n\n    const pathArray = getPathSegments(path);\n    if (pathArray.length === 0) {\n        return false;\n    }\n\n    for (const key of pathArray) {\n        if (!isObject(object) || !(key in object) || isStringIndex(object, key as any)) {\n            return false;\n        }\n\n        object = object[key];\n    }\n\n    return true;\n}\n\n// TODO: Backslashes with no effect should not be escaped\nfunction escapePath(path: string) {\n    if (typeof path !== 'string') {\n        throw new TypeError('Expected a string');\n    }\n\n    return path.replace(/[\\\\.[]/g, '\\\\$&');\n}\n\n// The keys returned by Object.entries() for arrays are strings\nfunction entries(value: any) {\n    if (Array.isArray(value)) {\n        return value.map((v, index) => [index, v]);\n    }\n\n    return Object.entries(value);\n}\n\nfunction stringifyPath(pathSegments: never[]) {\n    let result = '';\n\n    // eslint-disable-next-line prefer-const\n    for (let [index, segment] of entries(pathSegments)) {\n        if (typeof segment === 'number') {\n            result += `[${segment}]`;\n        } else {\n            segment = escapePath(segment);\n            result += index === 0 ? segment : `.${segment}`;\n        }\n    }\n\n    return result;\n}\n\nfunction* deepKeysIterator(object: any, currentPath = []): any {\n    if (!isObject(object)) {\n        if (currentPath.length > 0) {\n            yield stringifyPath(currentPath);\n        }\n\n        return;\n    }\n\n    for (const [key, value] of entries(object)) {\n        yield* deepKeysIterator(value, [...currentPath, key] as any);\n    }\n}\n\nexport function deepKeys(object: any) {\n    return [...deepKeysIterator(object)];\n}\n", "export function getFromMapOrThrow<K, V>(map: Map<K, V> | WeakMap<any, V>, key: K): V {\n    const val = map.get(key);\n    if (typeof val === 'undefined') {\n        throw new Error('missing value from map ' + key);\n    }\n    return val;\n}\n\nexport function getFromMapOrCreate<MapIndex, MapValue>(\n    map: Map<MapIndex, MapValue> | WeakMap<any, MapValue>,\n    index: MapIndex,\n    creator: () => MapValue,\n    ifWasThere?: (value: MapValue) => void\n): MapValue {\n    let value = map.get(index);\n    if (typeof value === 'undefined') {\n        value = creator();\n        map.set(index, value);\n    } else if (ifWasThere) {\n        ifWasThere(value);\n    }\n    return value;\n}\n", "import type {\n    PlainJsonError,\n    RxError,\n    RxTypeError\n} from '../../types/index.d.ts';\nimport { ucfirst } from './utils-string.ts';\n\n\n\n/**\n * Returns an error that indicates that a plugin is missing\n * We do not throw a RxError because this should not be handled\n * programmatically but by using the correct import\n */\nexport function pluginMissing(\n    pluginKey: string\n): Error {\n    const keyParts = pluginKey.split('-');\n    let pluginName = 'RxDB';\n    keyParts.forEach(part => {\n        pluginName += ucfirst(part);\n    });\n    pluginName += 'Plugin';\n    return new Error(\n        `You are using a function which must be overwritten by a plugin.\n        You should either prevent the usage of this function or add the plugin via:\n            import { ${pluginName} } from 'rxdb/plugins/${pluginKey}';\n            addRxPlugin(${pluginName});\n        `\n    );\n}\n\n\n\nexport function errorToPlainJson(err: Error | TypeError | RxError | RxTypeError): PlainJsonError {\n    const ret: PlainJsonError = {\n        name: err.name,\n        message: err.message,\n        rxdb: (err as any).rxdb,\n        parameters: (err as RxError).parameters,\n        extensions: (err as any).extensions,\n        code: (err as RxError).code,\n        url: (err as RxError).url,\n        /**\n         * stack must be last to make it easier to read the json in a console.\n         * Also we ensure that each linebreak is spaced so that the chrome devtools\n         * shows urls to the source code that can be clicked to inspect\n         * the correct place in the code.\n         */\n        stack: !err.stack ? undefined : err.stack.replace(/\\n/g, ' \\n ')\n    };\n    return ret;\n}\n", "\n/**\n * Returns the current unix time in milliseconds (with two decimals!)\n * Because the accuracy of getTime() in javascript is bad,\n * and we cannot rely on performance.now() on all platforms,\n * this method implements a way to never return the same value twice.\n * This ensures that when now() is called often, we do not loose the information\n * about which call came first and which came after.\n *\n * We had to move from having no decimals, to having two decimal\n * because it turned out that some storages are such fast that\n * calling this method too often would return 'the future'.\n */\nlet _lastNow: number = 0;\n/**\n * Returns the current time in milliseconds,\n * also ensures to not return the same value twice.\n */\nexport function now(): number {\n    let ret = Date.now();\n    ret = ret + 0.01;\n    if (ret <= _lastNow) {\n        ret = _lastNow + 0.01;\n    }\n\n    /**\n     * Strip the returned number to max two decimals.\n     * In theory we would not need this but\n     * in practice JavaScript has no such good number precision\n     * so rounding errors could add another decimal place.\n     */\n    const twoDecimals = parseFloat(ret.toFixed(2));\n\n    _lastNow = twoDecimals;\n    return twoDecimals;\n}\n", "export function runXTimes(xTimes: number, fn: (idx: number) => void) {\n    new Array(xTimes).fill(0).forEach((_v, idx) => fn(idx));\n}\n\nexport function ensureNotFalsy<T>(obj: T | false | undefined | null, message?: string): T {\n    if (!obj) {\n        if (!message) {\n            message = '';\n        }\n        throw new Error('ensureNotFalsy() is falsy: ' + message);\n    }\n    return obj;\n}\n\nexport function ensureInteger(obj: unknown): number {\n    if (!Number.isInteger(obj)) {\n        throw new Error('ensureInteger() is falsy');\n    }\n    return obj as number;\n}\n\n/**\n * Using shareReplay() without settings will not unsubscribe\n * if there are no more subscribers.\n * So we use these defaults.\n * @link https://cartant.medium.com/rxjs-whats-changed-with-sharereplay-65c098843e95\n */\nexport const RXJS_SHARE_REPLAY_DEFAULTS = {\n    bufferSize: 1,\n    refCount: true\n};\n\n\n\n/**\n * Dynamically add a name to a function\n * so that it can later be found in the stack.\n * @link https://stackoverflow.com/a/41854075/3443137\n */\nexport function nameFunction<T>(name: string, body: T): T {\n    // @ts-ignore\n    return { [name](...args) { return body.apply(this, args) } }[name];\n}\n", "/**\n * This file is replaced in the 'npm run build:version' script.\n */\nexport const RXDB_VERSION = '15.39.0';\n", "/**\n * Can be used by some plugins to have a \"global\" object that\n * can be imported and mutated at will.\n */\nexport const RXDB_UTILS_GLOBAL: any = {};\n\n\nexport const PREMIUM_FLAG_HASH = '6da4936d1425ff3a5c44c02342c6daf791d266be3ae8479b8ec59e261df41b93';\n", "/**\n * functions that can or should be overwritten by plugins\n * IMPORTANT: Do not import any big stuff from RxDB here!\n * An 'overwritable' can be used inside WebWorkers for RxStorage only,\n * and we do not want to have the full RxDB lib bundled in them.\n */\n\nimport type { DeepReadonly } from './types/util.d.ts';\n\nexport const overwritable = {\n    /**\n     * if this method is overwritten with one\n     * that returns true, we do additional checks\n     * which help the developer but have bad performance\n     */\n    isDevMode(): boolean {\n        return false;\n    },\n\n    /**\n     * Deep freezes and object when in dev-mode.\n     * Deep-Freezing has the same performance as deep-cloning, so we only do that in dev-mode.\n     * Also, we can ensure the readonly state via typescript\n     * @link https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\n     */\n    deepFreezeWhenDevMode<T>(obj: T): DeepReadonly<T> {\n        return obj as any;\n    },\n\n    /**\n     * overwritten to map error-codes to text-messages\n     */\n    tunnelErrorMessage(message: string): string {\n        return `RxDB Error-Code ${message}.\n        Error messages are not included in RxDB core to reduce build size.\n        `;\n    }\n};\n", "function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nexport { _typeof as default };", "import _typeof from \"./typeof.js\";\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nexport { toPrimitive as default };", "import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nexport { toPropertyKey as default };", "import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nexport { _createClass as default };", "function _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\nexport { _setPrototypeOf as default };", "import setPrototypeOf from \"./setPrototypeOf.js\";\nfunction _inheritsLoose(t, o) {\n  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, setPrototypeOf(t, o);\n}\nexport { _inheritsLoose as default };", "function _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\nexport { _getPrototypeOf as default };", "function _isNativeFunction(t) {\n  try {\n    return -1 !== Function.toString.call(t).indexOf(\"[native code]\");\n  } catch (n) {\n    return \"function\" == typeof t;\n  }\n}\nexport { _isNativeFunction as default };", "function _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n    return !!t;\n  })();\n}\nexport { _isNativeReflectConstruct as default };", "import isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nimport setPrototypeOf from \"./setPrototypeOf.js\";\nfunction _construct(t, e, r) {\n  if (isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);\n  var o = [null];\n  o.push.apply(o, e);\n  var p = new (t.bind.apply(t, o))();\n  return r && setPrototypeOf(p, r.prototype), p;\n}\nexport { _construct as default };", "import getPrototypeOf from \"./getPrototypeOf.js\";\nimport setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeFunction from \"./isNativeFunction.js\";\nimport construct from \"./construct.js\";\nfunction _wrapNativeSuper(t) {\n  var r = \"function\" == typeof Map ? new Map() : void 0;\n  return _wrapNativeSuper = function _wrapNativeSuper(t) {\n    if (null === t || !isNativeFunction(t)) return t;\n    if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n    if (void 0 !== r) {\n      if (r.has(t)) return r.get(t);\n      r.set(t, Wrapper);\n    }\n    function Wrapper() {\n      return construct(t, arguments, getPrototypeOf(this).constructor);\n    }\n    return Wrapper.prototype = Object.create(t.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }), setPrototypeOf(Wrapper, t);\n  }, _wrapNativeSuper(t);\n}\nexport { _wrapNativeSuper as default };", "/**\n * here we use custom errors with the additional field 'parameters'\n */\n\nimport { overwritable } from './overwritable.ts';\nimport type {\n    RxErrorParameters,\n    RxErrorKey,\n    RxStorageWriteError,\n    RxStorageWriteErrorConflict\n} from './types/index.d.ts';\n\n/**\n * transform an object of parameters to a presentable string\n */\nfunction parametersToString(parameters: any): string {\n    let ret = '';\n    if (Object.keys(parameters).length === 0)\n        return ret;\n    ret += 'Given parameters: {\\n';\n    ret += Object.keys(parameters)\n        .map(k => {\n            let paramStr = '[object Object]';\n            try {\n                if (k === 'errors') {\n                    paramStr = parameters[k].map((err: any) => JSON.stringify(err, Object.getOwnPropertyNames(err)));\n                } else {\n                    paramStr = JSON.stringify(parameters[k], function (_k, v) {\n                        return v === undefined ? null : v;\n                    }, 2);\n                }\n            } catch (e) { }\n            return k + ':' + paramStr;\n        })\n        .join('\\n');\n    ret += '}';\n    return ret;\n}\n\nfunction messageForError(\n    message: string,\n    code: string,\n    parameters: any\n): string {\n    return 'RxError (' + code + '):' + '\\n' +\n        message + '\\n' +\n        parametersToString(parameters);\n}\n\nexport class RxError extends Error {\n    public code: RxErrorKey;\n    public message: string;\n    public url: string;\n    public parameters: RxErrorParameters;\n    // always true, use this to detect if its an rxdb-error\n    public rxdb: true;\n    constructor(\n        code: RxErrorKey,\n        message: string,\n        parameters: RxErrorParameters = {}\n    ) {\n        const mes = messageForError(message, code, parameters);\n        super(mes);\n        this.code = code;\n        this.message = mes;\n        this.url = getErrorUrl(code);\n        this.parameters = parameters;\n        this.rxdb = true; // tag them as internal\n    }\n    get name(): string {\n        return 'RxError (' + this.code + ')';\n    }\n    toString(): string {\n        return this.message;\n    }\n    get typeError(): boolean {\n        return false;\n    }\n}\n\nexport class RxTypeError extends TypeError {\n    public code: RxErrorKey;\n    public message: string;\n    public url: string;\n    public parameters: RxErrorParameters;\n    // always true, use this to detect if its an rxdb-error\n    public rxdb: true;\n    constructor(\n        code: RxErrorKey,\n        message: string,\n        parameters: RxErrorParameters = {}\n    ) {\n        const mes = messageForError(message, code, parameters);\n        super(mes);\n        this.code = code;\n        this.message = mes;\n        this.url = getErrorUrl(code);\n        this.parameters = parameters;\n        this.rxdb = true; // tag them as internal\n    }\n    get name(): string {\n        return 'RxTypeError (' + this.code + ')';\n    }\n    toString(): string {\n        return this.message;\n    }\n    get typeError(): boolean {\n        return true;\n    }\n}\n\n\nexport function getErrorUrl(code: RxErrorKey) {\n    return 'https://rxdb.info/errors.html?console=errors#' + code;\n}\n\nexport function errorUrlHint(code: RxErrorKey) {\n    return '\\n You can find out more about this error here: ' + getErrorUrl(code) + ' ';\n}\n\nexport function newRxError(\n    code: RxErrorKey,\n    parameters?: RxErrorParameters\n): RxError {\n    return new RxError(\n        code,\n        overwritable.tunnelErrorMessage(code) + errorUrlHint(code),\n        parameters\n    );\n}\n\nexport function newRxTypeError(\n    code: RxErrorKey,\n    parameters?: RxErrorParameters\n): RxTypeError {\n    return new RxTypeError(\n        code,\n        overwritable.tunnelErrorMessage(code) + errorUrlHint(code),\n        parameters\n    );\n}\n\n\n/**\n * Returns the error if it is a 409 conflict,\n * return false if it is another error.\n */\nexport function isBulkWriteConflictError<RxDocType>(\n    err?: RxStorageWriteError<RxDocType> | any\n): RxStorageWriteErrorConflict<RxDocType> | false {\n    if (\n        err &&\n        err.status === 409\n    ) {\n        return err;\n    } else {\n        return false;\n    }\n}\n\n\nconst STORAGE_WRITE_ERROR_CODE_TO_MESSAGE: { [k: number]: string; } = {\n    409: 'document write conflict',\n    422: 'schema validation error',\n    510: 'attachment data missing'\n};\n\nexport function rxStorageWriteErrorToRxError(err: RxStorageWriteError<any>): RxError {\n    return newRxError('COL20', {\n        name: STORAGE_WRITE_ERROR_CODE_TO_MESSAGE[err.status],\n        document: err.documentId,\n        writeError: err\n    });\n}\n", "import { newRxError } from './rx-error.ts';\nimport type {\n    CompositePrimaryKey,\n    DeepReadonly,\n    JsonSchema,\n    PrimaryKey,\n    RxDocumentData,\n    RxJsonSchema,\n    RxStorageDefaultCheckpoint,\n    StringKeys\n} from './types/index.d.ts';\nimport {\n    appendToArray,\n    ensureNotFalsy,\n    flatClone,\n    getProperty,\n    isMaybeReadonlyArray,\n    REGEX_ALL_DOTS,\n    RX_META_LWT_MINIMUM,\n    sortObject,\n    trimDots\n} from './plugins/utils/index.ts';\nimport type { RxSchema } from './rx-schema.ts';\n\n/**\n * Helper function to create a valid RxJsonSchema\n * with a given version.\n */\nexport function getPseudoSchemaForVersion<T = any>(\n    version: number,\n    primaryKey: StringKeys<T>\n): RxJsonSchema<RxDocumentData<T>> {\n    const pseudoSchema: RxJsonSchema<RxDocumentData<T>> = fillWithDefaultSettings({\n        version,\n        type: 'object',\n        primaryKey: primaryKey as any,\n        properties: {\n            [primaryKey]: {\n                type: 'string',\n                maxLength: 100\n            }\n        } as any,\n        indexes: [\n            [primaryKey]\n        ],\n        required: [primaryKey]\n    });\n    return pseudoSchema;\n}\n\n/**\n * Returns the sub-schema for a given path\n */\nexport function getSchemaByObjectPath<T = any>(\n    rxJsonSchema: RxJsonSchema<T>,\n    path: keyof T | string\n): JsonSchema {\n    let usePath: string = path as string;\n    usePath = usePath.replace(REGEX_ALL_DOTS, '.properties.');\n    usePath = 'properties.' + usePath;\n    usePath = trimDots(usePath);\n\n    const ret = getProperty(rxJsonSchema, usePath);\n    return ret;\n}\n\nexport function fillPrimaryKey<T>(\n    primaryPath: keyof T,\n    jsonSchema: RxJsonSchema<T>,\n    documentData: RxDocumentData<T>\n): RxDocumentData<T> {\n    // optimization shortcut.\n    if (typeof jsonSchema.primaryKey === 'string') {\n        return documentData;\n    }\n\n    const newPrimary = getComposedPrimaryKeyOfDocumentData<T>(\n        jsonSchema,\n        documentData\n    );\n    const existingPrimary: string | undefined = documentData[primaryPath] as any;\n    if (\n        existingPrimary &&\n        existingPrimary !== newPrimary\n    ) {\n        throw newRxError(\n            'DOC19',\n            {\n                args: {\n                    documentData,\n                    existingPrimary,\n                    newPrimary,\n                },\n                schema: jsonSchema\n            });\n    }\n\n    (documentData as any)[primaryPath] = newPrimary;\n    return documentData;\n}\n\nexport function getPrimaryFieldOfPrimaryKey<RxDocType>(\n    primaryKey: PrimaryKey<RxDocType>\n): StringKeys<RxDocType> {\n    if (typeof primaryKey === 'string') {\n        return primaryKey as any;\n    } else {\n        return (primaryKey as CompositePrimaryKey<RxDocType>).key;\n    }\n}\n\nexport function getLengthOfPrimaryKey<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>\n): number {\n    const primaryPath = getPrimaryFieldOfPrimaryKey(schema.primaryKey);\n    const schemaPart = getSchemaByObjectPath(schema, primaryPath);\n    return ensureNotFalsy(schemaPart.maxLength);\n}\n\n/**\n * Returns the composed primaryKey of a document by its data.\n */\nexport function getComposedPrimaryKeyOfDocumentData<RxDocType>(\n    jsonSchema: RxJsonSchema<RxDocType> | RxJsonSchema<RxDocumentData<RxDocType>>,\n    documentData: Partial<RxDocType>\n): string {\n    if (typeof jsonSchema.primaryKey === 'string') {\n        return (documentData as any)[jsonSchema.primaryKey];\n    }\n\n    const compositePrimary: CompositePrimaryKey<RxDocType> = jsonSchema.primaryKey as any;\n    return compositePrimary.fields.map(field => {\n        const value = getProperty(documentData as any, field as string);\n        if (typeof value === 'undefined') {\n            throw newRxError('DOC18', { args: { field, documentData } });\n        }\n        return value;\n    }).join(compositePrimary.separator);\n}\n\n\n/**\n * Normalize the RxJsonSchema.\n * We need this to ensure everything is set up properly\n * and we have the same hash on schemas that represent the same value but\n * have different json.\n *\n * - Orders the schemas attributes by alphabetical order\n * - Adds the primaryKey to all indexes that do not contain the primaryKey\n * - We need this for deterministic sort order on all queries, which is required for event-reduce to work.\n *\n * @return RxJsonSchema - ordered and filled\n */\nexport function normalizeRxJsonSchema<T>(jsonSchema: RxJsonSchema<T>): RxJsonSchema<T> {\n    const normalizedSchema: RxJsonSchema<T> = sortObject(jsonSchema, true);\n    return normalizedSchema;\n}\n\n/**\n * If the schema does not specify any index,\n * we add this index so we at least can run RxQuery()\n * and only select non-deleted fields.\n */\nexport function getDefaultIndex(primaryPath: string) {\n    return ['_deleted', primaryPath];\n}\n\n/**\n * fills the schema-json with default-settings\n * @return cloned schemaObj\n */\nexport function fillWithDefaultSettings<T = any>(\n    schemaObj: RxJsonSchema<T>\n): RxJsonSchema<RxDocumentData<T>> {\n    schemaObj = flatClone(schemaObj);\n    const primaryPath: string = getPrimaryFieldOfPrimaryKey(schemaObj.primaryKey);\n    schemaObj.properties = flatClone(schemaObj.properties);\n\n    // additionalProperties is always false\n    schemaObj.additionalProperties = false;\n\n    // fill with key-compression-state ()\n    if (!Object.prototype.hasOwnProperty.call(schemaObj, 'keyCompression')) {\n        schemaObj.keyCompression = false;\n    }\n\n    // indexes must be array\n    schemaObj.indexes = schemaObj.indexes ? schemaObj.indexes.slice(0) : [];\n\n    // required must be array\n    schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];\n\n    // encrypted must be array\n    schemaObj.encrypted = schemaObj.encrypted ? schemaObj.encrypted.slice(0) : [];\n\n    // add _rev\n    (schemaObj.properties as any)._rev = {\n        type: 'string',\n        minLength: 1\n    };\n\n    // add attachments\n    (schemaObj.properties as any)._attachments = {\n        type: 'object'\n    };\n\n    // add deleted flag\n    (schemaObj.properties as any)._deleted = {\n        type: 'boolean'\n    };\n\n    // add meta property\n    (schemaObj.properties as any)._meta = RX_META_SCHEMA;\n\n    /**\n     * meta fields are all required\n     */\n    schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];\n    (schemaObj.required as string[]).push('_deleted');\n    (schemaObj.required as string[]).push('_rev');\n    (schemaObj.required as string[]).push('_meta');\n    (schemaObj.required as string[]).push('_attachments');\n\n    // final fields are always required\n    const finalFields = getFinalFields(schemaObj);\n    appendToArray(schemaObj.required as any, finalFields);\n    schemaObj.required = schemaObj.required\n        .filter((field: string) => !field.includes('.'))\n        .filter((elem: any, pos: any, arr: any) => arr.indexOf(elem) === pos); // unique;\n\n    // version is 0 by default\n    schemaObj.version = schemaObj.version || 0;\n\n    const useIndexes: string[][] = schemaObj.indexes.map(index => {\n        const arIndex = isMaybeReadonlyArray(index) ? index.slice(0) : [index];\n        /**\n         * Append primary key to indexes that do not contain the primaryKey.\n         * All indexes must have the primaryKey to ensure a deterministic sort order.\n         */\n        if (!arIndex.includes(primaryPath)) {\n            arIndex.push(primaryPath);\n        }\n\n        // add _deleted flag to all indexes so we can query only non-deleted fields\n        // in RxDB itself\n        if (arIndex[0] !== '_deleted') {\n            arIndex.unshift('_deleted');\n        }\n\n        return arIndex;\n    });\n\n    if (useIndexes.length === 0) {\n        useIndexes.push(getDefaultIndex(primaryPath));\n    }\n\n    // we need this index for the getChangedDocumentsSince() method\n    useIndexes.push(['_meta.lwt', primaryPath]);\n\n    // also add the internalIndexes\n    if (schemaObj.internalIndexes) {\n        schemaObj.internalIndexes.map(idx => {\n            useIndexes.push(idx);\n        });\n    }\n\n    // make indexes unique\n    const hasIndex = new Set<string>();\n    useIndexes.filter(index => {\n        const indexStr = index.join(',');\n        if (hasIndex.has(indexStr)) {\n            return false;\n        } else {\n            hasIndex.add(indexStr);\n            return true;\n        }\n    });\n\n    schemaObj.indexes = useIndexes;\n\n    return schemaObj as any;\n}\n\n\nexport const RX_META_SCHEMA: JsonSchema = {\n    type: 'object',\n    properties: {\n        /**\n         * The last-write time.\n         * Unix time in milliseconds.\n         */\n        lwt: {\n            type: 'number',\n            /**\n             * We use 1 as minimum so that the value is never falsy.\n             */\n            minimum: RX_META_LWT_MINIMUM,\n            maximum: 1000000000000000,\n            multipleOf: 0.01\n        }\n    },\n    /**\n     * Additional properties are allowed\n     * and can be used by plugins to set various flags.\n     */\n    additionalProperties: true as any,\n    required: [\n        'lwt'\n    ]\n};\n\n\n/**\n * returns the final-fields of the schema\n * @return field-names of the final-fields\n */\nexport function getFinalFields<T = any>(\n    jsonSchema: RxJsonSchema<T>\n): string[] {\n    const ret = Object.keys(jsonSchema.properties)\n        .filter(key => (jsonSchema as any).properties[key].final);\n\n    // primary is also final\n    const primaryPath = getPrimaryFieldOfPrimaryKey(jsonSchema.primaryKey);\n    ret.push(primaryPath);\n\n    // fields of composite primary are final\n    if (typeof jsonSchema.primaryKey !== 'string') {\n        (jsonSchema.primaryKey as CompositePrimaryKey<T>).fields\n            .forEach(field => ret.push(field as string));\n    }\n\n    return ret;\n}\n\n/**\n * fills all unset fields with default-values if set\n * @hotPath\n */\nexport function fillObjectWithDefaults(rxSchema: RxSchema<any>, obj: any): any {\n    const defaultKeys = Object.keys(rxSchema.defaultValues);\n    for (let i = 0; i < defaultKeys.length; ++i) {\n        const key = defaultKeys[i];\n        if (!Object.prototype.hasOwnProperty.call(obj, key) || typeof obj[key] === 'undefined') {\n            obj[key] = rxSchema.defaultValues[key];\n        }\n    }\n    return obj;\n}\n\nexport const DEFAULT_CHECKPOINT_SCHEMA: DeepReadonly<JsonSchema<RxStorageDefaultCheckpoint>> = {\n    type: 'object',\n    properties: {\n        id: {\n            type: 'string'\n        },\n        lwt: {\n            type: 'number'\n        }\n    },\n    required: [\n        'id',\n        'lwt'\n    ],\n    additionalProperties: false\n} as const;\n", "import { countUntilNotMatching } from './plugins/utils/index.ts';\nimport { newRxError } from './rx-error.ts';\nimport { getSchemaByObjectPath } from './rx-schema-helper.ts';\nimport type {\n    FilledMangoQuery,\n    MangoQuerySelector,\n    RxDocumentData,\n    RxJsonSchema,\n    RxQueryPlan,\n    RxQueryPlanKey,\n    RxQueryPlanerOpts\n} from './types/index.d.ts';\n\nexport const INDEX_MAX = String.fromCharCode(65535);\n\n/**\n * Do not use -Infinity here because it would be\n * transformed to null on JSON.stringify() which can break things\n * when the query plan is send to the storage as json.\n * @link https://stackoverflow.com/a/16644751\n * Notice that for IndexedDB IDBKeyRange we have\n * to transform the value back to -Infinity\n * before we can use it in IDBKeyRange.bound.\n */\nexport const INDEX_MIN = Number.MIN_SAFE_INTEGER;\n\n/**\n * Returns the query plan which contains\n * information about how to run the query\n * and which indexes to use.\n *\n * This is used in some storage like Memory, dexie.js and IndexedDB.\n */\nexport function getQueryPlan<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    query: FilledMangoQuery<RxDocType>\n): RxQueryPlan {\n    const selector = query.selector;\n\n    let indexes: string[][] = schema.indexes ? schema.indexes.slice(0) as any : [];\n    if (query.index) {\n        indexes = [query.index];\n    }\n\n    /**\n     * Most storages do not support descending indexes\n     * so having a 'desc' in the sorting, means we always have to re-sort the results.\n     */\n    const hasDescSorting = !!query.sort.find(sortField => Object.values(sortField)[0] === 'desc');\n\n    /**\n     * Some fields can be part of the selector while not being relevant for sorting\n     * because their selector operators specify that in all cases all matching docs\n     * would have the same value.\n     * For example the boolean field _deleted.\n     * TODO similar thing could be done for enums.\n     */\n    const sortIrrelevevantFields = new Set();\n    Object.keys(selector).forEach(fieldName => {\n        const schemaPart = getSchemaByObjectPath(schema, fieldName);\n        if (\n            schemaPart &&\n            schemaPart.type === 'boolean' &&\n            Object.prototype.hasOwnProperty.call((selector as any)[fieldName], '$eq')\n        ) {\n            sortIrrelevevantFields.add(fieldName);\n        }\n    });\n\n\n    const optimalSortIndex = query.sort.map(sortField => Object.keys(sortField)[0]);\n    const optimalSortIndexCompareString = optimalSortIndex\n        .filter(f => !sortIrrelevevantFields.has(f))\n        .join(',');\n\n    let currentBestQuality = -1;\n    let currentBestQueryPlan: RxQueryPlan | undefined;\n\n    /**\n     * Calculate one query plan for each index\n     * and then test which of the plans is best.\n     */\n    indexes.forEach((index) => {\n        let inclusiveEnd = true;\n        let inclusiveStart = true;\n        const opts: RxQueryPlanerOpts[] = index.map(indexField => {\n            const matcher = (selector as any)[indexField];\n            const operators = matcher ? Object.keys(matcher) : [];\n\n            let matcherOpts: RxQueryPlanerOpts = {} as any;\n            if (\n                !matcher ||\n                !operators.length\n            ) {\n                const startKey = inclusiveStart ? INDEX_MIN : INDEX_MAX;\n                matcherOpts = {\n                    startKey,\n                    endKey: inclusiveEnd ? INDEX_MAX : INDEX_MIN,\n                    inclusiveStart: true,\n                    inclusiveEnd: true\n                };\n            } else {\n                operators.forEach(operator => {\n                    if (LOGICAL_OPERATORS.has(operator)) {\n                        const operatorValue = matcher[operator];\n                        const partialOpts = getMatcherQueryOpts(operator, operatorValue);\n                        matcherOpts = Object.assign(matcherOpts, partialOpts);\n                    }\n                });\n            }\n\n            // fill missing attributes\n            if (typeof matcherOpts.startKey === 'undefined') {\n                matcherOpts.startKey = INDEX_MIN;\n            }\n            if (typeof matcherOpts.endKey === 'undefined') {\n                matcherOpts.endKey = INDEX_MAX;\n            }\n            if (typeof matcherOpts.inclusiveStart === 'undefined') {\n                matcherOpts.inclusiveStart = true;\n            }\n            if (typeof matcherOpts.inclusiveEnd === 'undefined') {\n                matcherOpts.inclusiveEnd = true;\n            }\n\n            if (inclusiveStart && !matcherOpts.inclusiveStart) {\n                inclusiveStart = false;\n            }\n            if (inclusiveEnd && !matcherOpts.inclusiveEnd) {\n                inclusiveEnd = false;\n            }\n\n            return matcherOpts;\n        });\n\n\n        const startKeys = opts.map(opt => opt.startKey);\n        const endKeys = opts.map(opt => opt.endKey);\n        const queryPlan: RxQueryPlan = {\n            index,\n            startKeys,\n            endKeys,\n            inclusiveEnd,\n            inclusiveStart,\n            sortSatisfiedByIndex: !hasDescSorting && optimalSortIndexCompareString === index.filter(f => !sortIrrelevevantFields.has(f)).join(','),\n            selectorSatisfiedByIndex: isSelectorSatisfiedByIndex(index, query.selector, startKeys, endKeys)\n        };\n        const quality = rateQueryPlan(\n            schema,\n            query,\n            queryPlan\n        );\n        if (\n            (\n                quality >= currentBestQuality\n            ) ||\n            query.index\n        ) {\n            currentBestQuality = quality;\n            currentBestQueryPlan = queryPlan;\n        }\n    });\n\n    /**\n     * In all cases and index must be found\n     */\n    if (!currentBestQueryPlan) {\n        throw newRxError('SNH', {\n            query\n        });\n    }\n\n    return currentBestQueryPlan;\n}\n\nexport const LOGICAL_OPERATORS = new Set(['$eq', '$gt', '$gte', '$lt', '$lte']);\nexport const LOWER_BOUND_LOGICAL_OPERATORS = new Set(['$eq', '$gt', '$gte']);\nexport const UPPER_BOUND_LOGICAL_OPERATORS = new Set(['$eq', '$lt', '$lte']);\n\n\nexport function isSelectorSatisfiedByIndex(\n    index: string[],\n    selector: MangoQuerySelector<any>,\n    startKeys: RxQueryPlanKey[],\n    endKeys: RxQueryPlanKey[]\n): boolean {\n\n\n    /**\n     * Not satisfied if one or more operators are non-logical\n     * operators that can never be satisfied by an index.\n     */\n    const selectorEntries = Object.entries(selector);\n    const hasNonMatchingOperator = selectorEntries\n        .find(([fieldName, operation]) => {\n            if (!index.includes(fieldName)) {\n                return true;\n            }\n            const hasNonLogicOperator = Object.entries(operation as any)\n                .find(([op, _value]) => !LOGICAL_OPERATORS.has(op));\n            return hasNonLogicOperator;\n        });\n\n    if (hasNonMatchingOperator) {\n        return false;\n    }\n\n    /**\n     * Not satisfied if contains $and or $or operations.\n     */\n    if (selector.$and || selector.$or) {\n        return false;\n    }\n\n\n\n    // ensure all lower bound in index\n    const satisfieldLowerBound: string[] = [];\n    const lowerOperatorFieldNames = new Set<string>();\n    for (const [fieldName, operation] of Object.entries(selector)) {\n        if (!index.includes(fieldName)) {\n            return false;\n        }\n\n        // If more then one logic op on the same field, we have to selector-match.\n        const lowerLogicOps = Object.keys(operation as any).filter(key => LOWER_BOUND_LOGICAL_OPERATORS.has(key));\n        if (lowerLogicOps.length > 1) {\n            return false;\n        }\n\n        const hasLowerLogicOp = lowerLogicOps[0];\n        if (hasLowerLogicOp) {\n            lowerOperatorFieldNames.add(fieldName);\n        }\n        if (hasLowerLogicOp !== '$eq') {\n            if (satisfieldLowerBound.length > 0) {\n                return false;\n            } else {\n                satisfieldLowerBound.push(hasLowerLogicOp);\n            }\n        }\n    }\n\n    // ensure all upper bound in index\n    const satisfieldUpperBound: string[] = [];\n    const upperOperatorFieldNames = new Set<string>();\n    for (const [fieldName, operation] of Object.entries(selector)) {\n        if (!index.includes(fieldName)) {\n            return false;\n        }\n\n        // If more then one logic op on the same field, we have to selector-match.\n        const upperLogicOps = Object.keys(operation as any).filter(key => UPPER_BOUND_LOGICAL_OPERATORS.has(key));\n        if (upperLogicOps.length > 1) {\n            return false;\n        }\n\n        const hasUperLogicOp = upperLogicOps[0];\n        if (hasUperLogicOp) {\n            upperOperatorFieldNames.add(fieldName);\n        }\n        if (hasUperLogicOp !== '$eq') {\n            if (satisfieldUpperBound.length > 0) {\n                return false;\n            } else {\n                satisfieldUpperBound.push(hasUperLogicOp);\n            }\n        }\n    }\n\n\n    /**\n     * If the index contains a non-relevant field between\n     * the relevant fields, then the index is not satisfying.\n     */\n    let i = 0;\n    for (const fieldName of index) {\n        for (const set of [\n            lowerOperatorFieldNames,\n            upperOperatorFieldNames\n        ]) {\n            if (\n                !set.has(fieldName) &&\n                set.size > 0\n            ) {\n                return false;\n            }\n            set.delete(fieldName);\n        }\n\n        const startKey = startKeys[i];\n        const endKey = endKeys[i];\n\n        if (\n            startKey !== endKey && (\n                lowerOperatorFieldNames.size > 0 &&\n                upperOperatorFieldNames.size > 0\n            )\n        ) {\n            return false;\n        }\n\n        i++;\n    }\n\n    return true;\n}\n\nexport function getMatcherQueryOpts(\n    operator: string,\n    operatorValue: any\n): Partial<RxQueryPlanerOpts> {\n    switch (operator) {\n        case '$eq':\n            return {\n                startKey: operatorValue,\n                endKey: operatorValue,\n                inclusiveEnd: true,\n                inclusiveStart: true\n            };\n        case '$lte':\n            return {\n                endKey: operatorValue,\n                inclusiveEnd: true\n            };\n        case '$gte':\n            return {\n                startKey: operatorValue,\n                inclusiveStart: true\n            };\n        case '$lt':\n            return {\n                endKey: operatorValue,\n                inclusiveEnd: false\n            };\n        case '$gt':\n            return {\n                startKey: operatorValue,\n                inclusiveStart: false\n            };\n        default:\n            throw new Error('SNH');\n    }\n}\n\n\n/**\n * Returns a number that determines the quality of the query plan.\n * Higher number means better query plan.\n */\nexport function rateQueryPlan<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    query: FilledMangoQuery<RxDocType>,\n    queryPlan: RxQueryPlan\n): number {\n    let quality: number = 0;\n    const addQuality = (value: number) => {\n        if (value > 0) {\n            quality = quality + value;\n        }\n    };\n\n    const pointsPerMatchingKey = 10;\n\n    const nonMinKeyCount = countUntilNotMatching(queryPlan.startKeys, keyValue => keyValue !== INDEX_MIN && keyValue !== INDEX_MAX);\n    addQuality(nonMinKeyCount * pointsPerMatchingKey);\n\n    const nonMaxKeyCount = countUntilNotMatching(queryPlan.startKeys, keyValue => keyValue !== INDEX_MAX && keyValue !== INDEX_MIN);\n    addQuality(nonMaxKeyCount * pointsPerMatchingKey);\n\n    const equalKeyCount = countUntilNotMatching(queryPlan.startKeys, (keyValue, idx) => {\n        if (keyValue === queryPlan.endKeys[idx]) {\n            return true;\n        } else {\n            return false;\n        }\n    });\n    addQuality(equalKeyCount * pointsPerMatchingKey * 1.5);\n\n    const pointsIfNoReSortMustBeDone = queryPlan.sortSatisfiedByIndex ? 5 : 0;\n    addQuality(pointsIfNoReSortMustBeDone);\n\n    return quality;\n}\n", "class MingoError extends Error {\n}\nconst MAX_INT = 2147483647;\nconst MIN_INT = -2147483648;\nconst MAX_LONG = Number.MAX_SAFE_INTEGER;\nconst MIN_LONG = Number.MIN_SAFE_INTEGER;\nconst MISSING = Symbol(\"missing\");\nconst CYCLE_FOUND_ERROR = Object.freeze(\n  new Error(\"mingo: cycle detected while processing object/array\")\n);\nconst OBJECT_TAG = \"[object Object]\";\nconst OBJECT_TYPE_RE = /^\\[object ([a-zA-Z0-9]+)\\]$/;\nconst DEFAULT_HASH_FUNCTION = (value) => {\n  const s = stringify(value);\n  let hash = 0;\n  let i = s.length;\n  while (i)\n    hash = (hash << 5) - hash ^ s.charCodeAt(--i);\n  return hash >>> 0;\n};\nconst JS_SIMPLE_TYPES = /* @__PURE__ */ new Set([\n  \"null\",\n  \"undefined\",\n  \"boolean\",\n  \"number\",\n  \"string\",\n  \"date\",\n  \"regexp\"\n]);\nconst SORT_ORDER_BY_TYPE = {\n  null: 0,\n  undefined: 0,\n  number: 1,\n  string: 2,\n  object: 3,\n  array: 4,\n  boolean: 5,\n  date: 6,\n  regexp: 7,\n  function: 8\n};\nconst compare = (a, b) => {\n  if (a === MISSING)\n    a = void 0;\n  if (b === MISSING)\n    b = void 0;\n  const [u, v] = [a, b].map(\n    (n) => SORT_ORDER_BY_TYPE[getType(n).toLowerCase()]\n  );\n  if (u !== v)\n    return u - v;\n  if (u === 1 || u === 2 || u === 6) {\n    if (a < b)\n      return -1;\n    if (a > b)\n      return 1;\n    return 0;\n  }\n  if (isEqual(a, b))\n    return 0;\n  if (a < b)\n    return -1;\n  if (a > b)\n    return 1;\n  return 0;\n};\nfunction assert(condition, message) {\n  if (!condition)\n    throw new MingoError(message);\n}\nconst getType = (v) => OBJECT_TYPE_RE.exec(Object.prototype.toString.call(v))[1];\nconst isBoolean = (v) => typeof v === \"boolean\";\nconst isString = (v) => typeof v === \"string\";\nconst isSymbol = (v) => typeof v === \"symbol\";\nconst isNumber = (v) => !isNaN(v) && typeof v === \"number\";\nconst isBigInt = (v) => !isNaN(v) && typeof v === \"bigint\";\nconst isNotNaN = (v) => !(isNaN(v) && typeof v === \"number\");\nconst isArray = Array.isArray;\nconst isObject = (v) => {\n  if (!v)\n    return false;\n  const proto = Object.getPrototypeOf(v);\n  return (proto === Object.prototype || proto === null) && OBJECT_TAG === Object.prototype.toString.call(v);\n};\nconst isObjectLike = (v) => v === Object(v);\nconst isDate = (v) => v instanceof Date;\nconst isRegExp = (v) => v instanceof RegExp;\nconst isFunction = (v) => typeof v === \"function\";\nconst isNil = (v) => v === null || v === void 0;\nconst inArray = (arr, item) => arr.includes(item);\nconst notInArray = (arr, item) => !inArray(arr, item);\nconst truthy = (arg, strict = true) => !!arg || strict && arg === \"\";\nconst isEmpty = (x) => isNil(x) || isString(x) && !x || x instanceof Array && x.length === 0 || isObject(x) && Object.keys(x).length === 0;\nconst isMissing = (v) => v === MISSING;\nconst ensureArray = (x) => x instanceof Array ? x : [x];\nconst has = (obj, prop) => !!obj && Object.prototype.hasOwnProperty.call(obj, prop);\nconst isTypedArray = (v) => typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView(v);\nconst INSTANCE_CLONE = [isDate, isRegExp, isTypedArray];\nconst cloneInternal = (val, refs) => {\n  if (isNil(val))\n    return val;\n  if (refs.has(val))\n    throw CYCLE_FOUND_ERROR;\n  const ctor = val.constructor;\n  if (INSTANCE_CLONE.some((f) => f(val)))\n    return new ctor(val);\n  try {\n    refs.add(val);\n    if (isArray(val))\n      return val.map((v) => cloneInternal(v, refs));\n    if (isObject(val)) {\n      const res = {};\n      for (const k in val)\n        res[k] = cloneInternal(val[k], refs);\n      return res;\n    }\n  } finally {\n    refs.delete(val);\n  }\n  return val;\n};\nconst cloneDeep = (obj) => cloneInternal(obj, /* @__PURE__ */ new Set());\nconst mergeable = (left, right) => isObject(left) && isObject(right) || isArray(left) && isArray(right);\nfunction merge(target, obj, options) {\n  options = options || { flatten: false };\n  if (isMissing(target) || isNil(target))\n    return obj;\n  if (isMissing(obj) || isNil(obj))\n    return target;\n  if (!mergeable(target, obj)) {\n    if (options.skipValidation)\n      return obj || target;\n    throw Error(\"mismatched types. must both be array or object\");\n  }\n  options.skipValidation = true;\n  if (isArray(target)) {\n    const result = target;\n    const input = obj;\n    if (options.flatten) {\n      let i = 0;\n      let j = 0;\n      while (i < result.length && j < input.length) {\n        result[i] = merge(result[i++], input[j++], options);\n      }\n      while (j < input.length) {\n        result.push(obj[j++]);\n      }\n    } else {\n      into(result, input);\n    }\n  } else {\n    for (const k in obj) {\n      target[k] = merge(\n        target[k],\n        obj[k],\n        options\n      );\n    }\n  }\n  return target;\n}\nfunction buildHashIndex(arr, hashFunction = DEFAULT_HASH_FUNCTION) {\n  const map = /* @__PURE__ */ new Map();\n  arr.forEach((o, i) => {\n    const h = hashCode(o, hashFunction);\n    if (map.has(h)) {\n      if (!map.get(h).some((j) => isEqual(arr[j], o))) {\n        map.get(h).push(i);\n      }\n    } else {\n      map.set(h, [i]);\n    }\n  });\n  return map;\n}\nfunction intersection(input, hashFunction = DEFAULT_HASH_FUNCTION) {\n  if (input.some((arr) => arr.length == 0))\n    return [];\n  if (input.length === 1)\n    return Array.from(input);\n  const sortedIndex = sortBy(\n    input.map((a, i) => [i, a.length]),\n    (a) => a[1]\n  );\n  const smallest = input[sortedIndex[0][0]];\n  const map = buildHashIndex(smallest, hashFunction);\n  const rmap = /* @__PURE__ */ new Map();\n  const results = new Array();\n  map.forEach((v, k) => {\n    const lhs = v.map((j) => smallest[j]);\n    const res = lhs.map((_) => 0);\n    const stable = lhs.map((_) => [sortedIndex[0][0], 0]);\n    let found = false;\n    for (let i = 1; i < input.length; i++) {\n      const [currIndex, _] = sortedIndex[i];\n      const arr = input[currIndex];\n      if (!rmap.has(i))\n        rmap.set(i, buildHashIndex(arr));\n      if (rmap.get(i).has(k)) {\n        const rhs = rmap.get(i).get(k).map((j) => arr[j]);\n        found = lhs.map(\n          (s, n) => rhs.some((t, m) => {\n            const p = res[n];\n            if (isEqual(s, t)) {\n              res[n]++;\n              if (currIndex < stable[n][0]) {\n                stable[n] = [currIndex, rmap.get(i).get(k)[m]];\n              }\n            }\n            return p < res[n];\n          })\n        ).some(Boolean);\n      }\n      if (!found)\n        return;\n    }\n    if (found) {\n      into(\n        results,\n        res.map((n, i) => {\n          return n === input.length - 1 ? [lhs[i], stable[i]] : MISSING;\n        }).filter((n) => n !== MISSING)\n      );\n    }\n  });\n  return results.sort((a, b) => {\n    const [_i, [u, m]] = a;\n    const [_j, [v, n]] = b;\n    const r = compare(u, v);\n    if (r !== 0)\n      return r;\n    return compare(m, n);\n  }).map((v) => v[0]);\n}\nfunction flatten(xs, depth = 0) {\n  const arr = new Array();\n  function flatten2(ys, n) {\n    for (let i = 0, len = ys.length; i < len; i++) {\n      if (isArray(ys[i]) && (n > 0 || n < 0)) {\n        flatten2(ys[i], Math.max(-1, n - 1));\n      } else {\n        arr.push(ys[i]);\n      }\n    }\n  }\n  flatten2(xs, depth);\n  return arr;\n}\nconst getMembersOf = (value) => {\n  let [proto, names] = [\n    Object.getPrototypeOf(value),\n    Object.getOwnPropertyNames(value)\n  ];\n  let activeProto = proto;\n  while (!names.length && proto !== Object.prototype && proto !== Array.prototype) {\n    activeProto = proto;\n    names = Object.getOwnPropertyNames(proto);\n    proto = Object.getPrototypeOf(proto);\n  }\n  const o = {};\n  names.forEach((k) => o[k] = value[k]);\n  return [o, activeProto];\n};\nfunction isEqual(a, b) {\n  if (a === b || Object.is(a, b))\n    return true;\n  const ctor = !!a && a.constructor || a;\n  if (a === null || b === null || a === void 0 || b === void 0 || ctor !== b.constructor || ctor === Function) {\n    return false;\n  }\n  if (ctor === Array || ctor === Object) {\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    if (aKeys.length !== bKeys.length)\n      return false;\n    if ((/* @__PURE__ */ new Set([...aKeys, ...bKeys])).size != aKeys.length)\n      return false;\n    for (const k of aKeys)\n      if (!isEqual(a[k], b[k]))\n        return false;\n    return true;\n  }\n  const proto = Object.getPrototypeOf(a);\n  const cmp = isTypedArray(a) || proto !== Object.prototype && proto !== Array.prototype && Object.prototype.hasOwnProperty.call(proto, \"toString\");\n  return cmp && a.toString() === b.toString();\n}\nfunction unique(input, hashFunction = DEFAULT_HASH_FUNCTION) {\n  const result = input.map((_) => MISSING);\n  buildHashIndex(input, hashFunction).forEach((v, _) => {\n    v.forEach((i) => result[i] = input[i]);\n  });\n  return result.filter((v) => v !== MISSING);\n}\nconst toString = (v, cycle) => {\n  if (v === null)\n    return \"null\";\n  if (v === void 0)\n    return \"undefined\";\n  const ctor = v.constructor;\n  switch (ctor) {\n    case RegExp:\n    case Number:\n    case Boolean:\n    case Function:\n    case Symbol:\n      return v.toString();\n    case String:\n      return JSON.stringify(v);\n    case Date:\n      return v.toISOString();\n  }\n  if (isTypedArray(v))\n    return ctor.name + \"[\" + v.toString() + \"]\";\n  if (cycle.has(v))\n    throw CYCLE_FOUND_ERROR;\n  try {\n    cycle.add(v);\n    if (isArray(v)) {\n      return \"[\" + v.map((s) => toString(s, cycle)).join(\",\") + \"]\";\n    }\n    if (ctor === Object) {\n      return \"{\" + Object.keys(v).sort().map((k) => k + \":\" + toString(v[k], cycle)).join(\",\") + \"}\";\n    }\n    const proto = Object.getPrototypeOf(v);\n    if (proto !== Object.prototype && proto !== Array.prototype && Object.prototype.hasOwnProperty.call(proto, \"toString\")) {\n      return ctor.name + \"(\" + JSON.stringify(v.toString()) + \")\";\n    }\n    const [members, _] = getMembersOf(v);\n    return ctor.name + toString(members, cycle);\n  } finally {\n    cycle.delete(v);\n  }\n};\nconst stringify = (value) => toString(value, /* @__PURE__ */ new Set());\nfunction hashCode(value, hashFunction) {\n  hashFunction = hashFunction || DEFAULT_HASH_FUNCTION;\n  if (isNil(value))\n    return null;\n  return hashFunction(value).toString();\n}\nfunction sortBy(collection, keyFn, comparator = compare) {\n  if (isEmpty(collection))\n    return collection;\n  const sorted = new Array();\n  const result = new Array();\n  for (let i = 0; i < collection.length; i++) {\n    const obj = collection[i];\n    const key = keyFn(obj, i);\n    if (isNil(key)) {\n      result.push(obj);\n    } else {\n      sorted.push([key, obj]);\n    }\n  }\n  sorted.sort((a, b) => comparator(a[0], b[0]));\n  return into(\n    result,\n    sorted.map((o) => o[1])\n  );\n}\nfunction groupBy(collection, keyFn, hashFunction = DEFAULT_HASH_FUNCTION) {\n  if (collection.length < 1)\n    return /* @__PURE__ */ new Map();\n  const lookup = /* @__PURE__ */ new Map();\n  const result = /* @__PURE__ */ new Map();\n  for (let i = 0; i < collection.length; i++) {\n    const obj = collection[i];\n    const key = keyFn(obj, i);\n    const hash = hashCode(key, hashFunction);\n    if (hash === null) {\n      if (result.has(null)) {\n        result.get(null).push(obj);\n      } else {\n        result.set(null, [obj]);\n      }\n    } else {\n      const existingKey = lookup.has(hash) ? lookup.get(hash).find((k) => isEqual(k, key)) : null;\n      if (isNil(existingKey)) {\n        result.set(key, [obj]);\n        if (lookup.has(hash)) {\n          lookup.get(hash).push(key);\n        } else {\n          lookup.set(hash, [key]);\n        }\n      } else {\n        result.get(existingKey).push(obj);\n      }\n    }\n  }\n  return result;\n}\nconst MAX_ARRAY_PUSH = 5e4;\nfunction into(target, ...rest) {\n  if (target instanceof Array) {\n    return rest.reduce(\n      (acc, arr) => {\n        let i = Math.ceil(arr.length / MAX_ARRAY_PUSH);\n        let begin = 0;\n        while (i-- > 0) {\n          Array.prototype.push.apply(\n            acc,\n            arr.slice(begin, begin + MAX_ARRAY_PUSH)\n          );\n          begin += MAX_ARRAY_PUSH;\n        }\n        return acc;\n      },\n      target\n    );\n  } else {\n    return rest.filter(isObjectLike).reduce((acc, item) => {\n      Object.assign(acc, item);\n      return acc;\n    }, target);\n  }\n}\nfunction memoize(fn, hashFunction = DEFAULT_HASH_FUNCTION) {\n  return /* @__PURE__ */ ((memo) => {\n    return (...args) => {\n      const key = hashCode(args, hashFunction) || \"\";\n      if (!has(memo, key)) {\n        memo[key] = fn.apply(this, args);\n      }\n      return memo[key];\n    };\n  })({\n    /* storage */\n  });\n}\nfunction getValue(obj, key) {\n  return isObjectLike(obj) ? obj[key] : void 0;\n}\nfunction unwrap(arr, depth) {\n  if (depth < 1)\n    return arr;\n  while (depth-- && arr.length === 1)\n    arr = arr[0];\n  return arr;\n}\nfunction resolve(obj, selector, options) {\n  let depth = 0;\n  function resolve2(o, path) {\n    let value = o;\n    for (let i = 0; i < path.length; i++) {\n      const field = path[i];\n      const isText = /^\\d+$/.exec(field) === null;\n      if (isText && value instanceof Array) {\n        if (i === 0 && depth > 0)\n          break;\n        depth += 1;\n        const subpath = path.slice(i);\n        value = value.reduce((acc, item) => {\n          const v = resolve2(item, subpath);\n          if (v !== void 0)\n            acc.push(v);\n          return acc;\n        }, []);\n        break;\n      } else {\n        value = getValue(value, field);\n      }\n      if (value === void 0)\n        break;\n    }\n    return value;\n  }\n  const result = JS_SIMPLE_TYPES.has(getType(obj).toLowerCase()) ? obj : resolve2(obj, selector.split(\".\"));\n  return result instanceof Array && options?.unwrapArray ? unwrap(result, depth) : result;\n}\nfunction resolveGraph(obj, selector, options) {\n  const names = selector.split(\".\");\n  const key = names[0];\n  const next = names.slice(1).join(\".\");\n  const isIndex = /^\\d+$/.exec(key) !== null;\n  const hasNext = names.length > 1;\n  let result;\n  let value;\n  if (obj instanceof Array) {\n    if (isIndex) {\n      result = getValue(obj, Number(key));\n      if (hasNext) {\n        result = resolveGraph(result, next, options);\n      }\n      result = [result];\n    } else {\n      result = [];\n      for (const item of obj) {\n        value = resolveGraph(item, selector, options);\n        if (options?.preserveMissing) {\n          if (value === void 0) {\n            value = MISSING;\n          }\n          result.push(value);\n        } else if (value !== void 0) {\n          result.push(value);\n        }\n      }\n    }\n  } else {\n    value = getValue(obj, key);\n    if (hasNext) {\n      value = resolveGraph(value, next, options);\n    }\n    if (value === void 0)\n      return void 0;\n    result = options?.preserveKeys ? { ...obj } : {};\n    result[key] = value;\n  }\n  return result;\n}\nfunction filterMissing(obj) {\n  if (obj instanceof Array) {\n    for (let i = obj.length - 1; i >= 0; i--) {\n      if (obj[i] === MISSING) {\n        obj.splice(i, 1);\n      } else {\n        filterMissing(obj[i]);\n      }\n    }\n  } else if (isObject(obj)) {\n    for (const k in obj) {\n      if (has(obj, k)) {\n        filterMissing(obj[k]);\n      }\n    }\n  }\n}\nconst NUMBER_RE = /^\\d+$/;\nfunction walk(obj, selector, fn, options) {\n  const names = selector.split(\".\");\n  const key = names[0];\n  const next = names.slice(1).join(\".\");\n  if (names.length === 1) {\n    if (isObject(obj) || isArray(obj) && NUMBER_RE.test(key)) {\n      fn(obj, key);\n    }\n  } else {\n    if (options?.buildGraph && isNil(obj[key])) {\n      obj[key] = {};\n    }\n    const item = obj[key];\n    if (!item)\n      return;\n    const isNextArrayIndex = !!(names.length > 1 && NUMBER_RE.test(names[1]));\n    if (item instanceof Array && options?.descendArray && !isNextArrayIndex) {\n      item.forEach((e) => walk(e, next, fn, options));\n    } else {\n      walk(item, next, fn, options);\n    }\n  }\n}\nfunction setValue(obj, selector, value) {\n  walk(\n    obj,\n    selector,\n    (item, key) => {\n      item[key] = isFunction(value) ? value(item[key]) : value;\n    },\n    { buildGraph: true }\n  );\n}\nfunction removeValue(obj, selector, options) {\n  walk(\n    obj,\n    selector,\n    (item, key) => {\n      if (item instanceof Array) {\n        if (/^\\d+$/.test(key)) {\n          item.splice(parseInt(key), 1);\n        } else if (options && options.descendArray) {\n          for (const elem of item) {\n            if (isObject(elem)) {\n              delete elem[key];\n            }\n          }\n        }\n      } else if (isObject(item)) {\n        delete item[key];\n      }\n    },\n    options\n  );\n}\nconst OPERATOR_NAME_PATTERN = /^\\$[a-zA-Z0-9_]+$/;\nfunction isOperator(name) {\n  return OPERATOR_NAME_PATTERN.test(name);\n}\nfunction normalize(expr) {\n  if (JS_SIMPLE_TYPES.has(getType(expr).toLowerCase())) {\n    return isRegExp(expr) ? { $regex: expr } : { $eq: expr };\n  }\n  if (isObjectLike(expr)) {\n    const exprObj = expr;\n    if (!Object.keys(exprObj).some(isOperator)) {\n      return { $eq: expr };\n    }\n    if (has(expr, \"$regex\")) {\n      const newExpr = { ...expr };\n      newExpr[\"$regex\"] = new RegExp(\n        expr[\"$regex\"],\n        expr[\"$options\"]\n      );\n      delete newExpr[\"$options\"];\n      return newExpr;\n    }\n  }\n  return expr;\n}\nfunction findInsertIndex(sorted, item) {\n  let lo = 0;\n  let hi = sorted.length - 1;\n  while (lo <= hi) {\n    const mid = Math.round(lo + (hi - lo) / 2);\n    if (compare(item, sorted[mid]) < 0) {\n      hi = mid - 1;\n    } else if (compare(item, sorted[mid]) > 0) {\n      lo = mid + 1;\n    } else {\n      return mid;\n    }\n  }\n  return lo;\n}\nexport {\n  MAX_INT,\n  MAX_LONG,\n  MIN_INT,\n  MIN_LONG,\n  MingoError,\n  assert,\n  cloneDeep,\n  compare,\n  ensureArray,\n  filterMissing,\n  findInsertIndex,\n  flatten,\n  getType,\n  groupBy,\n  has,\n  hashCode,\n  inArray,\n  intersection,\n  into,\n  isArray,\n  isBigInt,\n  isBoolean,\n  isDate,\n  isEmpty,\n  isEqual,\n  isFunction,\n  isMissing,\n  isNil,\n  isNotNaN,\n  isNumber,\n  isObject,\n  isObjectLike,\n  isOperator,\n  isRegExp,\n  isString,\n  isSymbol,\n  memoize,\n  merge,\n  normalize,\n  notInArray,\n  removeValue,\n  resolve,\n  resolveGraph,\n  setValue,\n  sortBy,\n  stringify,\n  truthy,\n  unique,\n  walk\n};\n", "import {\n  assert,\n  has,\n  isArray,\n  isFunction,\n  isNil,\n  isObject,\n  isObjectLike,\n  isOperator,\n  isString,\n  MingoError,\n  resolve\n} from \"./util\";\nvar ProcessingMode = /* @__PURE__ */ ((ProcessingMode2) => {\n  ProcessingMode2[\"CLONE_ALL\"] = \"CLONE_ALL\";\n  ProcessingMode2[\"CLONE_INPUT\"] = \"CLONE_INPUT\";\n  ProcessingMode2[\"CLONE_OUTPUT\"] = \"CLONE_OUTPUT\";\n  ProcessingMode2[\"CLONE_OFF\"] = \"CLONE_OFF\";\n  return ProcessingMode2;\n})(ProcessingMode || {});\nclass ComputeOptions {\n  constructor(_opts, _root, _local, timestamp = Date.now()) {\n    this._opts = _opts;\n    this._root = _root;\n    this._local = _local;\n    this.timestamp = timestamp;\n    this.update(_root, _local);\n  }\n  /**\n   * Initialize new ComputeOptions.\n   *\n   * @param options\n   * @param root\n   * @param local\n   * @returns {ComputeOptions}\n   */\n  static init(options, root, local) {\n    return options instanceof ComputeOptions ? new ComputeOptions(\n      options._opts,\n      isNil(options.root) ? root : options.root,\n      Object.assign({}, options.local, local)\n    ) : new ComputeOptions(options, root, local);\n  }\n  /** Updates the internal mutable state. */\n  update(root, local) {\n    this._root = root;\n    this._local = local ? Object.assign({}, local, {\n      variables: Object.assign({}, this._local?.variables, local?.variables)\n    }) : local;\n    return this;\n  }\n  getOptions() {\n    return Object.freeze({\n      ...this._opts,\n      context: Context.from(this._opts.context)\n    });\n  }\n  get root() {\n    return this._root;\n  }\n  get local() {\n    return this._local;\n  }\n  get idKey() {\n    return this._opts.idKey;\n  }\n  get collation() {\n    return this._opts?.collation;\n  }\n  get processingMode() {\n    return this._opts?.processingMode || \"CLONE_OFF\" /* CLONE_OFF */;\n  }\n  get useStrictMode() {\n    return this._opts?.useStrictMode;\n  }\n  get scriptEnabled() {\n    return this._opts?.scriptEnabled;\n  }\n  get useGlobalContext() {\n    return this._opts?.useGlobalContext;\n  }\n  get hashFunction() {\n    return this._opts?.hashFunction;\n  }\n  get collectionResolver() {\n    return this._opts?.collectionResolver;\n  }\n  get jsonSchemaValidator() {\n    return this._opts?.jsonSchemaValidator;\n  }\n  get variables() {\n    return this._opts?.variables;\n  }\n  get context() {\n    return this._opts?.context;\n  }\n}\nfunction initOptions(options) {\n  return options instanceof ComputeOptions ? options.getOptions() : Object.freeze({\n    idKey: \"_id\",\n    scriptEnabled: true,\n    useStrictMode: true,\n    useGlobalContext: true,\n    processingMode: \"CLONE_OFF\" /* CLONE_OFF */,\n    ...options,\n    context: options?.context ? Context.from(options?.context) : Context.init({})\n  });\n}\nvar OperatorType = /* @__PURE__ */ ((OperatorType2) => {\n  OperatorType2[\"ACCUMULATOR\"] = \"accumulator\";\n  OperatorType2[\"EXPRESSION\"] = \"expression\";\n  OperatorType2[\"PIPELINE\"] = \"pipeline\";\n  OperatorType2[\"PROJECTION\"] = \"projection\";\n  OperatorType2[\"QUERY\"] = \"query\";\n  OperatorType2[\"WINDOW\"] = \"window\";\n  return OperatorType2;\n})(OperatorType || {});\nclass Context {\n  constructor(ops) {\n    this.operators = {\n      [\"accumulator\" /* ACCUMULATOR */]: {},\n      [\"expression\" /* EXPRESSION */]: {},\n      [\"pipeline\" /* PIPELINE */]: {},\n      [\"projection\" /* PROJECTION */]: {},\n      [\"query\" /* QUERY */]: {},\n      [\"window\" /* WINDOW */]: {}\n    };\n    for (const [type, operators] of Object.entries(ops)) {\n      this.addOperators(type, operators);\n    }\n  }\n  static init(ops = {}) {\n    return new Context(ops);\n  }\n  static from(ctx) {\n    return new Context(ctx.operators);\n  }\n  addOperators(type, ops) {\n    for (const [name, fn] of Object.entries(ops)) {\n      if (!this.getOperator(type, name)) {\n        this.operators[type][name] = fn;\n      }\n    }\n    return this;\n  }\n  // register\n  addAccumulatorOps(ops) {\n    return this.addOperators(\"accumulator\" /* ACCUMULATOR */, ops);\n  }\n  addExpressionOps(ops) {\n    return this.addOperators(\"expression\" /* EXPRESSION */, ops);\n  }\n  addQueryOps(ops) {\n    return this.addOperators(\"query\" /* QUERY */, ops);\n  }\n  addPipelineOps(ops) {\n    return this.addOperators(\"pipeline\" /* PIPELINE */, ops);\n  }\n  addProjectionOps(ops) {\n    return this.addOperators(\"projection\" /* PROJECTION */, ops);\n  }\n  addWindowOps(ops) {\n    return this.addOperators(\"window\" /* WINDOW */, ops);\n  }\n  // getters\n  getOperator(type, name) {\n    return type in this.operators ? this.operators[type][name] || null : null;\n  }\n}\nconst GLOBAL_CONTEXT = Context.init();\nfunction useOperators(type, operators) {\n  for (const [name, fn] of Object.entries(operators)) {\n    assert(\n      isFunction(fn) && isOperator(name),\n      `'${name}' is not a valid operator`\n    );\n    const currentFn = getOperator(type, name, null);\n    assert(\n      !currentFn || fn === currentFn,\n      `${name} already exists for '${type}' operators. Cannot change operator function once registered.`\n    );\n  }\n  switch (type) {\n    case \"accumulator\" /* ACCUMULATOR */:\n      GLOBAL_CONTEXT.addAccumulatorOps(operators);\n      break;\n    case \"expression\" /* EXPRESSION */:\n      GLOBAL_CONTEXT.addExpressionOps(operators);\n      break;\n    case \"pipeline\" /* PIPELINE */:\n      GLOBAL_CONTEXT.addPipelineOps(operators);\n      break;\n    case \"projection\" /* PROJECTION */:\n      GLOBAL_CONTEXT.addProjectionOps(operators);\n      break;\n    case \"query\" /* QUERY */:\n      GLOBAL_CONTEXT.addQueryOps(operators);\n      break;\n    case \"window\" /* WINDOW */:\n      GLOBAL_CONTEXT.addWindowOps(operators);\n      break;\n  }\n}\nfunction getOperator(type, operator, options) {\n  const { context: ctx, useGlobalContext: fallback } = options || {};\n  const fn = ctx ? ctx.getOperator(type, operator) : null;\n  return !fn && fallback ? GLOBAL_CONTEXT.getOperator(type, operator) : fn;\n}\nconst systemVariables = {\n  $$ROOT(_obj, _expr, options) {\n    return options.root;\n  },\n  $$CURRENT(obj, _expr, _options) {\n    return obj;\n  },\n  $$REMOVE(_obj, _expr, _options) {\n    return void 0;\n  },\n  $$NOW(_obj, _expr, options) {\n    return new Date(options.timestamp);\n  }\n};\nconst redactVariables = {\n  $$KEEP(obj, _expr, _options) {\n    return obj;\n  },\n  $$PRUNE(_obj, _expr, _options) {\n    return void 0;\n  },\n  $$DESCEND(obj, expr, options) {\n    if (!has(expr, \"$cond\"))\n      return obj;\n    let result;\n    for (const [key, current] of Object.entries(obj)) {\n      if (isObjectLike(current)) {\n        if (current instanceof Array) {\n          const array = [];\n          for (let elem of current) {\n            if (isObject(elem)) {\n              elem = redact(elem, expr, options.update(elem));\n            }\n            if (!isNil(elem)) {\n              array.push(elem);\n            }\n          }\n          result = array;\n        } else {\n          result = redact(\n            current,\n            expr,\n            options.update(current)\n          );\n        }\n        if (isNil(result)) {\n          delete obj[key];\n        } else {\n          obj[key] = result;\n        }\n      }\n    }\n    return obj;\n  }\n};\nfunction computeValue(obj, expr, operator, options) {\n  const copts = ComputeOptions.init(options, obj);\n  operator = operator || \"\";\n  if (isOperator(operator)) {\n    const callExpression = getOperator(\n      \"expression\" /* EXPRESSION */,\n      operator,\n      options\n    );\n    if (callExpression)\n      return callExpression(obj, expr, copts);\n    const callAccumulator = getOperator(\n      \"accumulator\" /* ACCUMULATOR */,\n      operator,\n      options\n    );\n    if (callAccumulator) {\n      if (!(obj instanceof Array)) {\n        obj = computeValue(obj, expr, null, copts);\n        expr = null;\n      }\n      assert(obj instanceof Array, `'${operator}' target must be an array.`);\n      return callAccumulator(\n        obj,\n        expr,\n        // reset the root object for accumulators.\n        copts.update(null, copts.local)\n      );\n    }\n    throw new MingoError(`operator '${operator}' is not registered`);\n  }\n  if (isString(expr) && expr.length > 0 && expr[0] === \"$\") {\n    if (has(redactVariables, expr)) {\n      return expr;\n    }\n    let context = copts.root;\n    const arr = expr.split(\".\");\n    if (has(systemVariables, arr[0])) {\n      context = systemVariables[arr[0]](\n        obj,\n        null,\n        copts\n      );\n      expr = expr.slice(arr[0].length + 1);\n    } else if (arr[0].slice(0, 2) === \"$$\") {\n      context = Object.assign(\n        {},\n        copts.variables,\n        // global vars\n        // current item is added before local variables because the binding may be changed.\n        { this: obj },\n        copts.local?.variables\n        // local vars\n      );\n      const prefix = arr[0].slice(2);\n      assert(\n        has(context, prefix),\n        `Use of undefined variable: ${prefix}`\n      );\n      expr = expr.slice(2);\n    } else {\n      expr = expr.slice(1);\n    }\n    if (expr === \"\")\n      return context;\n    return resolve(context, expr);\n  }\n  if (isArray(expr)) {\n    return expr.map((item) => computeValue(obj, item, null, copts));\n  } else if (isObject(expr)) {\n    const result = {};\n    for (const [key, val] of Object.entries(expr)) {\n      result[key] = computeValue(obj, val, key, copts);\n      if ([\"expression\" /* EXPRESSION */, \"accumulator\" /* ACCUMULATOR */].some(\n        (t) => !!getOperator(t, key, options)\n      )) {\n        assert(\n          Object.keys(expr).length === 1,\n          \"Invalid aggregation expression '\" + JSON.stringify(expr) + \"'\"\n        );\n        return result[key];\n      }\n    }\n    return result;\n  }\n  return expr;\n}\nfunction redact(obj, expr, options) {\n  const result = computeValue(obj, expr, null, options);\n  return has(redactVariables, result) ? redactVariables[result](obj, expr, options) : result;\n}\nexport {\n  ComputeOptions,\n  Context,\n  OperatorType,\n  ProcessingMode,\n  computeValue,\n  getOperator,\n  initOptions,\n  redact,\n  useOperators\n};\n", "import { MingoError } from \"./util\";\nfunction Lazy(source) {\n  return source instanceof Iterator ? source : new Iterator(source);\n}\nfunction compose(...iterators) {\n  let index = 0;\n  return Lazy(() => {\n    while (index < iterators.length) {\n      const o = iterators[index].next();\n      if (!o.done)\n        return o;\n      index++;\n    }\n    return { done: true };\n  });\n}\nfunction isGenerator(o) {\n  return !!o && typeof o === \"object\" && o?.next instanceof Function;\n}\nfunction dropItem(array, i) {\n  const rest = array.slice(i + 1);\n  array.splice(i);\n  Array.prototype.push.apply(array, rest);\n}\nconst DONE = new Error();\nvar Action = /* @__PURE__ */ ((Action2) => {\n  Action2[Action2[\"MAP\"] = 0] = \"MAP\";\n  Action2[Action2[\"FILTER\"] = 1] = \"FILTER\";\n  Action2[Action2[\"TAKE\"] = 2] = \"TAKE\";\n  Action2[Action2[\"DROP\"] = 3] = \"DROP\";\n  return Action2;\n})(Action || {});\nfunction createCallback(nextFn, iteratees, buffer) {\n  let done = false;\n  let index = -1;\n  let bufferIndex = 0;\n  return function(storeResult) {\n    try {\n      outer:\n        while (!done) {\n          let o = nextFn();\n          index++;\n          let i = -1;\n          const size = iteratees.length;\n          let innerDone = false;\n          while (++i < size) {\n            const r = iteratees[i];\n            switch (r.action) {\n              case 0 /* MAP */:\n                o = r.func(o, index);\n                break;\n              case 1 /* FILTER */:\n                if (!r.func(o, index))\n                  continue outer;\n                break;\n              case 2 /* TAKE */:\n                --r.count;\n                if (!r.count)\n                  innerDone = true;\n                break;\n              case 3 /* DROP */:\n                --r.count;\n                if (!r.count)\n                  dropItem(iteratees, i);\n                continue outer;\n              default:\n                break outer;\n            }\n          }\n          done = innerDone;\n          if (storeResult) {\n            buffer[bufferIndex++] = o;\n          } else {\n            return { value: o, done: false };\n          }\n        }\n    } catch (e) {\n      if (e !== DONE)\n        throw e;\n    }\n    done = true;\n    return { done };\n  };\n}\nclass Iterator {\n  /**\n   * @param {*} source An iterable object or function.\n   *    Array - return one element per cycle\n   *    Object{next:Function} - call next() for the next value (this also handles generator functions)\n   *    Function - call to return the next value\n   * @param {Function} fn An optional transformation function\n   */\n  constructor(source) {\n    this.iteratees = [];\n    this.yieldedValues = [];\n    this.isDone = false;\n    let nextVal;\n    if (source instanceof Function) {\n      source = { next: source };\n    }\n    if (isGenerator(source)) {\n      const src = source;\n      nextVal = () => {\n        const o = src.next();\n        if (o.done)\n          throw DONE;\n        return o.value;\n      };\n    } else if (source instanceof Array) {\n      const data = source;\n      const size = data.length;\n      let index = 0;\n      nextVal = () => {\n        if (index < size)\n          return data[index++];\n        throw DONE;\n      };\n    } else if (!(source instanceof Function)) {\n      throw new MingoError(\n        `Lazy must be initialized with an array, generator, or function.`\n      );\n    }\n    this.getNext = createCallback(nextVal, this.iteratees, this.yieldedValues);\n  }\n  /**\n   * Add an iteratee to this lazy sequence\n   */\n  push(action, value) {\n    if (typeof value === \"function\") {\n      this.iteratees.push({ action, func: value });\n    } else if (typeof value === \"number\") {\n      this.iteratees.push({ action, count: value });\n    }\n    return this;\n  }\n  next() {\n    return this.getNext();\n  }\n  // Iteratees methods\n  /**\n   * Transform each item in the sequence to a new value\n   * @param {Function} f\n   */\n  map(f) {\n    return this.push(0 /* MAP */, f);\n  }\n  /**\n   * Select only items matching the given predicate\n   * @param {Function} pred\n   */\n  filter(predicate) {\n    return this.push(1 /* FILTER */, predicate);\n  }\n  /**\n   * Take given numbe for values from sequence\n   * @param {Number} n A number greater than 0\n   */\n  take(n) {\n    return n > 0 ? this.push(2 /* TAKE */, n) : this;\n  }\n  /**\n   * Drop a number of values from the sequence\n   * @param {Number} n Number of items to drop greater than 0\n   */\n  drop(n) {\n    return n > 0 ? this.push(3 /* DROP */, n) : this;\n  }\n  // Transformations\n  /**\n   * Returns a new lazy object with results of the transformation\n   * The entire sequence is realized.\n   *\n   * @param {Callback<Source, RawArray>} fn Tranform function of type (Array) => (Any)\n   */\n  transform(fn) {\n    const self = this;\n    let iter;\n    return Lazy(() => {\n      if (!iter) {\n        iter = Lazy(fn(self.value()));\n      }\n      return iter.next();\n    });\n  }\n  // Terminal methods\n  /**\n   * Returns the fully realized values of the iterators.\n   * The return value will be an array unless `lazy.first()` was used.\n   * The realized values are cached for subsequent calls.\n   */\n  value() {\n    if (!this.isDone) {\n      this.isDone = this.getNext(true).done;\n    }\n    return this.yieldedValues;\n  }\n  /**\n   * Execute the funcion for each value. Will stop when an execution returns false.\n   * @param {Function} f\n   * @returns {Boolean} false iff `f` return false for AnyVal execution, otherwise true\n   */\n  each(f) {\n    for (; ; ) {\n      const o = this.next();\n      if (o.done)\n        break;\n      if (f(o.value) === false)\n        return false;\n    }\n    return true;\n  }\n  /**\n   * Returns the reduction of sequence according the reducing function\n   *\n   * @param {*} f a reducing function\n   * @param {*} initialValue\n   */\n  reduce(f, initialValue) {\n    let o = this.next();\n    if (initialValue === void 0 && !o.done) {\n      initialValue = o.value;\n      o = this.next();\n    }\n    while (!o.done) {\n      initialValue = f(initialValue, o.value);\n      o = this.next();\n    }\n    return initialValue;\n  }\n  /**\n   * Returns the number of matched items in the sequence\n   */\n  size() {\n    return this.reduce(\n      (acc, _) => ++acc,\n      0\n    );\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n}\nexport {\n  Iterator,\n  Lazy,\n  compose\n};\n", "import {\n  getOperator,\n  initOptions,\n  OperatorType,\n  ProcessingMode\n} from \"./core\";\nimport { Lazy } from \"./lazy\";\nimport { assert, cloneDeep, intersection, isEmpty } from \"./util\";\nclass Aggregator {\n  constructor(pipeline, options) {\n    this.pipeline = pipeline;\n    this.options = initOptions(options);\n  }\n  /**\n   * Returns an `Lazy` iterator for processing results of pipeline\n   *\n   * @param {*} collection An array or iterator object\n   * @returns {Iterator} an iterator object\n   */\n  stream(collection) {\n    let iterator = Lazy(collection);\n    const mode = this.options.processingMode;\n    if (mode == ProcessingMode.CLONE_ALL || mode == ProcessingMode.CLONE_INPUT) {\n      iterator.map(cloneDeep);\n    }\n    const pipelineOperators = new Array();\n    if (!isEmpty(this.pipeline)) {\n      for (const operator of this.pipeline) {\n        const operatorKeys = Object.keys(operator);\n        const opName = operatorKeys[0];\n        const call = getOperator(\n          OperatorType.PIPELINE,\n          opName,\n          this.options\n        );\n        assert(\n          operatorKeys.length === 1 && !!call,\n          `invalid pipeline operator ${opName}`\n        );\n        pipelineOperators.push(opName);\n        iterator = call(iterator, operator[opName], this.options);\n      }\n    }\n    if (mode == ProcessingMode.CLONE_OUTPUT || mode == ProcessingMode.CLONE_ALL && !!intersection([[\"$group\", \"$unwind\"], pipelineOperators]).length) {\n      iterator.map(cloneDeep);\n    }\n    return iterator;\n  }\n  /**\n   * Return the results of the aggregation as an array.\n   *\n   * @param {*} collection\n   * @param {*} query\n   */\n  run(collection) {\n    return this.stream(collection).value();\n  }\n}\nexport {\n  Aggregator\n};\n", "import { Aggregator } from \"./aggregator\";\nimport { compose, Lazy } from \"./lazy\";\nimport { isObject } from \"./util\";\nclass Cursor {\n  constructor(source, predicate, projection, options) {\n    this.source = source;\n    this.predicate = predicate;\n    this.projection = projection;\n    this.options = options;\n    this.operators = [];\n    this.result = null;\n    this.buffer = [];\n  }\n  /** Returns the iterator from running the query */\n  fetch() {\n    if (this.result)\n      return this.result;\n    if (isObject(this.projection)) {\n      this.operators.push({ $project: this.projection });\n    }\n    this.result = Lazy(this.source).filter(this.predicate);\n    if (this.operators.length > 0) {\n      this.result = new Aggregator(this.operators, this.options).stream(\n        this.result\n      );\n    }\n    return this.result;\n  }\n  /** Returns an iterator with the buffered data included */\n  fetchAll() {\n    const buffered = Lazy([...this.buffer]);\n    this.buffer = [];\n    return compose(buffered, this.fetch());\n  }\n  /**\n   * Return remaining objects in the cursor as an array. This method exhausts the cursor\n   * @returns {Array}\n   */\n  all() {\n    return this.fetchAll().value();\n  }\n  /**\n   * Returns the number of objects return in the cursor. This method exhausts the cursor\n   * @returns {Number}\n   */\n  count() {\n    return this.all().length;\n  }\n  /**\n   * Returns a cursor that begins returning results only after passing or skipping a number of documents.\n   * @param {Number} n the number of results to skip.\n   * @return {Cursor} Returns the cursor, so you can chain this call.\n   */\n  skip(n) {\n    this.operators.push({ $skip: n });\n    return this;\n  }\n  /**\n   * Constrains the size of a cursor's result set.\n   * @param {Number} n the number of results to limit to.\n   * @return {Cursor} Returns the cursor, so you can chain this call.\n   */\n  limit(n) {\n    this.operators.push({ $limit: n });\n    return this;\n  }\n  /**\n   * Returns results ordered according to a sort specification.\n   * @param {Object} modifier an object of key and values specifying the sort order. 1 for ascending and -1 for descending\n   * @return {Cursor} Returns the cursor, so you can chain this call.\n   */\n  sort(modifier) {\n    this.operators.push({ $sort: modifier });\n    return this;\n  }\n  /**\n   * Specifies the collation for the cursor returned by the `mingo.Query.find`\n   * @param {*} spec\n   */\n  collation(spec) {\n    this.options = { ...this.options, collation: spec };\n    return this;\n  }\n  /**\n   * Returns the next document in a cursor.\n   * @returns {Object | Boolean}\n   */\n  next() {\n    if (this.buffer.length > 0) {\n      return this.buffer.pop();\n    }\n    const o = this.fetch().next();\n    if (o.done)\n      return;\n    return o.value;\n  }\n  /**\n   * Returns true if the cursor has documents and can be iterated.\n   * @returns {boolean}\n   */\n  hasNext() {\n    if (this.buffer.length > 0)\n      return true;\n    const o = this.fetch().next();\n    if (o.done)\n      return false;\n    this.buffer.push(o.value);\n    return true;\n  }\n  /**\n   * Applies a function to each document in a cursor and collects the return values in an array.\n   * @param fn\n   * @returns {Array}\n   */\n  map(fn) {\n    return this.all().map(fn);\n  }\n  /**\n   * Applies a JavaScript function for every document in a cursor.\n   * @param fn\n   */\n  forEach(fn) {\n    this.all().forEach(fn);\n  }\n  [Symbol.iterator]() {\n    return this.fetchAll();\n  }\n}\nexport {\n  Cursor\n};\n", "import {\n  getOperator,\n  initOptions,\n  OperatorType\n} from \"./core\";\nimport { Cursor } from \"./cursor\";\nimport {\n  assert,\n  inArray,\n  isObject,\n  isOperator,\n  MingoError,\n  normalize\n} from \"./util\";\nclass Query {\n  constructor(condition, options) {\n    this.condition = condition;\n    this.options = initOptions(options);\n    this.compiled = [];\n    this.compile();\n  }\n  compile() {\n    assert(\n      isObject(this.condition),\n      `query criteria must be an object: ${JSON.stringify(this.condition)}`\n    );\n    const whereOperator = {};\n    for (const [field, expr] of Object.entries(this.condition)) {\n      if (\"$where\" === field) {\n        Object.assign(whereOperator, { field, expr });\n      } else if (inArray([\"$and\", \"$or\", \"$nor\", \"$expr\", \"$jsonSchema\"], field)) {\n        this.processOperator(field, field, expr);\n      } else {\n        assert(!isOperator(field), `unknown top level operator: ${field}`);\n        for (const [operator, val] of Object.entries(\n          normalize(expr)\n        )) {\n          this.processOperator(field, operator, val);\n        }\n      }\n      if (whereOperator.field) {\n        this.processOperator(\n          whereOperator.field,\n          whereOperator.field,\n          whereOperator.expr\n        );\n      }\n    }\n  }\n  processOperator(field, operator, value) {\n    const call = getOperator(\n      OperatorType.QUERY,\n      operator,\n      this.options\n    );\n    if (!call) {\n      throw new MingoError(`unknown query operator ${operator}`);\n    }\n    const fn = call(field, value, this.options);\n    this.compiled.push(fn);\n  }\n  /**\n   * Checks if the object passes the query criteria. Returns true if so, false otherwise.\n   *\n   * @param obj The object to test\n   * @returns {boolean} True or false\n   */\n  test(obj) {\n    for (let i = 0, len = this.compiled.length; i < len; i++) {\n      if (!this.compiled[i](obj)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Returns a cursor to select matching documents from the input source.\n   *\n   * @param source A source providing a sequence of documents\n   * @param projection An optional projection criteria\n   * @returns {Cursor} A Cursor for iterating over the results\n   */\n  find(collection, projection) {\n    return new Cursor(\n      collection,\n      (x) => this.test(x),\n      projection || {},\n      this.options\n    );\n  }\n  /**\n   * Remove matched documents from the collection returning the remainder\n   *\n   * @param collection An array of documents\n   * @returns {Array} A new array with matching elements removed\n   */\n  remove(collection) {\n    return collection.reduce((acc, obj) => {\n      if (!this.test(obj))\n        acc.push(obj);\n      return acc;\n    }, []);\n  }\n}\nexport {\n  Query\n};\n", "import { computeValue } from \"../../../core\";\nimport { isDate, isNil, isNumber } from \"../../../util\";\nconst COMMON_YEAR_DAYS_OFFSET = [\n  0,\n  31,\n  59,\n  90,\n  120,\n  151,\n  181,\n  212,\n  243,\n  273,\n  304,\n  334\n];\nconst LEAP_YEAR_DAYS_OFFSET = [\n  0,\n  31,\n  60,\n  91,\n  121,\n  152,\n  182,\n  213,\n  244,\n  274,\n  305,\n  335\n];\nconst p = (y) => (y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400)) % 7;\nconst weeks = (y) => 52 + Number(p(y) == 4 || p(y - 1) == 3);\nconst isLeapYear = (year) => (year & 3) == 0 && (year % 100 != 0 || year % 400 == 0);\nconst getDayOfYear = (d) => (isLeapYear(d.getUTCFullYear()) ? LEAP_YEAR_DAYS_OFFSET : COMMON_YEAR_DAYS_OFFSET)[d.getUTCMonth()] + d.getUTCDate();\nfunction isoWeek(d) {\n  const w = Math.floor((10 + getDayOfYear(d) - (d.getUTCDay() || 7)) / 7);\n  if (w < 1)\n    return weeks(d.getUTCFullYear() - 1);\n  if (w > weeks(d.getUTCFullYear()))\n    return 1;\n  return w;\n}\nfunction isoWeekYear(d) {\n  return d.getUTCFullYear() - Number(d.getUTCMonth() == 0 && d.getUTCDate() == 1 && d.getUTCDay() < 1);\n}\nconst MINUTES_PER_HOUR = 60;\nconst MILLIS_PER_DAY = 1e3 * 60 * 60 * 24;\nconst DURATION_IN_MILLIS = {\n  week: MILLIS_PER_DAY * 7,\n  day: MILLIS_PER_DAY,\n  hour: 1e3 * 60 * 60,\n  minute: 1e3 * 60,\n  second: 1e3,\n  millisecond: 1\n};\nconst DATE_FORMAT = \"%Y-%m-%dT%H:%M:%S.%LZ\";\nconst DATE_PART_INTERVAL = [\n  [\"year\", 0, 9999],\n  [\"month\", 1, 12],\n  [\"day\", 1, 31],\n  [\"hour\", 0, 23],\n  [\"minute\", 0, 59],\n  [\"second\", 0, 59],\n  [\"millisecond\", 0, 999]\n];\nconst DATE_SYM_TABLE = {\n  \"%Y\": { name: \"year\", padding: 4, re: /([0-9]{4})/ },\n  \"%G\": { name: \"year\", padding: 4, re: /([0-9]{4})/ },\n  \"%m\": { name: \"month\", padding: 2, re: /(0[1-9]|1[012])/ },\n  \"%d\": { name: \"day\", padding: 2, re: /(0[1-9]|[12][0-9]|3[01])/ },\n  \"%H\": { name: \"hour\", padding: 2, re: /([01][0-9]|2[0-3])/ },\n  \"%M\": { name: \"minute\", padding: 2, re: /([0-5][0-9])/ },\n  \"%S\": { name: \"second\", padding: 2, re: /([0-5][0-9]|60)/ },\n  \"%L\": { name: \"millisecond\", padding: 3, re: /([0-9]{3})/ },\n  \"%u\": { name: \"weekday\", padding: 1, re: /([1-7])/ },\n  \"%U\": { name: \"week\", padding: 2, re: /([1-4][0-9]?|5[0-3]?)/ },\n  \"%V\": { name: \"isoWeek\", padding: 2, re: /([1-4][0-9]?|5[0-3]?)/ },\n  \"%z\": {\n    name: \"timezone\",\n    padding: 2,\n    re: /(([+-][01][0-9]|2[0-3]):?([0-5][0-9])?)/\n  },\n  \"%Z\": { name: \"minuteOffset\", padding: 3, re: /([+-][0-9]{3})/ }\n  // \"%%\": \"%\",\n};\nfunction parseTimezone(tzstr) {\n  if (isNil(tzstr))\n    return 0;\n  const m = DATE_SYM_TABLE[\"%z\"].re.exec(tzstr);\n  if (!m)\n    throw Error(`invalid or location-based timezone '${tzstr}' not supported`);\n  const hr = parseInt(m[2]) || 0;\n  const min = parseInt(m[3]) || 0;\n  return (Math.abs(hr * MINUTES_PER_HOUR) + min) * (hr < 0 ? -1 : 1);\n}\nfunction formatTimezone(minuteOffset) {\n  return (minuteOffset < 0 ? \"-\" : \"+\") + padDigits(Math.abs(Math.floor(minuteOffset / MINUTES_PER_HOUR)), 2) + padDigits(Math.abs(minuteOffset) % MINUTES_PER_HOUR, 2);\n}\nfunction adjustDate(d, minuteOffset) {\n  d.setUTCMinutes(d.getUTCMinutes() + minuteOffset);\n}\nfunction computeDate(obj, expr, options) {\n  const d = computeValue(obj, expr, null, options);\n  if (isDate(d))\n    return new Date(d);\n  if (isNumber(d))\n    return new Date(d * 1e3);\n  if (d.date) {\n    const date = isDate(d.date) ? new Date(d.date) : new Date(d.date * 1e3);\n    if (d.timezone) {\n      adjustDate(date, parseTimezone(d.timezone));\n    }\n    return date;\n  }\n  throw Error(`cannot convert ${expr?.toString()} to date`);\n}\nfunction padDigits(n, digits) {\n  return new Array(Math.max(digits - String(n).length + 1, 0)).join(\"0\") + n.toString();\n}\nfunction regexQuote(s) {\n  \"^.-*?$\".split(\"\").forEach((c) => {\n    s = s.replace(c, `\\\\${c}`);\n  });\n  return s;\n}\nfunction regexStrip(s) {\n  return s.replace(/^\\//, \"\").replace(/\\/$/, \"\");\n}\nexport {\n  DATE_FORMAT,\n  DATE_PART_INTERVAL,\n  DATE_SYM_TABLE,\n  DURATION_IN_MILLIS,\n  MILLIS_PER_DAY,\n  MINUTES_PER_HOUR,\n  adjustDate,\n  computeDate,\n  formatTimezone,\n  getDayOfYear,\n  isLeapYear,\n  isoWeek,\n  isoWeekYear,\n  padDigits,\n  parseTimezone,\n  regexQuote,\n  regexStrip\n};\n", "import { groupBy, isEqual, MingoError } from \"../../util\";\nimport { $push } from \"../accumulator\";\nimport { MILLIS_PER_DAY } from \"../expression/date/_internal\";\nimport { isUnbounded } from \"../pipeline/_internal\";\nconst MILLIS_PER_UNIT = {\n  week: MILLIS_PER_DAY * 7,\n  day: MILLIS_PER_DAY,\n  hour: MILLIS_PER_DAY / 24,\n  minute: 6e4,\n  second: 1e3,\n  millisecond: 1\n};\nconst memo = /* @__PURE__ */ new WeakMap();\nfunction withMemo(collection, expr, cacheFn, fn) {\n  if (!isUnbounded(expr.parentExpr.output[expr.field].window)) {\n    return fn(cacheFn());\n  }\n  if (!memo.has(collection)) {\n    memo.set(collection, { [expr.field]: cacheFn() });\n  }\n  const data = memo.get(collection);\n  if (data[expr.field] === void 0) {\n    data[expr.field] = cacheFn();\n  }\n  let failed = false;\n  try {\n    return fn(data[expr.field]);\n  } catch (e) {\n    failed = true;\n  } finally {\n    if (failed || expr.documentNumber === collection.length) {\n      delete data[expr.field];\n      if (Object.keys(data).length === 0)\n        memo.delete(collection);\n    }\n  }\n}\nfunction rank(_, collection, expr, options, dense) {\n  return withMemo(\n    collection,\n    expr,\n    () => {\n      const sortKey = \"$\" + Object.keys(expr.parentExpr.sortBy)[0];\n      const values = $push(collection, sortKey, options);\n      const groups = groupBy(\n        values,\n        (_2, n) => values[n],\n        options.hashFunction\n      );\n      return { values, groups };\n    },\n    (input) => {\n      const { values, groups: partitions } = input;\n      if (partitions.size == collection.length) {\n        return expr.documentNumber;\n      }\n      const current = values[expr.documentNumber - 1];\n      let i = 0;\n      let offset = 0;\n      for (const key of partitions.keys()) {\n        if (isEqual(current, key)) {\n          return dense ? i + 1 : offset + 1;\n        }\n        i++;\n        offset += partitions.get(key).length;\n      }\n      throw new MingoError(\n        \"rank: invalid return value. please submit a bug report.\"\n      );\n    }\n  );\n}\nexport {\n  MILLIS_PER_UNIT,\n  rank,\n  withMemo\n};\n", "import {\n  compare,\n  groupBy,\n  into,\n  isEmpty,\n  isObject,\n  isString,\n  resolve\n} from \"../../util\";\nconst $sort = (collection, sortKeys, options) => {\n  if (isEmpty(sortKeys) || !isObject(sortKeys))\n    return collection;\n  let cmp = compare;\n  const collationSpec = options.collation;\n  if (isObject(collationSpec) && isString(collationSpec.locale)) {\n    cmp = collationComparator(collationSpec);\n  }\n  return collection.transform((coll) => {\n    const modifiers = Object.keys(sortKeys);\n    for (const key of modifiers.reverse()) {\n      const groups = groupBy(\n        coll,\n        (obj) => resolve(obj, key),\n        options.hashFunction\n      );\n      const sortedKeys = Array.from(groups.keys()).sort(cmp);\n      if (sortKeys[key] === -1)\n        sortedKeys.reverse();\n      coll = [];\n      sortedKeys.reduce(\n        (acc, key2) => into(acc, groups.get(key2)),\n        coll\n      );\n    }\n    return coll;\n  });\n};\nconst COLLATION_STRENGTH = {\n  // Only strings that differ in base letters compare as unequal. Examples: a โ b, a = รก, a = A.\n  1: \"base\",\n  //  Only strings that differ in base letters or accents and other diacritic marks compare as unequal.\n  // Examples: a โ b, a โ รก, a = A.\n  2: \"accent\",\n  // Strings that differ in base letters, accents and other diacritic marks, or case compare as unequal.\n  // Other differences may also be taken into consideration. Examples: a โ b, a โ รก, a โ A\n  3: \"variant\"\n  // case - Only strings that differ in base letters or case compare as unequal. Examples: a โ b, a = รก, a โ A.\n};\nfunction collationComparator(spec) {\n  const localeOpt = {\n    sensitivity: COLLATION_STRENGTH[spec.strength || 3],\n    caseFirst: spec.caseFirst === \"off\" ? \"false\" : spec.caseFirst || \"false\",\n    numeric: spec.numericOrdering || false,\n    ignorePunctuation: spec.alternate === \"shifted\"\n  };\n  if ((spec.caseLevel || false) === true) {\n    if (localeOpt.sensitivity === \"base\")\n      localeOpt.sensitivity = \"case\";\n    if (localeOpt.sensitivity === \"accent\")\n      localeOpt.sensitivity = \"variant\";\n  }\n  const collator = new Intl.Collator(spec.locale, localeOpt);\n  return (a, b) => {\n    if (!isString(a) || !isString(b))\n      return compare(a, b);\n    const i = collator.compare(a, b);\n    if (i < 0)\n      return -1;\n    if (i > 0)\n      return 1;\n    return 0;\n  };\n}\nexport {\n  $sort\n};\n", "import {\n  computeValue\n} from \"../core\";\nimport { Query } from \"../query\";\nimport {\n  compare as mingoCmp,\n  ensureArray,\n  flatten,\n  getType,\n  inArray,\n  intersection,\n  isArray,\n  isBoolean,\n  isDate,\n  isEmpty,\n  isEqual,\n  isNil,\n  isNumber,\n  isObject,\n  isOperator,\n  isRegExp,\n  isString,\n  MAX_INT,\n  MAX_LONG,\n  MIN_INT,\n  MIN_LONG,\n  MingoError,\n  resolve,\n  truthy\n} from \"../util\";\nfunction createQueryOperator(predicate) {\n  const f = (selector, value, options) => {\n    const opts = { unwrapArray: true };\n    const depth = Math.max(1, selector.split(\".\").length - 1);\n    return (obj) => {\n      const lhs = resolve(obj, selector, opts);\n      return predicate(lhs, value, { ...options, depth });\n    };\n  };\n  f.op = \"query\";\n  return f;\n}\nfunction createExpressionOperator(predicate) {\n  return (obj, expr, options) => {\n    const args = computeValue(obj, expr, null, options);\n    return predicate(...args);\n  };\n}\nfunction $eq(a, b, options) {\n  if (isEqual(a, b))\n    return true;\n  if (isNil(a) && isNil(b))\n    return true;\n  if (a instanceof Array) {\n    const eq = isEqual.bind(null, b);\n    return a.some(eq) || flatten(a, options?.depth).some(eq);\n  }\n  return false;\n}\nfunction $ne(a, b, options) {\n  return !$eq(a, b, options);\n}\nfunction $in(a, b, options) {\n  if (isNil(a))\n    return b.some((v) => v === null);\n  return intersection([ensureArray(a), b], options?.hashFunction).length > 0;\n}\nfunction $nin(a, b, options) {\n  return !$in(a, b, options);\n}\nfunction $lt(a, b, _options) {\n  return compare(a, b, (x, y) => mingoCmp(x, y) < 0);\n}\nfunction $lte(a, b, _options) {\n  return compare(a, b, (x, y) => mingoCmp(x, y) <= 0);\n}\nfunction $gt(a, b, _options) {\n  return compare(a, b, (x, y) => mingoCmp(x, y) > 0);\n}\nfunction $gte(a, b, _options) {\n  return compare(a, b, (x, y) => mingoCmp(x, y) >= 0);\n}\nfunction $mod(a, b, _options) {\n  return ensureArray(a).some(\n    (x) => b.length === 2 && x % b[0] === b[1]\n  );\n}\nfunction $regex(a, b, options) {\n  const lhs = ensureArray(a);\n  const match = (x) => isString(x) && truthy(b.exec(x), options?.useStrictMode);\n  return lhs.some(match) || flatten(lhs, 1).some(match);\n}\nfunction $exists(a, b, _options) {\n  return (b === false || b === 0) && a === void 0 || (b === true || b === 1) && a !== void 0;\n}\nfunction $all(values, queries, options) {\n  if (!isArray(values) || !isArray(queries) || !values.length || !queries.length) {\n    return false;\n  }\n  let matched = true;\n  for (const query of queries) {\n    if (!matched)\n      break;\n    if (isObject(query) && inArray(Object.keys(query), \"$elemMatch\")) {\n      matched = $elemMatch(values, query[\"$elemMatch\"], options);\n    } else if (query instanceof RegExp) {\n      matched = values.some((s) => typeof s === \"string\" && query.test(s));\n    } else {\n      matched = values.some((v) => isEqual(query, v));\n    }\n  }\n  return matched;\n}\nfunction $size(a, b, _options) {\n  return Array.isArray(a) && a.length === b;\n}\nfunction isNonBooleanOperator(name) {\n  return isOperator(name) && [\"$and\", \"$or\", \"$nor\"].indexOf(name) === -1;\n}\nfunction $elemMatch(a, b, options) {\n  if (isArray(a) && !isEmpty(a)) {\n    let format = (x) => x;\n    let criteria = b;\n    if (Object.keys(b).every(isNonBooleanOperator)) {\n      criteria = { temp: b };\n      format = (x) => ({ temp: x });\n    }\n    const query = new Query(criteria, options);\n    for (let i = 0, len = a.length; i < len; i++) {\n      if (query.test(format(a[i]))) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nconst isNull = (a) => a === null;\nconst isInt = (a) => isNumber(a) && a >= MIN_INT && a <= MAX_INT && a.toString().indexOf(\".\") === -1;\nconst isLong = (a) => isNumber(a) && a >= MIN_LONG && a <= MAX_LONG && a.toString().indexOf(\".\") === -1;\nconst compareFuncs = {\n  array: isArray,\n  bool: isBoolean,\n  boolean: isBoolean,\n  date: isDate,\n  decimal: isNumber,\n  double: isNumber,\n  int: isInt,\n  long: isLong,\n  number: isNumber,\n  null: isNull,\n  object: isObject,\n  regex: isRegExp,\n  regexp: isRegExp,\n  string: isString,\n  // added for completeness\n  undefined: isNil,\n  // deprecated\n  function: (_) => {\n    throw new MingoError(\"unsupported type key `function`.\");\n  },\n  // Mongo identifiers\n  1: isNumber,\n  //double\n  2: isString,\n  3: isObject,\n  4: isArray,\n  6: isNil,\n  // deprecated\n  8: isBoolean,\n  9: isDate,\n  10: isNull,\n  11: isRegExp,\n  16: isInt,\n  18: isLong,\n  19: isNumber\n  //decimal\n};\nfunction compareType(a, b, _) {\n  const f = compareFuncs[b];\n  return f ? f(a) : false;\n}\nfunction $type(a, b, options) {\n  return Array.isArray(b) ? b.findIndex((t) => compareType(a, t, options)) >= 0 : compareType(a, b, options);\n}\nfunction compare(a, b, f) {\n  return ensureArray(a).some((x) => getType(x) === getType(b) && f(x, b));\n}\nexport {\n  $all,\n  $elemMatch,\n  $eq,\n  $exists,\n  $gt,\n  $gte,\n  $in,\n  $lt,\n  $lte,\n  $mod,\n  $ne,\n  $nin,\n  $regex,\n  $size,\n  $type,\n  createExpressionOperator,\n  createQueryOperator\n};\n", "import { $nin as __nin, createExpressionOperator } from \"../../_predicates\";\nconst $nin = createExpressionOperator(__nin);\nexport {\n  $nin\n};\n", "import { computeValue } from \"../../../core\";\nimport { assert, isArray, isNil, isNumber } from \"../../../util\";\nconst bitwise = (op, compute) => (obj, expr, options) => {\n  assert(isArray(expr), `${op}: expression must be an array.`);\n  const nums = computeValue(obj, expr, null, options);\n  if (nums.some(isNil))\n    return null;\n  assert(\n    nums.every(isNumber),\n    `${op}: expression must evalue to array of numbers.`\n  );\n  return compute(nums);\n};\nexport {\n  bitwise\n};\n", "import { bitwise } from \"./_internal\";\nconst $bitAnd = bitwise(\n  \"$bitAnd\",\n  (nums) => nums.reduce((a, b) => a & b, -1)\n);\nexport {\n  $bitAnd\n};\n", "import { bitwise } from \"./_internal\";\nconst $bitOr = bitwise(\n  \"$bitOr\",\n  (nums) => nums.reduce((a, b) => a | b, 0)\n);\nexport {\n  $bitOr\n};\n", "import { bitwise } from \"./_internal\";\nconst $bitXor = bitwise(\n  \"$bitXor\",\n  (nums) => nums.reduce((a, b) => a ^ b, 0)\n);\nexport {\n  $bitXor\n};\n", "export * from \"./and\";\nexport * from \"./not\";\nexport * from \"./or\";\n", "import { computeValue } from \"../../../core\";\nimport { truthy } from \"../../../util\";\nconst $and = (obj, expr, options) => {\n  const value = computeValue(obj, expr, null, options);\n  return truthy(value, options.useStrictMode) && value.every((v) => truthy(v, options.useStrictMode));\n};\nexport {\n  $and\n};\n", "import { computeValue } from \"../../../core\";\nimport { ensureArray } from \"../../../util\";\nconst $not = (obj, expr, options) => {\n  const booleanExpr = ensureArray(expr);\n  if (booleanExpr.length == 0)\n    return false;\n  if (booleanExpr.length == 1)\n    return !computeValue(obj, booleanExpr[0], null, options);\n  throw \"Expression $not takes exactly 1 argument\";\n};\nexport {\n  $not\n};\n", "import { computeValue } from \"../../../core\";\nimport { truthy } from \"../../../util\";\nconst $or = (obj, expr, options) => {\n  const value = computeValue(obj, expr, null, options);\n  const strict = options.useStrictMode;\n  return truthy(value, strict) && value.some((v) => truthy(v, strict));\n};\nexport {\n  $or\n};\n", "export * from \"./cmp\";\nexport * from \"./eq\";\nexport * from \"./gt\";\nexport * from \"./gte\";\nexport * from \"./lt\";\nexport * from \"./lte\";\nexport * from \"./ne\";\n", "import { computeValue } from \"../../../core\";\nconst $cmp = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  if (args[0] > args[1])\n    return 1;\n  if (args[0] < args[1])\n    return -1;\n  return 0;\n};\nexport {\n  $cmp\n};\n", "import { $eq as __eq, createExpressionOperator } from \"../../_predicates\";\nconst $eq = createExpressionOperator(__eq);\nexport {\n  $eq\n};\n", "import { $gt as __gt, createExpressionOperator } from \"../../_predicates\";\nconst $gt = createExpressionOperator(__gt);\nexport {\n  $gt\n};\n", "import { $gte as __gte, createExpressionOperator } from \"../../_predicates\";\nconst $gte = createExpressionOperator(__gte);\nexport {\n  $gte\n};\n", "import { $lt as __lt, createExpressionOperator } from \"../../_predicates\";\nconst $lt = createExpressionOperator(__lt);\nexport {\n  $lt\n};\n", "import { $lte as __lte, createExpressionOperator } from \"../../_predicates\";\nconst $lte = createExpressionOperator(__lte);\nexport {\n  $lte\n};\n", "import { $ne as __ne, createExpressionOperator } from \"../../_predicates\";\nconst $ne = createExpressionOperator(__ne);\nexport {\n  $ne\n};\n", "import { computeValue } from \"../../../core\";\nimport { assert, isNil, isObject } from \"../../../util\";\nimport {\n  adjustDate,\n  DATE_FORMAT,\n  DATE_SYM_TABLE,\n  MINUTES_PER_HOUR,\n  parseTimezone,\n  regexQuote,\n  regexStrip\n} from \"./_internal\";\nconst buildMap = (letters, sign) => {\n  const h = {};\n  letters.split(\"\").forEach((v, i) => h[v] = sign * (i + 1));\n  return h;\n};\nconst TZ_LETTER_OFFSETS = {\n  ...buildMap(\"ABCDEFGHIKLM\", 1),\n  ...buildMap(\"NOPQRSTUVWXY\", -1),\n  Z: 0\n};\nconst $dateFromString = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  args.format = args.format || DATE_FORMAT;\n  args.onNull = args.onNull || null;\n  let dateString = args.dateString;\n  if (isNil(dateString))\n    return args.onNull;\n  const separators = args.format.split(/%[YGmdHMSLuVzZ]/);\n  separators.reverse();\n  const matches = args.format.match(\n    /(%%|%Y|%G|%m|%d|%H|%M|%S|%L|%u|%V|%z|%Z)/g\n  );\n  const dateParts = {};\n  let expectedPattern = \"\";\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const formatSpecifier = matches[i];\n    const props = DATE_SYM_TABLE[formatSpecifier];\n    if (isObject(props)) {\n      const m2 = props.re.exec(dateString);\n      const delimiter = separators.pop() || \"\";\n      if (m2 !== null) {\n        dateParts[props.name] = /^\\d+$/.exec(m2[0]) ? parseInt(m2[0]) : m2[0];\n        dateString = dateString.substr(0, m2.index) + dateString.substr(m2.index + m2[0].length);\n        expectedPattern += regexQuote(delimiter) + regexStrip(props.re.toString());\n      } else {\n        dateParts[props.name] = null;\n      }\n    }\n  }\n  if (isNil(dateParts.year) || isNil(dateParts.month) || isNil(dateParts.day) || !new RegExp(\"^\" + expectedPattern + \"[A-Z]?$\").exec(args.dateString)) {\n    return args.onError;\n  }\n  const m = args.dateString.match(/([A-Z])$/);\n  assert(\n    // only one of in-date timeone or timezone argument but not both.\n    !(m && args.timezone),\n    `$dateFromString: you cannot pass in a date/time string with time zone information ('${m && m[0]}') together with a timezone argument`\n  );\n  const minuteOffset = m ? TZ_LETTER_OFFSETS[m[0]] * MINUTES_PER_HOUR : parseTimezone(args.timezone);\n  const d = new Date(\n    Date.UTC(dateParts.year, dateParts.month - 1, dateParts.day, 0, 0, 0)\n  );\n  if (!isNil(dateParts.hour))\n    d.setUTCHours(dateParts.hour);\n  if (!isNil(dateParts.minute))\n    d.setUTCMinutes(dateParts.minute);\n  if (!isNil(dateParts.second))\n    d.setUTCSeconds(dateParts.second);\n  if (!isNil(dateParts.millisecond))\n    d.setUTCMilliseconds(dateParts.millisecond);\n  adjustDate(d, -minuteOffset);\n  return d;\n};\nexport {\n  $dateFromString\n};\n", "import { computeValue } from \"../../../core\";\nimport { MingoError } from \"../../../util\";\nconst FIXED_POINTS = {\n  undefined: null,\n  null: null,\n  NaN: NaN,\n  Infinity: new Error(),\n  \"-Infinity\": new Error()\n};\nfunction createTrignometryOperator(f, fixedPoints = FIXED_POINTS) {\n  const fp = Object.assign({}, FIXED_POINTS, fixedPoints);\n  const keySet = new Set(Object.keys(fp));\n  return (obj, expr, options) => {\n    const n = computeValue(obj, expr, null, options);\n    if (keySet.has(`${n}`)) {\n      const res = fp[`${n}`];\n      if (res instanceof Error) {\n        throw new MingoError(\n          `cannot apply $${f.name} to -inf, value must in (-inf,inf)`\n        );\n      }\n      return res;\n    }\n    return f(n);\n  };\n}\nexport {\n  createTrignometryOperator\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $acos = createTrignometryOperator(Math.acos, {\n  Infinity: Infinity,\n  0: new Error()\n});\nexport {\n  $acos\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $acosh = createTrignometryOperator(Math.acosh, {\n  Infinity: Infinity,\n  0: new Error()\n});\nexport {\n  $acosh\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $asin = createTrignometryOperator(Math.asin);\nexport {\n  $asin\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $asinh = createTrignometryOperator(Math.asinh, {\n  Infinity: Infinity,\n  \"-Infinity\": -Infinity\n});\nexport {\n  $asinh\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $atan = createTrignometryOperator(Math.atan);\nexport {\n  $atan\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $atanh = createTrignometryOperator(Math.atanh, {\n  1: Infinity,\n  \"-1\": -Infinity\n});\nexport {\n  $atanh\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $cos = createTrignometryOperator(Math.cos);\nexport {\n  $cos\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $cosh = createTrignometryOperator(Math.cosh, {\n  \"-Infinity\": Infinity,\n  Infinity: Infinity\n  // [Math.PI]: -1,\n});\nexport {\n  $cosh\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst RADIANS_FACTOR = Math.PI / 180;\nconst $degreesToRadians = createTrignometryOperator(\n  (n) => n * RADIANS_FACTOR,\n  {\n    Infinity: Infinity,\n    \"-Infinity\": Infinity\n  }\n);\nexport {\n  $degreesToRadians\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst DEGREES_FACTOR = 180 / Math.PI;\nconst $radiansToDegrees = createTrignometryOperator(\n  (n) => n * DEGREES_FACTOR,\n  {\n    Infinity: Infinity,\n    \"-Infinity\": -Infinity\n  }\n);\nexport {\n  $radiansToDegrees\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $sin = createTrignometryOperator(Math.sin);\nexport {\n  $sin\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $sinh = createTrignometryOperator(Math.sinh, {\n  \"-Infinity\": -Infinity,\n  Infinity: Infinity\n});\nexport {\n  $sinh\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $tan = createTrignometryOperator(Math.tan);\nexport {\n  $tan\n};\n", "import {\n  ComputeOptions,\n  computeValue,\n  getOperator,\n  OperatorType\n} from \"../../core\";\nimport {\n  assert,\n  ensureArray,\n  filterMissing,\n  has,\n  inArray,\n  into,\n  isEmpty,\n  isNil,\n  isNumber,\n  isObject,\n  isOperator,\n  isString,\n  merge,\n  notInArray,\n  removeValue,\n  resolveGraph,\n  setValue\n} from \"../../util\";\nconst $project = (collection, expr, options) => {\n  if (isEmpty(expr))\n    return collection;\n  let expressionKeys = Object.keys(expr);\n  let idOnlyExcluded = false;\n  validateExpression(expr, options);\n  const ID_KEY = options.idKey;\n  if (inArray(expressionKeys, ID_KEY)) {\n    const id = expr[ID_KEY];\n    if (id === 0 || id === false) {\n      expressionKeys = expressionKeys.filter(\n        notInArray.bind(null, [ID_KEY])\n      );\n      idOnlyExcluded = expressionKeys.length == 0;\n    }\n  } else {\n    expressionKeys.push(ID_KEY);\n  }\n  const copts = ComputeOptions.init(options);\n  return collection.map((obj) => processObject(\n    obj,\n    expr,\n    copts.update(obj),\n    expressionKeys,\n    idOnlyExcluded\n  ));\n};\nfunction processObject(obj, expr, options, expressionKeys, idOnlyExcluded) {\n  let newObj = {};\n  let foundSlice = false;\n  let foundExclusion = false;\n  const dropKeys = [];\n  if (idOnlyExcluded) {\n    dropKeys.push(options.idKey);\n  }\n  for (const key of expressionKeys) {\n    let value = void 0;\n    const subExpr = expr[key];\n    if (key !== options.idKey && inArray([0, false], subExpr)) {\n      foundExclusion = true;\n    }\n    if (key === options.idKey && isEmpty(subExpr)) {\n      value = obj[key];\n    } else if (isString(subExpr)) {\n      value = computeValue(obj, subExpr, key, options);\n    } else if (inArray([1, true], subExpr)) {\n    } else if (subExpr instanceof Array) {\n      value = subExpr.map((v) => {\n        const r = computeValue(obj, v, null, options);\n        if (isNil(r))\n          return null;\n        return r;\n      });\n    } else if (isObject(subExpr)) {\n      const subExprObj = subExpr;\n      const subExprKeys = Object.keys(subExpr);\n      const operator = subExprKeys.length == 1 ? subExprKeys[0] : \"\";\n      const call = getOperator(\n        OperatorType.PROJECTION,\n        operator,\n        options\n      );\n      if (call) {\n        if (operator === \"$slice\") {\n          if (ensureArray(subExprObj[operator]).every(isNumber)) {\n            value = call(obj, subExprObj[operator], key, options);\n            foundSlice = true;\n          } else {\n            value = computeValue(obj, subExprObj, key, options);\n          }\n        } else {\n          value = call(obj, subExprObj[operator], key, options);\n        }\n      } else if (isOperator(operator)) {\n        value = computeValue(obj, subExprObj[operator], operator, options);\n      } else if (has(obj, key)) {\n        validateExpression(subExprObj, options);\n        let target = obj[key];\n        if (target instanceof Array) {\n          value = target.map(\n            (o) => processObject(o, subExprObj, options, subExprKeys, false)\n          );\n        } else {\n          target = isObject(target) ? target : obj;\n          value = processObject(\n            target,\n            subExprObj,\n            options,\n            subExprKeys,\n            false\n          );\n        }\n      } else {\n        value = computeValue(obj, subExpr, null, options);\n      }\n    } else {\n      dropKeys.push(key);\n      continue;\n    }\n    const objPathGraph = resolveGraph(obj, key, {\n      preserveMissing: true\n    });\n    if (objPathGraph !== void 0) {\n      merge(newObj, objPathGraph, {\n        flatten: true\n      });\n    }\n    if (notInArray([0, 1, false, true], subExpr)) {\n      if (value === void 0) {\n        removeValue(newObj, key, { descendArray: true });\n      } else {\n        setValue(newObj, key, value);\n      }\n    }\n  }\n  filterMissing(newObj);\n  if (foundSlice || foundExclusion || idOnlyExcluded) {\n    newObj = into({}, obj, newObj);\n    if (dropKeys.length > 0) {\n      for (const k of dropKeys) {\n        removeValue(newObj, k, { descendArray: true });\n      }\n    }\n  }\n  return newObj;\n}\nfunction validateExpression(expr, options) {\n  const check = [false, false];\n  for (const [k, v] of Object.entries(expr)) {\n    if (k === options?.idKey)\n      return;\n    if (v === 0 || v === false) {\n      check[0] = true;\n    } else if (v === 1 || v === true) {\n      check[1] = true;\n    }\n    assert(\n      !(check[0] && check[1]),\n      \"Projection cannot have a mix of inclusion and exclusion.\"\n    );\n  }\n}\nexport {\n  $project\n};\n", "import { Query } from \"../../../query\";\nimport { assert, isArray } from \"../../../util\";\nconst $and = (_, rhs, options) => {\n  assert(\n    isArray(rhs),\n    \"Invalid expression: $and expects value to be an Array.\"\n  );\n  const queries = rhs.map((expr) => new Query(expr, options));\n  return (obj) => queries.every((q) => q.test(obj));\n};\nexport {\n  $and\n};\n", "import { Query } from \"../../../query\";\nimport { assert, isArray } from \"../../../util\";\nconst $or = (_, rhs, options) => {\n  assert(isArray(rhs), \"Invalid expression. $or expects value to be an Array\");\n  const queries = rhs.map((expr) => new Query(expr, options));\n  return (obj) => queries.some((q) => q.test(obj));\n};\nexport {\n  $or\n};\n", "import { assert, isArray } from \"../../../util\";\nimport { $or } from \"./or\";\nconst $nor = (_, rhs, options) => {\n  assert(\n    isArray(rhs),\n    \"Invalid expression. $nor expects value to be an array.\"\n  );\n  const f = $or(\"$or\", rhs, options);\n  return (obj) => !f(obj);\n};\nexport {\n  $nor\n};\n", "import { Query } from \"../../../query\";\nimport { normalize } from \"../../../util\";\nconst $not = (selector, rhs, options) => {\n  const criteria = {};\n  criteria[selector] = normalize(rhs);\n  const query = new Query(criteria, options);\n  return (obj) => !query.test(obj);\n};\nexport {\n  $not\n};\n", "import { $eq as __eq, createQueryOperator } from \"../../_predicates\";\nconst $eq = createQueryOperator(__eq);\nexport {\n  $eq\n};\n", "import { $gt as __gt, createQueryOperator } from \"../../_predicates\";\nconst $gt = createQueryOperator(__gt);\nexport {\n  $gt\n};\n", "import { $gte as __gte, createQueryOperator } from \"../../_predicates\";\nconst $gte = createQueryOperator(__gte);\nexport {\n  $gte\n};\n", "import { $in as __in, createQueryOperator } from \"../../_predicates\";\nconst $in = createQueryOperator(__in);\nexport {\n  $in\n};\n", "import { $lt as __lt, createQueryOperator } from \"../../_predicates\";\nconst $lt = createQueryOperator(__lt);\nexport {\n  $lt\n};\n", "import { $lte as __lte, createQueryOperator } from \"../../_predicates\";\nconst $lte = createQueryOperator(__lte);\nexport {\n  $lte\n};\n", "import { $ne as __ne, createQueryOperator } from \"../../_predicates\";\nconst $ne = createQueryOperator(__ne);\nexport {\n  $ne\n};\n", "import { $nin as __nin, createQueryOperator } from \"../../_predicates\";\nconst $nin = createQueryOperator(__nin);\nexport {\n  $nin\n};\n", "import { computeValue } from \"../../../core\";\nfunction $expr(_, rhs, options) {\n  return (obj) => computeValue(obj, rhs, null, options);\n}\nexport {\n  $expr\n};\n", "import { MingoError } from \"../../../util\";\nfunction $jsonSchema(_, schema, options) {\n  if (!options?.jsonSchemaValidator) {\n    throw new MingoError(\n      \"Missing option 'jsonSchemaValidator'. Configure to use '$jsonSchema' operator.\"\n    );\n  }\n  const validate = options?.jsonSchemaValidator(schema);\n  return (obj) => validate(obj);\n}\nexport {\n  $jsonSchema\n};\n", "import { $mod as __mod, createQueryOperator } from \"../../_predicates\";\nconst $mod = createQueryOperator(__mod);\nexport {\n  $mod\n};\n", "import { $regex as __regex, createQueryOperator } from \"../../_predicates\";\nconst $regex = createQueryOperator(__regex);\nexport {\n  $regex\n};\n", "import { assert, isFunction, truthy } from \"../../../util\";\nfunction $where(_, rhs, options) {\n  assert(\n    options.scriptEnabled,\n    \"$where operator requires 'scriptEnabled' option to be true\"\n  );\n  const f = rhs;\n  assert(isFunction(f), \"$where only accepts a Function object\");\n  return (obj) => truthy(f.call(obj), options?.useStrictMode);\n}\nexport {\n  $where\n};\n", "import { $all as __all, createQueryOperator } from \"../../_predicates\";\nconst $all = createQueryOperator(__all);\nexport {\n  $all\n};\n", "import {\n  $elemMatch as __elemMatch,\n  createQueryOperator\n} from \"../../_predicates\";\nconst $elemMatch = createQueryOperator(__elemMatch);\nexport {\n  $elemMatch\n};\n", "import { $size as __size, createQueryOperator } from \"../../_predicates\";\nconst $size = createQueryOperator(__size);\nexport {\n  $size\n};\n", "import { $exists as __exists, createQueryOperator } from \"../../_predicates\";\nconst $exists = createQueryOperator(__exists);\nexport {\n  $exists\n};\n", "import { $type as __type, createQueryOperator } from \"../../_predicates\";\nconst $type = createQueryOperator(__type);\nexport {\n  $type\n};\n", "import { useOperators, OperatorType } from 'mingo/core';\nimport { Query } from 'mingo/query';\nimport type { MangoQuerySelector } from './types/index.d.ts';\nimport {\n    $project,\n    $sort\n} from 'mingo/operators/pipeline';\nimport {\n    $and,\n    $not,\n    $or,\n    $nor\n} from 'mingo/operators/query/logical';\nimport {\n    $eq,\n    $ne,\n    $gt,\n    $gte,\n    $lt,\n    $lte,\n    $nin,\n    $in\n} from 'mingo/operators/query/comparison';\nimport {\n    $regex,\n    $mod\n} from 'mingo/operators/query/evaluation';\nimport {\n    $elemMatch,\n    $size\n} from 'mingo/operators/query/array';\nimport {\n    $exists,\n    $type\n} from 'mingo/operators/query/element';\n\nlet mingoInitDone = false;\n\n\n/**\n * The MongoDB query library is huge and we do not need all the operators.\n * If you add an operator here, make sure that you properly add a test in\n * the file /test/unit/rx-storage-query-correctness.test.ts\n *\n * @link https://github.com/kofrasa/mingo#es6\n */\nexport function getMingoQuery<RxDocType>(\n    selector?: MangoQuerySelector<RxDocType>\n) {\n    if (!mingoInitDone) {\n        useOperators(OperatorType.PIPELINE, {\n            $sort,\n            $project\n        } as any);\n        useOperators(OperatorType.QUERY, {\n            $and,\n            $eq,\n            $elemMatch,\n            $exists,\n            $gt,\n            $gte,\n            $in,\n            $lt,\n            $lte,\n            $ne,\n            $nin,\n            $mod,\n            $nor,\n            $not,\n            $or,\n            $regex,\n            $size,\n            $type,\n        } as any);\n        mingoInitDone = true;\n    }\n    return new Query(selector as any);\n}\n", "import { LOGICAL_OPERATORS } from './query-planner.ts';\nimport { getPrimaryFieldOfPrimaryKey } from './rx-schema-helper.ts';\nimport type {\n    DeepReadonly,\n    DeterministicSortComparator,\n    FilledMangoQuery,\n    MangoQuery,\n    MangoQuerySortDirection,\n    QueryMatcher,\n    RxDocument,\n    RxDocumentData,\n    RxJsonSchema,\n    RxQuery\n} from './types/index.d.ts';\nimport {\n    clone,\n    firstPropertyNameOfObject,\n    toArray,\n    isMaybeReadonlyArray,\n    flatClone,\n    objectPathMonad,\n    ObjectPathMonadFunction\n} from './plugins/utils/index.ts';\nimport {\n    compare as mingoSortComparator\n} from 'mingo/util';\nimport { newRxError } from './rx-error.ts';\nimport { getMingoQuery } from './rx-query-mingo.ts';\n\n/**\n * Normalize the query to ensure we have all fields set\n * and queries that represent the same query logic are detected as equal by the caching.\n */\nexport function normalizeMangoQuery<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    mangoQuery: MangoQuery<RxDocType>\n): FilledMangoQuery<RxDocType> {\n    const primaryKey: string = getPrimaryFieldOfPrimaryKey(schema.primaryKey);\n    mangoQuery = flatClone(mangoQuery);\n\n    const normalizedMangoQuery: FilledMangoQuery<RxDocType> = clone(mangoQuery) as any;\n    if (typeof normalizedMangoQuery.skip !== 'number') {\n        normalizedMangoQuery.skip = 0;\n    }\n\n    if (!normalizedMangoQuery.selector) {\n        normalizedMangoQuery.selector = {};\n    } else {\n        normalizedMangoQuery.selector = normalizedMangoQuery.selector;\n        /**\n         * In mango query, it is possible to have an\n         * equals comparison by directly assigning a value\n         * to a property, without the '$eq' operator.\n         * Like:\n         * selector: {\n         *   foo: 'bar'\n         * }\n         * For normalization, we have to normalize this\n         * so our checks can perform properly.\n         *\n         *\n         * TODO this must work recursive with nested queries that\n         * contain multiple selectors via $and or $or etc.\n         */\n        Object\n            .entries(normalizedMangoQuery.selector)\n            .forEach(([field, matcher]) => {\n                if (typeof matcher !== 'object' || matcher === null) {\n                    (normalizedMangoQuery as any).selector[field] = {\n                        $eq: matcher\n                    };\n                }\n            });\n    }\n\n    /**\n     * Ensure that if an index is specified,\n     * the primaryKey is inside of it.\n     */\n    if (normalizedMangoQuery.index) {\n        const indexAr = toArray(normalizedMangoQuery.index);\n        if (!indexAr.includes(primaryKey)) {\n            indexAr.push(primaryKey);\n        }\n        normalizedMangoQuery.index = indexAr;\n    }\n\n    /**\n     * To ensure a deterministic sorting,\n     * we have to ensure the primary key is always part\n     * of the sort query.\n     * Primary sorting is added as last sort parameter,\n     * similar to how we add the primary key to indexes that do not have it.\n     *\n     */\n    if (!normalizedMangoQuery.sort) {\n        /**\n         * If no sort is given at all,\n         * we can assume that the user does not care about sort order at al.\n         *\n         * we cannot just use the primary key as sort parameter\n         * because it would likely cause the query to run over the primary key index\n         * which has a bad performance in most cases.\n         */\n        if (normalizedMangoQuery.index) {\n            normalizedMangoQuery.sort = normalizedMangoQuery.index.map((field: string) => {\n                return { [field as any]: 'asc' } as any;\n            });\n        } else {\n            /**\n             * Find the index that best matches the fields with the logical operators\n             */\n            if (schema.indexes) {\n                const fieldsWithLogicalOperator: Set<string> = new Set();\n                Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {\n                    let hasLogical = false;\n                    if (typeof matcher === 'object' && matcher !== null) {\n                        hasLogical = !!Object.keys(matcher).find(operator => LOGICAL_OPERATORS.has(operator));\n                    } else {\n                        hasLogical = true;\n                    }\n                    if (hasLogical) {\n                        fieldsWithLogicalOperator.add(field);\n                    }\n                });\n\n\n                let currentFieldsAmount = -1;\n                let currentBestIndexForSort: string[] | readonly string[] | undefined;\n                schema.indexes.forEach(index => {\n                    const useIndex = isMaybeReadonlyArray(index) ? index : [index];\n                    const firstWrongIndex = useIndex.findIndex(indexField => !fieldsWithLogicalOperator.has(indexField));\n                    if (\n                        firstWrongIndex > 0 &&\n                        firstWrongIndex > currentFieldsAmount\n                    ) {\n                        currentFieldsAmount = firstWrongIndex;\n                        currentBestIndexForSort = useIndex;\n                    }\n                });\n                if (currentBestIndexForSort) {\n                    normalizedMangoQuery.sort = currentBestIndexForSort.map((field: string) => {\n                        return { [field as any]: 'asc' } as any;\n                    });\n                }\n\n            }\n\n            /**\n             * Fall back to the primary key as sort order\n             * if no better one has been found\n             */\n            if (!normalizedMangoQuery.sort) {\n                normalizedMangoQuery.sort = [{ [primaryKey]: 'asc' }] as any;\n            }\n        }\n    } else {\n        const isPrimaryInSort = normalizedMangoQuery.sort\n            .find(p => firstPropertyNameOfObject(p) === primaryKey);\n        if (!isPrimaryInSort) {\n            normalizedMangoQuery.sort = normalizedMangoQuery.sort.slice(0);\n            normalizedMangoQuery.sort.push({ [primaryKey]: 'asc' } as any);\n        }\n    }\n\n    return normalizedMangoQuery;\n}\n\n/**\n * Returns the sort-comparator,\n * which is able to sort documents in the same way\n * a query over the db would do.\n */\nexport function getSortComparator<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    query: FilledMangoQuery<RxDocType>\n): DeterministicSortComparator<RxDocType> {\n    if (!query.sort) {\n        throw newRxError('SNH', { query });\n    }\n    const sortParts: {\n        key: string;\n        direction: MangoQuerySortDirection;\n        getValueFn: ObjectPathMonadFunction<RxDocType>;\n    }[] = [];\n    query.sort.forEach(sortBlock => {\n        const key = Object.keys(sortBlock)[0];\n        const direction = Object.values(sortBlock)[0];\n        sortParts.push({\n            key,\n            direction,\n            getValueFn: objectPathMonad(key)\n        });\n    });\n    const fun: DeterministicSortComparator<RxDocType> = (a: RxDocType, b: RxDocType) => {\n        for (let i = 0; i < sortParts.length; ++i) {\n            const sortPart = sortParts[i];\n            const valueA = sortPart.getValueFn(a);\n            const valueB = sortPart.getValueFn(b);\n            if (valueA !== valueB) {\n                const ret = sortPart.direction === 'asc' ? mingoSortComparator(valueA, valueB) : mingoSortComparator(valueB, valueA);\n                return ret as any;\n            }\n        }\n    };\n\n    return fun;\n}\n\n\n/**\n * Returns a function\n * that can be used to check if a document\n * matches the query.\n */\nexport function getQueryMatcher<RxDocType>(\n    _schema: RxJsonSchema<RxDocType> | RxJsonSchema<RxDocumentData<RxDocType>>,\n    query: FilledMangoQuery<RxDocType>\n): QueryMatcher<RxDocumentData<RxDocType>> {\n    if (!query.sort) {\n        throw newRxError('SNH', { query });\n    }\n\n    const mingoQuery = getMingoQuery(query.selector as any);\n    const fun: QueryMatcher<RxDocumentData<RxDocType>> = (doc: RxDocumentData<RxDocType> | DeepReadonly<RxDocumentData<RxDocType>>) => {\n        return mingoQuery.test(doc);\n    };\n    return fun;\n}\n\n\nexport async function runQueryUpdateFunction<RxDocType, RxQueryResult>(\n    rxQuery: RxQuery<RxDocType, RxQueryResult>,\n    fn: (doc: RxDocument<RxDocType>) => Promise<RxDocument<RxDocType>>\n): Promise<RxQueryResult> {\n    const docs = await rxQuery.exec();\n    if (!docs) {\n        // only findOne() queries can return null\n        return null as any;\n    }\n    if (Array.isArray(docs)) {\n        return Promise.all(\n            docs.map(doc => fn(doc))\n        ) as any;\n    }else if(docs instanceof Map){\n        return Promise.all(\n            [...docs.values()].map((doc) => fn(doc))\n        ) as any;\n    } else {\n        // via findOne()\n        const result = await fn(docs as any);\n        return result as any;\n    }\n}\n"],
  "mappings": "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",
  "names": ["lastOfArray", "ar", "length", "shuffleArray", "arr", "slice", "sort", "Math", "random", "randomOfArray", "randomElement", "floor", "toArray", "input", "Array", "isArray", "batchArray", "array", "batchSize", "ret", "batch", "splice", "push", "removeOneFromArrayIfMatches", "condition", "i", "done", "isMaybeReadonlyArray", "x", "isOneItemOfArrayInOtherArray", "ar1", "ar2", "el", "has", "includes", "arrayFilterNotEmpty", "value", "undefined", "countUntilNotMatching", "matchingFn", "count", "idx", "item", "matching", "asyncFilter", "predicate", "filters", "Promise", "all", "map", "filter", "index", "sumNumberArray", "maxOfNumbers", "max", "appendToArray", "add", "addSize", "baseSize", "uniqueArray", "arrArg", "elem", "pos", "indexOf", "sortByObjectNumberProperty", "property", "a", "b", "b64EncodeUnicode", "str", "encode", "b64DecodeUnicode", "decode", "arrayBufferToBase64", "buffer", "binary", "bytes", "Uint8Array", "len", "byteLength", "i", "String", "fromCharCode", "btoa", "base64ToArrayBuffer", "base64", "binary_string", "atob", "length", "charCodeAt", "createBlob", "data", "type", "blob", "Blob", "createBlobFromBase64", "base64String", "base64Response", "fetch", "blobToString", "blobType", "Object", "prototype", "toString", "call", "Promise", "resolve", "text", "blobToBase64String", "arrayBuffer", "arrayBufferToBase64", "getBlobSize", "size", "parseRevision", "revision", "split", "length", "Error", "height", "parseInt", "hash", "getHeightOfRevision", "useChars", "index", "char", "createRevision", "databaseInstanceToken", "previousDocData", "newRevisionHeight", "_rev", "deepFreeze", "o", "Object", "freeze", "getOwnPropertyNames", "forEach", "prop", "prototype", "hasOwnProperty", "call", "isFrozen", "objectPathMonad", "objectPath", "split", "splitLength", "length", "obj", "currentVal", "i", "subPath", "getFromObjectOrThrow", "key", "val", "Error", "flattenObject", "ob", "toReturn", "flatObject", "x", "flatClone", "assign", "firstPropertyNameOfObject", "keys", "firstPropertyValueOfObject", "sortObject", "noArraySort", "Array", "isArray", "sort", "a", "b", "localeCompare", "map", "out", "deepClone", "src", "ret", "dest", "clone", "overwriteGetterForCaching", "getterName", "value", "defineProperty", "get", "hasDeepProperty", "property", "has", "find", "item", "RX_META_LWT_MINIMUM", "getDefaultRxDocumentMeta", "lwt", "getDefaultRevision", "stripMetaDataFromDocument", "docData", "Object", "assign", "_meta", "undefined", "_deleted", "_rev", "areRxDocumentArraysEqual", "primaryPath", "ar1", "ar2", "length", "i", "len", "row1", "row2", "getSortDocumentsByLastWriteTimeComparator", "a", "b", "sortDocumentsByLastWriteTime", "docs", "sort", "toWithDeleted", "flatClone", "_attachments", "jsSha256", "input", "Promise", "resolve", "sha256", "nativeSha256", "data", "TextEncoder", "encode", "hashBuffer", "crypto", "subtle", "digest", "hash", "Array", "prototype", "map", "call", "Uint8Array", "x", "toString", "slice", "join", "canUseCryptoSubtle", "defaultHashSha256", "hashStringToNumber", "str", "nr", "len", "length", "i", "charCodeAt", "nextTick", "Promise", "res", "setTimeout", "promiseWait", "ms", "toPromise", "maybePromise", "then", "resolve", "isPromise", "value", "PROMISE_RESOLVE_TRUE", "PROMISE_RESOLVE_FALSE", "PROMISE_RESOLVE_NULL", "PROMISE_RESOLVE_VOID", "requestIdlePromiseNoQueue", "timeout", "requestIdleCallback", "idlePromiseQueue", "requestIdlePromise", "undefined", "requestIdleCallbackIfAvailable", "fun", "promiseSeries", "tasks", "initial", "reduce", "current", "next", "REGEX_ALL_DOTS", "REGEX_ALL_PIPES", "COUCH_NAME_CHARS", "randomCouchString", "length", "text", "i", "charAt", "Math", "floor", "random", "RANDOM_STRING", "ucfirst", "str", "f", "toUpperCase", "substr", "trimDots", "slice", "lastCharOfString", "isFolderPath", "name", "includes", "arrayBufferToString", "arrayBuffer", "TextDecoder", "decode", "stringToArrayBuffer", "TextEncoder", "encode", "normalizeString", "trim", "replace", "deepEqual", "a", "b", "constructor", "length", "i", "Array", "isArray", "RegExp", "source", "flags", "valueOf", "Object", "prototype", "toString", "keys", "hasOwnProperty", "call", "key", "isObject", "value", "type", "disallowedKeys", "Set", "digits", "getPathSegments", "path", "parts", "currentSegment", "currentPart", "isIgnoring", "character", "Error", "has", "push", "Number", "parseInt", "isStringIndex", "object", "key", "Array", "isArray", "index", "isInteger", "assertNotStringIndex", "getProperty", "join", "includes", "undefined", "pathArray", "length", "setProperty", "root", "deleteProperty", "hasProperty", "escapePath", "TypeError", "replace", "entries", "map", "v", "Object", "stringifyPath", "pathSegments", "result", "segment", "deepKeysIterator", "currentPath", "deepKeys", "getFromMapOrThrow", "map", "key", "val", "get", "Error", "getFromMapOrCreate", "index", "creator", "ifWasThere", "value", "set", "pluginMissing", "pluginKey", "keyParts", "split", "pluginName", "forEach", "part", "ucfirst", "Error", "errorToPlainJson", "err", "ret", "name", "message", "rxdb", "parameters", "extensions", "code", "url", "stack", "undefined", "replace", "_lastNow", "now", "ret", "Date", "twoDecimals", "parseFloat", "toFixed", "runXTimes", "xTimes", "fn", "Array", "fill", "forEach", "_v", "idx", "ensureNotFalsy", "obj", "message", "Error", "ensureInteger", "Number", "isInteger", "RXJS_SHARE_REPLAY_DEFAULTS", "bufferSize", "refCount", "nameFunction", "name", "body", "args", "apply", "RXDB_VERSION", "RXDB_UTILS_GLOBAL", "PREMIUM_FLAG_HASH", "overwritable", "isDevMode", "deepFreezeWhenDevMode", "obj", "tunnelErrorMessage", "message", "o", "t", "e", "t", "t", "_isNativeReflectConstruct", "_wrapNativeSuper", "t", "parametersToString", "parameters", "ret", "Object", "keys", "length", "map", "k", "paramStr", "err", "JSON", "stringify", "getOwnPropertyNames", "_k", "v", "undefined", "e", "join", "messageForError", "message", "code", "RxError", "_Error", "_this", "mes", "call", "url", "getErrorUrl", "rxdb", "_inheritsLoose", "_proto", "prototype", "toString", "_createClass", "key", "get", "_wrapNativeSuper", "Error", "RxTypeError", "_TypeError", "_this2", "_proto2", "TypeError", "errorUrlHint", "newRxError", "overwritable", "tunnelErrorMessage", "newRxTypeError", "isBulkWriteConflictError", "status", "STORAGE_WRITE_ERROR_CODE_TO_MESSAGE", "rxStorageWriteErrorToRxError", "name", "document", "documentId", "writeError", "getPseudoSchemaForVersion", "version", "primaryKey", "pseudoSchema", "fillWithDefaultSettings", "type", "properties", "maxLength", "indexes", "required", "getSchemaByObjectPath", "rxJsonSchema", "path", "usePath", "replace", "REGEX_ALL_DOTS", "trimDots", "ret", "getProperty", "fillPrimaryKey", "primaryPath", "jsonSchema", "documentData", "newPrimary", "getComposedPrimaryKeyOfDocumentData", "existingPrimary", "newRxError", "args", "schema", "getPrimaryFieldOfPrimaryKey", "key", "getLengthOfPrimaryKey", "schemaPart", "ensureNotFalsy", "compositePrimary", "fields", "map", "field", "value", "join", "separator", "normalizeRxJsonSchema", "normalizedSchema", "sortObject", "getDefaultIndex", "schemaObj", "flatClone", "additionalProperties", "Object", "prototype", "hasOwnProperty", "call", "keyCompression", "slice", "encrypted", "_rev", "minLength", "_attachments", "_deleted", "_meta", "RX_META_SCHEMA", "push", "finalFields", "getFinalFields", "appendToArray", "filter", "includes", "elem", "pos", "arr", "indexOf", "useIndexes", "index", "arIndex", "isMaybeReadonlyArray", "unshift", "length", "internalIndexes", "idx", "hasIndex", "Set", "indexStr", "has", "add", "lwt", "minimum", "RX_META_LWT_MINIMUM", "maximum", "multipleOf", "keys", "final", "forEach", "fillObjectWithDefaults", "rxSchema", "obj", "defaultKeys", "defaultValues", "i", "DEFAULT_CHECKPOINT_SCHEMA", "id", "INDEX_MAX", "String", "fromCharCode", "INDEX_MIN", "Number", "MIN_SAFE_INTEGER", "getQueryPlan", "schema", "query", "selector", "indexes", "slice", "index", "hasDescSorting", "sort", "find", "sortField", "Object", "values", "sortIrrelevevantFields", "Set", "keys", "forEach", "fieldName", "schemaPart", "getSchemaByObjectPath", "type", "prototype", "hasOwnProperty", "call", "add", "optimalSortIndex", "map", "optimalSortIndexCompareString", "filter", "f", "has", "join", "currentBestQuality", "currentBestQueryPlan", "inclusiveEnd", "inclusiveStart", "opts", "indexField", "matcher", "operators", "matcherOpts", "length", "startKey", "endKey", "operator", "LOGICAL_OPERATORS", "operatorValue", "partialOpts", "getMatcherQueryOpts", "assign", "startKeys", "opt", "endKeys", "queryPlan", "sortSatisfiedByIndex", "selectorSatisfiedByIndex", "isSelectorSatisfiedByIndex", "quality", "rateQueryPlan", "newRxError", "LOWER_BOUND_LOGICAL_OPERATORS", "UPPER_BOUND_LOGICAL_OPERATORS", "selectorEntries", "entries", "hasNonMatchingOperator", "operation", "includes", "hasNonLogicOperator", "op", "_value", "$and", "$or", "satisfieldLowerBound", "lowerOperatorFieldNames", "lowerLogicOps", "key", "hasLowerLogicOp", "push", "satisfieldUpperBound", "upperOperatorFieldNames", "upperLogicOps", "hasUperLogicOp", "i", "set", "size", "delete", "Error", "addQuality", "value", "pointsPerMatchingKey", "nonMinKeyCount", "countUntilNotMatching", "keyValue", "nonMaxKeyCount", "equalKeyCount", "idx", "pointsIfNoReSortMustBeDone", "isObject", "isObject", "isObject", "isObject", "isObject", "isObject", "compare", "isObject", "$nin", "$eq", "$gt", "$gte", "$lt", "$lte", "$ne", "$eq", "$gt", "$gte", "$lt", "$lte", "$ne", "isObject", "$and", "$or", "$or", "$not", "$eq", "$gt", "$gte", "$in", "$lt", "$lte", "$ne", "$nin", "$mod", "$regex", "$all", "$elemMatch", "$size", "$exists", "$type", "mingoInitDone", "getMingoQuery", "selector", "useOperators", "OperatorType", "PIPELINE", "$sort", "$project", "QUERY", "$and", "$eq", "$elemMatch", "$exists", "$gt", "$gte", "$in", "$lt", "$lte", "$ne", "$nin", "$mod", "$nor", "$not", "$or", "$regex", "$size", "$type", "Query", "normalizeMangoQuery", "schema", "mangoQuery", "primaryKey", "getPrimaryFieldOfPrimaryKey", "flatClone", "normalizedMangoQuery", "clone", "skip", "selector", "Object", "entries", "forEach", "field", "matcher", "$eq", "index", "indexAr", "toArray", "includes", "push", "sort", "map", "indexes", "fieldsWithLogicalOperator", "Set", "hasLogical", "keys", "find", "operator", "LOGICAL_OPERATORS", "has", "add", "currentFieldsAmount", "currentBestIndexForSort", "useIndex", "isMaybeReadonlyArray", "firstWrongIndex", "findIndex", "indexField", "isPrimaryInSort", "p", "firstPropertyNameOfObject", "slice", "getSortComparator", "query", "newRxError", "sortParts", "sortBlock", "key", "direction", "values", "getValueFn", "objectPathMonad", "fun", "a", "b", "i", "length", "sortPart", "valueA", "valueB", "ret", "mingoSortComparator", "getQueryMatcher", "_schema", "mingoQuery", "getMingoQuery", "doc", "test", "runQueryUpdateFunction", "rxQuery", "fn", "docs", "exec", "Array", "isArray", "Promise", "all", "Map", "result"]
}
