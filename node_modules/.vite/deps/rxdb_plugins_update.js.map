{
  "version": 3,
  "sources": ["../../mingo/dist/esm/operators/query/index.js", "../../mingo/dist/esm/operators/query/bitwise/_internal.js", "../../mingo/dist/esm/operators/query/bitwise/bitsAllClear.js", "../../mingo/dist/esm/operators/query/bitwise/bitsAllSet.js", "../../mingo/dist/esm/operators/query/bitwise/bitsAnyClear.js", "../../mingo/dist/esm/operators/query/bitwise/bitsAnySet.js", "../../mingo/dist/esm/operators/update/index.js", "../../mingo/dist/esm/operators/update/_internal.js", "../../mingo/dist/esm/operators/update/addToSet.js", "../../mingo/dist/esm/operators/update/bit.js", "../../mingo/dist/esm/operators/update/currentDate.js", "../../mingo/dist/esm/operators/update/inc.js", "../../mingo/dist/esm/operators/update/max.js", "../../mingo/dist/esm/operators/update/min.js", "../../mingo/dist/esm/operators/update/mul.js", "../../mingo/dist/esm/operators/update/pop.js", "../../mingo/dist/esm/operators/update/pull.js", "../../mingo/dist/esm/operators/update/pullAll.js", "../../mingo/dist/esm/operators/update/push.js", "../../mingo/dist/esm/operators/update/set.js", "../../mingo/dist/esm/operators/update/rename.js", "../../mingo/dist/esm/operators/update/unset.js", "../../mingo/dist/esm/updater.js", "../../rxdb/src/plugins/update/mingo-updater.ts", "../../rxdb/src/plugins/update/index.ts"],
  "sourcesContent": ["export * from \"./array\";\nexport * from \"./bitwise\";\nexport * from \"./comparison\";\nexport * from \"./element\";\nexport * from \"./evaluation\";\nexport * from \"./logical\";\n", "import { createQueryOperator } from \"../../_predicates\";\nconst createBitwiseOperator = (predicate) => {\n  return createQueryOperator(\n    (value, mask, options) => {\n      let b = 0;\n      if (mask instanceof Array) {\n        for (const n of mask)\n          b = b | 1 << n;\n      } else {\n        b = mask;\n      }\n      return predicate(value & b, b);\n    }\n  );\n};\nexport {\n  createBitwiseOperator\n};\n", "import { createBitwiseOperator } from \"./_internal\";\nconst $bitsAllClear = createBitwiseOperator((result, _) => result == 0);\nexport {\n  $bitsAllClear\n};\n", "import { createBitwiseOperator } from \"./_internal\";\nconst $bitsAllSet = createBitwiseOperator(\n  (result, mask) => result == mask\n);\nexport {\n  $bitsAllSet\n};\n", "import { createBitwiseOperator } from \"./_internal\";\nconst $bitsAnyClear = createBitwiseOperator(\n  (result, mask) => result < mask\n);\nexport {\n  $bitsAnyClear\n};\n", "import { createBitwiseOperator } from \"./_internal\";\nconst $bitsAnySet = createBitwiseOperator((result, _) => result > 0);\nexport {\n  $bitsAnySet\n};\n", "export * from \"./addToSet\";\nexport * from \"./bit\";\nexport * from \"./currentDate\";\nexport * from \"./inc\";\nexport * from \"./max\";\nexport * from \"./min\";\nexport * from \"./mul\";\nexport * from \"./pop\";\nexport * from \"./pull\";\nexport * from \"./pullAll\";\nexport * from \"./push\";\nexport * from \"./rename\";\nexport * from \"./set\";\nexport * from \"./unset\";\n", "import { Query } from \"../../query\";\nimport {\n  assert,\n  cloneDeep,\n  isArray,\n  isDate,\n  isObject,\n  resolve,\n  walk\n} from \"../../util\";\nconst clone = (mode, val) => {\n  switch (mode) {\n    case \"deep\":\n      return cloneDeep(val);\n    case \"copy\": {\n      if (isDate(val))\n        return new Date(val);\n      if (isArray(val))\n        return [...val];\n      if (isObject(val))\n        return { ...val };\n      return val;\n    }\n    default:\n      return val;\n  }\n};\nconst FILTER_IDENT_RE = /^[a-z]+[a-zA-Z0-9]*$/;\nfunction tokenizePath(selector) {\n  if (!selector.includes(\".$\")) {\n    return [{ parent: selector, selector }, []];\n  }\n  const begin = selector.indexOf(\".$\");\n  const end = selector.indexOf(\"]\");\n  const parent = selector.substring(0, begin);\n  const child = selector.substring(begin + 3, end);\n  assert(\n    child === \"\" || FILTER_IDENT_RE.test(child),\n    \"The filter <identifier> must begin with a lowercase letter and contain only alphanumeric characters.\"\n  );\n  const rest = selector.substring(end + 2);\n  const [next, elems] = rest ? tokenizePath(rest) : [];\n  return [\n    { selector, parent, child: child || \"$\", next },\n    [child, ...elems || []].filter(Boolean)\n  ];\n}\nconst applyUpdate = (o, n, q, f, opts) => {\n  const { parent, child: c, next } = n;\n  if (!c) {\n    let b = false;\n    const g = (u, k) => b = Boolean(f(u, k)) || b;\n    walk(o, parent, g, opts);\n    return b;\n  }\n  const t = resolve(o, parent);\n  if (!isArray(t))\n    return false;\n  return t.map((e, i) => {\n    if (q[c] && !q[c].test({ [c]: e }))\n      return false;\n    return next ? applyUpdate(e, next, q, f, opts) : f(t, i);\n  }).some(Boolean);\n};\nfunction walkExpression(expr, arrayFilter, options, callback) {\n  const res = [];\n  for (const [selector, val] of Object.entries(expr)) {\n    const [node, vars] = tokenizePath(selector);\n    if (!vars.length) {\n      if (callback(val, node, {}))\n        res.push(node.parent);\n    } else {\n      const conditions = {};\n      arrayFilter.forEach((o) => {\n        Object.keys(o).forEach((k) => {\n          vars.forEach((w) => {\n            if (k === w || k.startsWith(w + \".\")) {\n              conditions[w] = conditions[w] || {};\n              Object.assign(conditions[w], { [k]: o[k] });\n            }\n          });\n        });\n      });\n      const queries = {};\n      for (const [k, condition] of Object.entries(conditions)) {\n        queries[k] = new Query(condition, options.queryOptions);\n      }\n      if (callback(val, node, queries))\n        res.push(node.parent);\n    }\n  }\n  return res;\n}\nexport {\n  applyUpdate,\n  clone,\n  tokenizePath,\n  walkExpression\n};\n", "import { has, intersection, isObject, unique } from \"../../util\";\nimport { applyUpdate, clone, walkExpression } from \"./_internal\";\nconst $addToSet = (obj, expr, arrayFilters = [], options = {}) => {\n  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    const args = { $each: [val] };\n    if (isObject(val) && has(val, \"$each\")) {\n      Object.assign(args, val);\n    }\n    return applyUpdate(\n      obj,\n      node,\n      queries,\n      (o, k) => {\n        const prev = o[k] ||= [];\n        const common = intersection([prev, args.$each]);\n        if (common.length === args.$each.length)\n          return false;\n        o[k] = clone(options.cloneMode, unique(prev.concat(args.$each)));\n        return true;\n      },\n      { buildGraph: true }\n    );\n  });\n};\nexport {\n  $addToSet\n};\n", "import { assert, isNumber } from \"../../util\";\nimport { applyUpdate, walkExpression } from \"./_internal\";\nconst BIT_OPS = /* @__PURE__ */ new Set([\"and\", \"or\", \"xor\"]);\nconst $bit = (obj, expr, arrayFilters = [], options = {}) => {\n  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    const op = Object.keys(val);\n    assert(\n      op.length === 1 && BIT_OPS.has(op[0]),\n      `Invalid bit operator '${op[0]}'. Must be one of 'and', 'or', or 'xor'.`\n    );\n    return applyUpdate(\n      obj,\n      node,\n      queries,\n      (o, k) => {\n        let n = o[k];\n        const v = val[op[0]];\n        if (n !== void 0 && !(isNumber(n) && isNumber(v)))\n          return false;\n        n = n || 0;\n        switch (op[0]) {\n          case \"and\":\n            o[k] = n & v;\n            break;\n          case \"or\":\n            o[k] = n | v;\n            break;\n          case \"xor\":\n            o[k] = n ^ v;\n            break;\n        }\n        return o[k] !== n;\n      },\n      { buildGraph: true }\n    );\n  });\n};\nexport {\n  $bit\n};\n", "import { applyUpdate, walkExpression } from \"./_internal\";\nconst $currentDate = (obj, expr, arrayFilters = [], options = {}) => {\n  const now = Date.now();\n  return walkExpression(expr, arrayFilters, options, (_, node, queries) => {\n    return applyUpdate(\n      obj,\n      node,\n      queries,\n      (o, k) => {\n        o[k] = now;\n        return true;\n      },\n      { buildGraph: true }\n    );\n  });\n};\nexport {\n  $currentDate\n};\n", "import { assert, isNumber, resolve } from \"../../util\";\nimport { applyUpdate, walkExpression } from \"./_internal\";\nconst $inc = (obj, expr, arrayFilters = [], options = {}) => {\n  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    if (!node.child) {\n      const n = resolve(obj, node.parent);\n      assert(\n        n === void 0 || isNumber(n),\n        `cannot apply $inc to a value of non-numeric type`\n      );\n    }\n    return applyUpdate(\n      obj,\n      node,\n      queries,\n      (o, k) => {\n        o[k] = (o[k] ||= 0) + val;\n        return true;\n      },\n      { buildGraph: true }\n    );\n  });\n};\nexport {\n  $inc\n};\n", "import { compare } from \"../../util\";\nimport { applyUpdate, walkExpression } from \"./_internal\";\nconst $max = (obj, expr, arrayFilters = [], options = {}) => {\n  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    return applyUpdate(\n      obj,\n      node,\n      queries,\n      (o, k) => {\n        if (o[k] !== void 0 && compare(o[k], val) > -1)\n          return false;\n        o[k] = val;\n        return true;\n      },\n      { buildGraph: true }\n    );\n  });\n};\nexport {\n  $max\n};\n", "import { compare } from \"../../util\";\nimport { applyUpdate, walkExpression } from \"./_internal\";\nconst $min = (obj, expr, arrayFilters = [], options = {}) => {\n  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    return applyUpdate(\n      obj,\n      node,\n      queries,\n      (o, k) => {\n        if (o[k] !== void 0 && compare(o[k], val) < 1)\n          return false;\n        o[k] = val;\n        return true;\n      },\n      { buildGraph: true }\n    );\n  });\n};\nexport {\n  $min\n};\n", "import { applyUpdate, walkExpression } from \"./_internal\";\nconst $mul = (obj, expr, arrayFilters = [], options = {}) => {\n  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    return applyUpdate(\n      obj,\n      node,\n      queries,\n      (o, k) => {\n        const prev = o[k];\n        o[k] = o[k] === void 0 ? 0 : o[k] * val;\n        return o[k] !== prev;\n      },\n      { buildGraph: true }\n    );\n  });\n};\nexport {\n  $mul\n};\n", "import { assert, isArray } from \"../../util\";\nimport { applyUpdate, walkExpression } from \"./_internal\";\nconst $pop = (obj, expr, arrayFilters = [], options = {}) => {\n  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    return applyUpdate(obj, node, queries, (o, k) => {\n      const arr = o[k];\n      assert(\n        isArray(arr),\n        `path '${node.selector}' contains an element of non-array type.`\n      );\n      if (!arr.length)\n        return false;\n      if (val === -1) {\n        arr.splice(0, 1);\n      } else {\n        arr.pop();\n      }\n      return true;\n    });\n  });\n};\nexport {\n  $pop\n};\n", "import { Query } from \"../../query\";\nimport { isObject, isOperator } from \"../../util\";\nimport { applyUpdate, walkExpression } from \"./_internal\";\nconst $pull = (obj, expr, arrayFilters = [], options = {}) => {\n  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    const wrap = !isObject(val) || Object.keys(val).some(isOperator);\n    const query = new Query(\n      wrap ? { k: val } : val,\n      options.queryOptions\n    );\n    const pred = wrap ? (v) => query.test({ k: v }) : (v) => query.test(v);\n    return applyUpdate(obj, node, queries, (o, k) => {\n      const prev = o[k];\n      const curr = new Array();\n      const found = prev.map((v) => {\n        const b = pred(v);\n        if (!b)\n          curr.push(v);\n        return b;\n      }).some(Boolean);\n      if (!found)\n        return false;\n      o[k] = curr;\n      return true;\n    });\n  });\n};\nexport {\n  $pull\n};\n", "import { $pull } from \"./pull\";\nconst $pullAll = (obj, expr, arrayFilters = [], options = {}) => {\n  const pullExpr = {};\n  Object.entries(expr).forEach(([k, v]) => {\n    pullExpr[k] = { $in: v };\n  });\n  return $pull(obj, pullExpr, arrayFilters, options);\n};\nexport {\n  $pullAll\n};\n", "import { compare, has, isEqual, isNumber, isObject, resolve } from \"../../util\";\nimport { applyUpdate, clone, walkExpression } from \"./_internal\";\nconst OPERATOR_MODIFIERS = Object.freeze([\n  \"$each\",\n  \"$slice\",\n  \"$sort\",\n  \"$position\"\n]);\nconst $push = (obj, expr, arrayFilters = [], options = {}) => {\n  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    const args = {\n      $each: [val]\n    };\n    if (isObject(val) && OPERATOR_MODIFIERS.some((m) => has(val, m))) {\n      Object.assign(args, val);\n    }\n    return applyUpdate(\n      obj,\n      node,\n      queries,\n      (o, k) => {\n        const arr = o[k] ||= [];\n        const prev = arr.slice(0, args.$slice || arr.length);\n        const oldsize = arr.length;\n        const pos = isNumber(args.$position) ? args.$position : arr.length;\n        arr.splice(\n          pos,\n          0,\n          ...clone(options.cloneMode, args.$each)\n        );\n        if (args.$sort) {\n          const sortKey = isObject(args.$sort) ? Object.keys(args.$sort || {}).pop() : \"\";\n          const order = !sortKey ? args.$sort : args.$sort[sortKey];\n          const f = !sortKey ? (a) => a : (a) => resolve(a, sortKey);\n          arr.sort((a, b) => order * compare(f(a), f(b)));\n        }\n        if (isNumber(args.$slice)) {\n          if (args.$slice < 0)\n            arr.splice(0, arr.length + args.$slice);\n          else\n            arr.splice(args.$slice);\n        }\n        return oldsize != arr.length || !isEqual(prev, arr);\n      },\n      { descendArray: true, buildGraph: true }\n    );\n  });\n};\nexport {\n  $push\n};\n", "import { isEqual } from \"../../util\";\nimport { applyUpdate, clone, walkExpression } from \"./_internal\";\nconst $set = (obj, expr, arrayFilters = [], options = {}) => {\n  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    return applyUpdate(\n      obj,\n      node,\n      queries,\n      (o, k) => {\n        if (isEqual(o[k], val))\n          return false;\n        o[k] = clone(options.cloneMode, val);\n        return true;\n      },\n      { buildGraph: true }\n    );\n  });\n};\nexport {\n  $set\n};\n", "import { has } from \"../../util\";\nimport { applyUpdate, walkExpression } from \"./_internal\";\nimport { $set } from \"./set\";\nconst $rename = (obj, expr, arrayFilters = [], options = {}) => {\n  const res = [];\n  const changed = walkExpression(expr, arrayFilters, options, (val, node, queries) => {\n    return applyUpdate(obj, node, queries, (o, k) => {\n      if (!has(o, k))\n        return false;\n      res.push(...$set(obj, { [val]: o[k] }, arrayFilters, options));\n      delete o[k];\n      return true;\n    });\n  });\n  return Array.from(new Set(changed.concat(res)));\n};\nexport {\n  $rename\n};\n", "import { has, isArray } from \"../../util\";\nimport { applyUpdate, walkExpression } from \"./_internal\";\nconst $unset = (obj, expr, arrayFilters = [], options = {}) => {\n  return walkExpression(expr, arrayFilters, options, (_, node, queries) => {\n    return applyUpdate(obj, node, queries, (o, k) => {\n      if (!has(o, k))\n        return false;\n      if (isArray(o)) {\n        o[k] = null;\n      } else {\n        delete o[k];\n      }\n      return true;\n    });\n  });\n};\nexport {\n  $unset\n};\n", "import { initOptions } from \"./core\";\nimport * as booleanOperators from \"./operators/expression/boolean\";\nimport * as comparisonOperators from \"./operators/expression/comparison\";\nimport * as queryOperators from \"./operators/query\";\nimport * as UPDATE_OPERATORS from \"./operators/update\";\nimport { Query } from \"./query\";\nimport { assert, has } from \"./util\";\nfunction createUpdater(defaultOptions) {\n  defaultOptions = {\n    ...defaultOptions,\n    queryOptions: initOptions(defaultOptions.queryOptions)\n  };\n  defaultOptions.queryOptions.context.addQueryOps(queryOperators).addExpressionOps(booleanOperators).addExpressionOps(comparisonOperators);\n  return (obj, expr, arrayFilters = [], condition = {}, options = {}) => {\n    const opts = Object.assign({ cloneMode: \"copy\" }, defaultOptions, options);\n    Object.assign(opts, {\n      queryOptions: initOptions(\n        Object.assign({ useStrictMode: false }, opts?.queryOptions)\n      )\n    });\n    arrayFilters = arrayFilters || [];\n    condition = condition || {};\n    const entry = Object.entries(expr);\n    assert(\n      entry.length === 1,\n      \"Update expression must contain only one operator.\"\n    );\n    const [op, args] = entry[0];\n    assert(\n      has(UPDATE_OPERATORS, op),\n      `Update operator '${op}' is not supported.`\n    );\n    const mutate = UPDATE_OPERATORS[op];\n    if (Object.keys(condition).length) {\n      const q = condition instanceof Query ? condition : new Query(condition, opts.queryOptions);\n      if (!q.test(obj))\n        return [];\n    }\n    return mutate(obj, args, arrayFilters, opts);\n  };\n}\nconst updateObject = createUpdater({});\nexport {\n  createUpdater,\n  updateObject\n};\n", "/**\n * Custom build of the mingo updater for smaller build size\n */\n\nimport {\n    createUpdater\n} from \"mingo/updater\";\nimport {\n    clone\n} from '../utils/index.ts';\nimport type {\n    UpdateQuery\n} from '../../types/index';\n\nlet updater: any;\nexport function mingoUpdater<T>(\n    d: T, op: UpdateQuery<T>\n): T {\n    if (!updater) {\n        const updateObject = createUpdater({ cloneMode: \"none\" });\n        updater = (d: T, op: UpdateQuery<T>) => {\n            const cloned = clone(d);\n            updateObject(cloned as any, op as any);\n            return cloned;\n        }\n    }\n    return updater(d, op);\n}\n", "/**\n * this plugin allows delta-updates with mongo-like-syntax\n * It's using mingo internally\n * @link https://github.com/kofrasa/mingo\n */\nimport { runQueryUpdateFunction } from '../../rx-query-helper.ts';\nimport type {\n    RxDocument,\n    RxQuery,\n    RxPlugin,\n    UpdateQuery\n} from '../../types/index.d.ts';\nimport { mingoUpdater } from './mingo-updater.ts';\n\nexport function incrementalUpdate<RxDocType>(\n    this: RxDocument<RxDocType>,\n    updateObj: UpdateQuery<RxDocType>\n): Promise<RxDocument<RxDocType>> {\n    return this.incrementalModify((docData) => {\n        const newDocData = mingoUpdater<RxDocType>(docData, updateObj);\n        return newDocData;\n    });\n}\n\nexport function update<RxDocType>(\n    this: RxDocument<RxDocType>,\n    updateObj: UpdateQuery<RxDocType>\n): Promise<RxDocument<RxDocType>> {\n    const oldDocData = this._data;\n    const newDocData = mingoUpdater(oldDocData, updateObj);\n    return this._saveData(newDocData, oldDocData);\n}\n\nexport async function RxQueryUpdate(\n    this: RxQuery,\n    updateObj: UpdateQuery<any>\n): Promise<any> {\n    return runQueryUpdateFunction(\n        this.asRxQuery,\n        (doc) => doc.update(updateObj),\n    );\n}\n\n\nexport const RxDBUpdatePlugin: RxPlugin = {\n    name: 'update',\n    rxdb: true,\n    prototypes: {\n        RxDocument: (proto: any) => {\n            proto.update = update;\n            proto.incrementalUpdate = incrementalUpdate;\n        },\n        RxQuery: (proto: any) => {\n            proto.update = RxQueryUpdate;\n        }\n    }\n};\n"],
  "mappings": "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",
  "names": ["clone", "clone", "clone", "clone", "updater", "mingoUpdater", "d", "op", "updateObject", "createUpdater", "cloneMode", "cloned", "clone", "incrementalUpdate", "updateObj", "incrementalModify", "docData", "newDocData", "mingoUpdater", "update", "oldDocData", "_data", "_saveData", "RxQueryUpdate", "runQueryUpdateFunction", "asRxQuery", "doc", "RxDBUpdatePlugin", "name", "rxdb", "prototypes", "RxDocument", "proto", "RxQuery"]
}
