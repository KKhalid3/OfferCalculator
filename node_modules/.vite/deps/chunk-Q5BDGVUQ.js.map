{
  "version": 3,
  "sources": ["../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/hooks.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/rx-change-event.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/query-cache.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/doc-cache.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/rx-query-single-result.ts", "../../.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/performanceTimestampProvider.ts", "../../.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/animationFrameProvider.ts", "../../.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/dom/animationFrames.ts", "../../.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/util/Immediate.ts", "../../.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/immediateProvider.ts", "../../.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/AsapAction.ts", "../../.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/AsapScheduler.ts", "../../.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/asap.ts", "../../.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/QueueAction.ts", "../../.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/QueueScheduler.ts", "../../.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/queue.ts", "../../.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/AnimationFrameAction.ts", "../../.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/AnimationFrameScheduler.ts", "../../.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/animationFrame.ts", "../../.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/scheduler/VirtualTimeScheduler.ts", "../../.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/firstValueFrom.ts", "../../.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/merge.ts", "../../.pnpm/rxjs@7.8.2/node_modules/rxjs/src/internal/observable/never.ts", "../../.pnpm/event-reduce-js@5.2.7/node_modules/event-reduce-js/src/util.ts", "../../.pnpm/event-reduce-js@5.2.7/node_modules/event-reduce-js/src/states/state-resolver.ts", "../../.pnpm/event-reduce-js@5.2.7/node_modules/event-reduce-js/src/states/index.ts", "../../.pnpm/array-push-at-sort-position@4.0.1/node_modules/array-push-at-sort-position/dist/esm/index.js", "../../.pnpm/event-reduce-js@5.2.7/node_modules/event-reduce-js/src/actions/action-functions.ts", "../../.pnpm/event-reduce-js@5.2.7/node_modules/event-reduce-js/src/actions/index.ts", "../../.pnpm/binary-decision-diagram@3.2.0/node_modules/binary-decision-diagram/src/minimal-string/string-format.ts", "../../.pnpm/binary-decision-diagram@3.2.0/node_modules/binary-decision-diagram/src/util.ts", "../../.pnpm/binary-decision-diagram@3.2.0/node_modules/binary-decision-diagram/src/minimal-string/minimal-string-to-simple-bdd.ts", "../../.pnpm/binary-decision-diagram@3.2.0/node_modules/binary-decision-diagram/src/minimal-string/resolve-with-simple-bdd.ts", "../../.pnpm/event-reduce-js@5.2.7/node_modules/event-reduce-js/src/bdd/bdd.generated.ts", "../../.pnpm/event-reduce-js@5.2.7/node_modules/event-reduce-js/src/index.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/event-reduce.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/rx-query.ts", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/rx-storage-helper.ts", "../../.pnpm/broadcast-channel@7.0.0/node_modules/broadcast-channel/dist/esbrowser/util.js", "../../.pnpm/broadcast-channel@7.0.0/node_modules/broadcast-channel/dist/esbrowser/methods/native.js", "../../.pnpm/oblivious-set@1.4.0/node_modules/oblivious-set/src/index.ts", "../../.pnpm/broadcast-channel@7.0.0/node_modules/broadcast-channel/dist/esbrowser/options.js", "../../.pnpm/broadcast-channel@7.0.0/node_modules/broadcast-channel/dist/esbrowser/methods/indexed-db.js", "../../.pnpm/broadcast-channel@7.0.0/node_modules/broadcast-channel/dist/esbrowser/methods/localstorage.js", "../../.pnpm/broadcast-channel@7.0.0/node_modules/broadcast-channel/dist/esbrowser/methods/simulate.js", "../../.pnpm/broadcast-channel@7.0.0/node_modules/broadcast-channel/dist/esbrowser/method-chooser.js", "../../.pnpm/broadcast-channel@7.0.0/node_modules/broadcast-channel/dist/esbrowser/broadcast-channel.js", "../../.pnpm/unload@2.4.1/node_modules/unload/dist/es/browser.js", "../../.pnpm/unload@2.4.1/node_modules/unload/dist/es/node.js", "../../.pnpm/unload@2.4.1/node_modules/unload/dist/es/index.js", "../../.pnpm/broadcast-channel@7.0.0/node_modules/broadcast-channel/dist/esbrowser/leader-election-util.js", "../../.pnpm/broadcast-channel@7.0.0/node_modules/broadcast-channel/dist/esbrowser/leader-election-web-lock.js", "../../.pnpm/broadcast-channel@7.0.0/node_modules/broadcast-channel/dist/esbrowser/leader-election.js", "../../.pnpm/rxdb@15.39.0_rxjs@7.8.2/node_modules/rxdb/src/rx-storage-multiinstance.ts"],
  "sourcesContent": ["\n/**\n * hook-functions that can be extended by the plugin\n */\nexport const HOOKS: { [k: string]: any[]; } = {\n    /**\n     * Runs before a plugin is added.\n     * Use this to block the usage of non-compatible plugins.\n     */\n    preAddRxPlugin: [],\n    /**\n     * functions that run before the database is created\n     */\n    preCreateRxDatabase: [],\n    /**\n     * runs after the database is created and prepared\n     * but before the instance is returned to the user\n     * @async\n     */\n    createRxDatabase: [],\n    preCreateRxCollection: [],\n    createRxCollection: [],\n    createRxState: [],\n    /**\n    * runs at the end of the destroy-process of a collection\n    * @async\n    */\n    postDestroyRxCollection: [],\n    /**\n     * Runs after a collection is removed.\n     * @async\n     */\n    postRemoveRxCollection: [],\n    /**\n      * functions that get the json-schema as input\n      * to do additionally checks/manipulation\n      */\n    preCreateRxSchema: [],\n    /**\n     * functions that run after the RxSchema is created\n     * gets RxSchema as attribute\n     */\n    createRxSchema: [],\n    preCreateRxQuery: [],\n    /**\n     * Runs before a query is send to the\n     * prepareQuery function of the storage engine.\n     */\n    prePrepareQuery: [],\n    createRxDocument: [],\n    /**\n     * runs after a RxDocument is created,\n     * cannot be async\n     */\n    postCreateRxDocument: [],\n    /**\n     * Runs before a RxStorageInstance is created\n     * gets the params of createStorageInstance()\n     * as attribute so you can manipulate them.\n     * Notice that you have to clone stuff before mutating the inputs.\n     */\n    preCreateRxStorageInstance: [],\n    preStorageWrite: [],\n    /**\n     * runs on the document-data before the document is migrated\n     * {\n     *   doc: Object, // original doc-data\n     *   migrated: // migrated doc-data after run through migration-strategies\n     * }\n     */\n    preMigrateDocument: [],\n    /**\n     * runs after the migration of a document has been done\n     */\n    postMigrateDocument: [],\n    /**\n     * runs at the beginning of the destroy-process of a database\n     */\n    preDestroyRxDatabase: [],\n    /**\n     * runs after a database has been removed\n     * @async\n     */\n    postRemoveRxDatabase: [],\n\n\n    postCleanup: [],\n\n    /**\n     * runs before the replication writes the rows to master\n     * but before the rows have been modified\n     * @async\n     */\n    preReplicationMasterWrite: [],\n\n    /**\n     * runs after the replication has been sent to the server\n     * but before the new documents have been handled\n     * @async\n     */\n    preReplicationMasterWriteDocumentsHandle: [],\n};\n\nexport function runPluginHooks(hookKey: string, obj: any) {\n    if (HOOKS[hookKey].length > 0) {\n        HOOKS[hookKey].forEach(fun => fun(obj));\n    }\n}\n\n\n/**\n * TODO\n * we should not run the hooks in parallel\n * this makes stuff unpredictable.\n */\nexport function runAsyncPluginHooks(hookKey: string, obj: any): Promise<any> {\n    return Promise.all(\n        HOOKS[hookKey].map(fun => fun(obj))\n    );\n}\n\n/**\n * used in tests to remove hooks\n */\nexport function _clearHook(type: string, fun: Function) {\n    HOOKS[type] = HOOKS[type].filter(h => h !== fun);\n}\n", "/**\n * RxChangeEvents a emitted when something in the database changes\n * they can be grabbed by the observables of database, collection and document\n */\n\nimport type {\n    ChangeEvent as EventReduceChangeEvent,\n} from 'event-reduce-js';\nimport { overwritable } from './overwritable.ts';\n\nimport type {\n    EventBulk,\n    RxChangeEvent,\n    RxDocumentData\n} from './types/index.d.ts';\nimport { appendToArray } from './plugins/utils/index.ts';\n\nexport function getDocumentDataOfRxChangeEvent<T>(\n    rxChangeEvent: RxChangeEvent<T>\n): RxDocumentData<T> {\n    if ((rxChangeEvent as any).documentData) {\n        return (rxChangeEvent as any).documentData;\n    } else {\n        return (rxChangeEvent as any).previousDocumentData;\n    }\n}\n\n/**\n * Might return null which means an\n * already deleted document got modified but still is deleted.\n * These kind of events are not relevant for the event-reduce algorithm\n * and must be filtered out.\n */\nexport function rxChangeEventToEventReduceChangeEvent<DocType>(\n    rxChangeEvent: RxChangeEvent<DocType>\n): EventReduceChangeEvent<DocType> | null {\n    switch (rxChangeEvent.operation) {\n        case 'INSERT':\n            return {\n                operation: rxChangeEvent.operation,\n                id: rxChangeEvent.documentId,\n                doc: rxChangeEvent.documentData as any,\n                previous: null\n            };\n        case 'UPDATE':\n            return {\n                operation: rxChangeEvent.operation,\n                id: rxChangeEvent.documentId,\n                doc: overwritable.deepFreezeWhenDevMode(rxChangeEvent.documentData) as any,\n                previous: rxChangeEvent.previousDocumentData ? rxChangeEvent.previousDocumentData as any : 'UNKNOWN'\n            };\n        case 'DELETE':\n            return {\n                operation: rxChangeEvent.operation,\n                id: rxChangeEvent.documentId,\n                doc: null,\n                previous: rxChangeEvent.previousDocumentData as DocType\n            };\n    }\n}\n\n/**\n * Flattens the given events into a single array of events.\n * Used mostly in tests.\n */\nexport function flattenEvents<EventType>(\n    input: EventBulk<EventType, any> | EventBulk<EventType, any>[] | EventType | EventType[]\n): EventType[] {\n    const output: EventType[] = [];\n    if (Array.isArray(input)) {\n        input.forEach(inputItem => {\n            const add = flattenEvents(inputItem);\n            appendToArray(output, add);\n        });\n    } else {\n        if ((input as any).id && (input as any).events) {\n            // is bulk\n            (input as EventBulk<EventType, any>)\n                .events\n                .forEach(ev => output.push(ev));\n        } else {\n            output.push(input as any);\n        }\n    }\n\n    const usedIds = new Set<string>();\n    const nonDuplicate: EventType[] = [];\n\n    function getEventId(ev: any): string {\n        return [\n            ev.documentId,\n            ev.documentData ? ev.documentData._rev : '',\n            ev.previousDocumentData ? ev.previousDocumentData._rev : ''\n        ].join('|');\n    }\n\n    output.forEach(ev => {\n        const eventId = getEventId(ev);\n        if (!usedIds.has(eventId)) {\n            usedIds.add(eventId);\n            nonDuplicate.push(ev);\n        }\n    });\n\n    return nonDuplicate;\n}\n", "/**\n * the query-cache makes sure that on every query-state, exactly one instance can exist\n * if you use the same mango-query more then once, it will reuse the first RxQuery\n */\nimport type {\n    RxQuery,\n    RxCacheReplacementPolicy,\n    RxCollection\n} from './types/index.d.ts';\nimport {\n    getFromMapOrCreate,\n    nextTick,\n    now,\n    requestIdlePromise\n} from './plugins/utils/index.ts';\n\nexport class QueryCache {\n    public _map: Map<string, RxQuery> = new Map();\n\n    /**\n     * check if an equal query is in the cache,\n     * if true, return the cached one,\n     * if false, save the given one and return it\n     */\n    getByQuery(rxQuery: RxQuery): RxQuery {\n        const stringRep = rxQuery.toString();\n        return getFromMapOrCreate(\n            this._map,\n            stringRep,\n            () => rxQuery\n        );\n    }\n}\n\nexport function createQueryCache() {\n    return new QueryCache();\n}\n\n\nexport function uncacheRxQuery(queryCache: QueryCache, rxQuery: RxQuery) {\n    rxQuery.uncached = true;\n    const stringRep = rxQuery.toString();\n    queryCache._map.delete(stringRep);\n\n}\n\n\nexport function countRxQuerySubscribers(rxQuery: RxQuery): number {\n    return rxQuery.refCount$.observers.length;\n}\n\n\nexport const DEFAULT_TRY_TO_KEEP_MAX = 100;\nexport const DEFAULT_UNEXECUTED_LIFETIME = 30 * 1000;\n\n/**\n * The default cache replacement policy\n * See docs-src/query-cache.md to learn how it should work.\n * Notice that this runs often and should block the cpu as less as possible\n * This is a monad which makes it easier to unit test\n */\nexport const defaultCacheReplacementPolicyMonad: (\n    tryToKeepMax: number,\n    unExecutedLifetime: number\n) => RxCacheReplacementPolicy = (\n    tryToKeepMax,\n    unExecutedLifetime\n) => (\n    _collection: RxCollection,\n    queryCache: QueryCache\n) => {\n            if (queryCache._map.size < tryToKeepMax) {\n                return;\n            }\n\n            const minUnExecutedLifetime = now() - unExecutedLifetime;\n            const maybeUncache: RxQuery[] = [];\n\n            const queriesInCache = Array.from(queryCache._map.values());\n            for (const rxQuery of queriesInCache) {\n                // filter out queries with subscribers\n                if (countRxQuerySubscribers(rxQuery) > 0) {\n                    continue;\n                }\n                // directly uncache queries that never executed and are older then unExecutedLifetime\n                if (rxQuery._lastEnsureEqual === 0 && rxQuery._creationTime < minUnExecutedLifetime) {\n                    uncacheRxQuery(queryCache, rxQuery);\n                    continue;\n                }\n                maybeUncache.push(rxQuery);\n            }\n\n            const mustUncache = maybeUncache.length - tryToKeepMax;\n            if (mustUncache <= 0) {\n                return;\n            }\n\n            const sortedByLastUsage = maybeUncache.sort((a, b) => a._lastEnsureEqual - b._lastEnsureEqual);\n            const toRemove = sortedByLastUsage.slice(0, mustUncache);\n            toRemove.forEach(rxQuery => uncacheRxQuery(queryCache, rxQuery));\n        };\n\n\nexport const defaultCacheReplacementPolicy: RxCacheReplacementPolicy = defaultCacheReplacementPolicyMonad(\n    DEFAULT_TRY_TO_KEEP_MAX,\n    DEFAULT_UNEXECUTED_LIFETIME\n);\n\nexport const COLLECTIONS_WITH_RUNNING_CLEANUP: WeakSet<RxCollection> = new WeakSet();\n\n/**\n * Triggers the cache replacement policy after waitTime has passed.\n * We do not run this directly because at exactly the time a query is created,\n * we need all CPU to minimize latency.\n * Also this should not be triggered multiple times when waitTime is still waiting.\n */\nexport function triggerCacheReplacement(\n    rxCollection: RxCollection\n) {\n    if (COLLECTIONS_WITH_RUNNING_CLEANUP.has(rxCollection)) {\n        // already started\n        return;\n    }\n\n    COLLECTIONS_WITH_RUNNING_CLEANUP.add(rxCollection);\n\n    /**\n     * Do not run directly to not reduce result latency of a new query\n     */\n    nextTick() // wait at least one tick\n        .then(() => requestIdlePromise(200)) // and then wait for the CPU to be idle\n        .then(() => {\n            if (!rxCollection.destroyed) {\n                rxCollection.cacheReplacementPolicy(rxCollection, rxCollection._queryCache);\n            }\n            COLLECTIONS_WITH_RUNNING_CLEANUP.delete(rxCollection);\n        });\n}\n", "import type {\n    RxChangeEvent,\n    RxDocument,\n    RxDocumentData\n} from './types/index.d.ts';\nimport {\n    getFromMapOrThrow,\n    getHeightOfRevision,\n    overwriteGetterForCaching,\n    requestIdlePromiseNoQueue\n} from './plugins/utils/index.ts';\nimport {\n    overwritable\n} from './overwritable.ts';\nimport { Observable } from 'rxjs';\n\n/**\n * Because we have to create many cache items,\n * we use an array instead of an object with properties\n * for better performance and less memory usage.\n * @link https://stackoverflow.com/questions/17295056/array-vs-object-efficiency-in-javascript\n */\ndeclare type CacheItem<RxDocType, OrmMethods> = [\n    /**\n     * Store the different document states of time\n     * based on their revision height (rev height = array index).\n     * We store WeakRefs so that we can later clean up\n     * document states that are no longer needed.\n     */\n    Map<number, WeakRef<RxDocument<RxDocType, OrmMethods>>>,\n\n    /**\n     * Store the latest known document state.\n     * As long as any state of the document is in the cache,\n     * we observe the changestream and update the latestDoc accordingly.\n     * This makes it easier to optimize performance on other parts\n     * because for each known document we can always get the current state\n     * in the storage.\n     * Also it makes it possible to call RxDocument.latest() in a non-async way\n     * to retrieve the latest document state or to observe$ some property.\n     *\n     * To not prevent the whole cacheItem from being garbage collected,\n     * we store only the document data here, but not the RxDocument.\n     */\n    RxDocumentData<RxDocType>\n];\n\n\n/**\n * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n */\ndeclare type FinalizationRegistryValue = {\n    docId: string;\n    revisionHeight: number;\n};\n\n/**\n * The DocumentCache stores RxDocument objects\n * by their primary key and revision.\n * This is useful on client side applications where\n * it is not known how much memory can be used, so\n * we de-duplicate RxDocument states to save memory.\n * To not fill up the memory with old document states, the DocumentCache\n * only contains weak references to the RxDocuments themself.\n * @link https://caniuse.com/?search=weakref\n */\nexport class DocumentCache<RxDocType, OrmMethods> {\n    public readonly cacheItemByDocId = new Map<string, CacheItem<RxDocType, OrmMethods>>();\n\n    /**\n     * Process stuff lazy to not block the CPU\n     * on critical paths.\n     */\n    public readonly tasks = new Set<Function>();\n\n    /**\n     * Some JavaScript runtimes like QuickJS,\n     * so not have a FinalizationRegistry or WeakRef.\n     * Therefore we need a workaround which might waste a lot of memory,\n     * but at least works.\n     */\n    public readonly registry?: FinalizationRegistry<FinalizationRegistryValue> = typeof FinalizationRegistry === 'function' ?\n        new FinalizationRegistry<FinalizationRegistryValue>(docMeta => {\n            const docId = docMeta.docId;\n            const cacheItem = this.cacheItemByDocId.get(docId);\n            if (cacheItem) {\n                cacheItem[0].delete(docMeta.revisionHeight);\n                if (cacheItem[0].size === 0) {\n                    /**\n                     * No state of the document is cached anymore,\n                     * so we can clean up.\n                     */\n                    this.cacheItemByDocId.delete(docId);\n                }\n            }\n        }) :\n        undefined;\n\n    constructor(\n        public readonly primaryPath: string,\n        public readonly changes$: Observable<RxChangeEvent<RxDocType>[]>,\n        /**\n         * A method that can create a RxDocument by the given document data.\n         */\n        public documentCreator: (docData: RxDocumentData<RxDocType>) => RxDocument<RxDocType, OrmMethods>\n    ) {\n        changes$.subscribe(events => {\n            this.tasks.add(() => {\n                const cacheItemByDocId = this.cacheItemByDocId;\n                for (let index = 0; index < events.length; index++) {\n                    const event = events[index];\n                    const cacheItem = cacheItemByDocId.get(event.documentId);\n                    if (cacheItem) {\n                        let documentData = event.documentData;\n                        if (!documentData) {\n                            documentData = event.previousDocumentData as any;\n                        }\n                        cacheItem[1] = documentData;\n                    }\n                }\n            });\n            if (this.tasks.size <= 1) {\n                requestIdlePromiseNoQueue().then(() => {\n                    this.processTasks();\n                });\n            }\n        });\n    }\n\n    public processTasks() {\n        if (this.tasks.size === 0) {\n            return;\n        }\n        const tasks = Array.from(this.tasks);\n        tasks.forEach(task => task());\n        this.tasks.clear();\n    }\n\n    /**\n     * Get the RxDocument from the cache\n     * and create a new one if not exits before.\n     * @overwrites itself with the actual function\n     * because this is @performance relevant.\n     * It is called on each document row for each write and read.\n     */\n    get getCachedRxDocuments(): (docsData: RxDocumentData<RxDocType>[]) => RxDocument<RxDocType, OrmMethods>[] {\n        const fn = getCachedRxDocumentMonad(this);\n        return overwriteGetterForCaching(\n            this,\n            'getCachedRxDocuments',\n            fn\n        );\n    }\n\n    get getCachedRxDocument(): (docData: RxDocumentData<RxDocType>) => RxDocument<RxDocType, OrmMethods> {\n        const fn = getCachedRxDocumentMonad(this);\n        return overwriteGetterForCaching(\n            this,\n            'getCachedRxDocument',\n            doc => fn([doc])[0]\n        );\n    }\n\n    /**\n     * Throws if not exists\n     */\n    public getLatestDocumentData(docId: string): RxDocumentData<RxDocType> {\n        this.processTasks();\n        const cacheItem = getFromMapOrThrow(this.cacheItemByDocId, docId);\n        return cacheItem[1];\n    }\n\n    public getLatestDocumentDataIfExists(docId: string): RxDocumentData<RxDocType> | undefined {\n        this.processTasks();\n        const cacheItem = this.cacheItemByDocId.get(docId);\n        if (cacheItem) {\n            return cacheItem[1];\n        }\n    }\n}\n\n/**\n * This function is called very very often.\n * This is likely the most important function for RxDB overall performance\n * @hotPath This is one of the most important methods for performance.\n * It is used in many places to transform the raw document data into RxDocuments.\n */\nfunction getCachedRxDocumentMonad<RxDocType, OrmMethods>(\n    docCache: DocumentCache<RxDocType, OrmMethods>\n): (docsData: RxDocumentData<RxDocType>[]) => RxDocument<RxDocType, OrmMethods>[] {\n    const primaryPath = docCache.primaryPath;\n    const cacheItemByDocId = docCache.cacheItemByDocId;\n    const registry = docCache.registry;\n    const deepFreezeWhenDevMode = overwritable.deepFreezeWhenDevMode;\n    const documentCreator = docCache.documentCreator;\n    const fn: (docsData: RxDocumentData<RxDocType>[]) => RxDocument<RxDocType, OrmMethods>[] = (docsData: RxDocumentData<RxDocType>[]) => {\n        const ret: RxDocument<RxDocType, OrmMethods>[] = new Array(docsData.length);\n        const registryTasks: RxDocument<RxDocType, OrmMethods>[] = [];\n        for (let index = 0; index < docsData.length; index++) {\n            let docData = docsData[index];\n            const docId: string = (docData as any)[primaryPath];\n            const revisionHeight = getHeightOfRevision(docData._rev);\n\n            let byRev: Map<number, WeakRef<RxDocument<RxDocType, OrmMethods>>>;\n            let cachedRxDocumentWeakRef: WeakRef<RxDocument<RxDocType, OrmMethods>> | undefined;\n            let cacheItem = cacheItemByDocId.get(docId);\n            if (!cacheItem) {\n                byRev = new Map();\n                cacheItem = [\n                    byRev,\n                    docData\n                ];\n                cacheItemByDocId.set(docId, cacheItem);\n            } else {\n                byRev = cacheItem[0];\n                cachedRxDocumentWeakRef = byRev.get(revisionHeight);\n            }\n            let cachedRxDocument = cachedRxDocumentWeakRef ? cachedRxDocumentWeakRef.deref() : undefined;\n            if (!cachedRxDocument) {\n                docData = deepFreezeWhenDevMode(docData) as any;\n                cachedRxDocument = documentCreator(docData) as RxDocument<RxDocType, OrmMethods>;\n                byRev.set(revisionHeight, createWeakRefWithFallback(cachedRxDocument));\n                if (registry) {\n                    registryTasks.push(cachedRxDocument);\n                }\n            }\n            ret[index] = cachedRxDocument;\n        }\n        if (registryTasks.length > 0 && registry) {\n            /**\n             * Calling registry.register() has shown to have\n             * really bad performance. So we add the cached documents\n             * lazily.\n             */\n            docCache.tasks.add(() => {\n                for (let index = 0; index < registryTasks.length; index++) {\n                    const doc = registryTasks[index];\n                    registry.register(doc, {\n                        docId: doc.primary,\n                        revisionHeight: getHeightOfRevision(doc.revision)\n                    });\n                }\n            });\n            if (docCache.tasks.size <= 1) {\n                requestIdlePromiseNoQueue().then(() => {\n                    docCache.processTasks();\n                });\n            }\n        }\n        return ret;\n    };\n    return fn;\n}\n\nexport function mapDocumentsDataToCacheDocs<RxDocType, OrmMethods>(\n    docCache: DocumentCache<RxDocType, OrmMethods>,\n    docsData: RxDocumentData<RxDocType>[]\n) {\n    const getCachedRxDocuments = docCache.getCachedRxDocuments;\n    return getCachedRxDocuments(docsData);\n}\n\n/**\n * Fallback for JavaScript runtimes that do not support WeakRef.\n * The fallback will keep the items in cache forever,\n * but at least works.\n */\nconst HAS_WEAK_REF = typeof WeakRef === 'function';\nconst createWeakRefWithFallback = HAS_WEAK_REF ? createWeakRef : createWeakRefFallback;\nfunction createWeakRef<T extends object>(obj: T): WeakRef<T> {\n    return new WeakRef(obj) as any;\n}\nfunction createWeakRefFallback<T extends object>(obj: T): WeakRef<T> {\n    return {\n        deref() {\n            return obj;\n        }\n    } as any;\n}\n", "import { mapDocumentsDataToCacheDocs } from './doc-cache.ts';\nimport { now, overwriteGetterForCaching } from './plugins/utils/index.ts';\nimport { newRxError } from './rx-error.ts';\nimport { RxQueryBase } from './rx-query.ts';\nimport type {\n    RxDocument,\n    RxDocumentData\n} from './types';\n\n/**\n * RxDB needs the query results in multiple formats.\n * Sometimes as a Map or an array with only the documentData.\n * For better performance we work with this class\n * that initializes stuff lazily so that\n * we can directly work with the query results after RxQuery.exec()\n */\nexport class RxQuerySingleResult<RxDocType> {\n    /**\n     * Time at which the current _result state was created.\n     * Used to determine if the result set has changed since X\n     * so that we do not emit the same result multiple times on subscription.\n     */\n    public readonly time = now();\n    public readonly documents: RxDocument<RxDocType>[];\n    constructor(\n        public readonly query: RxQueryBase<RxDocType, unknown>,\n        // only used internally, do not use outside, use this.docsData instead\n        docsDataFromStorageInstance: RxDocumentData<RxDocType>[],\n        // can be overwritten for count-queries\n        public readonly count: number,\n    ) {\n        this.documents = mapDocumentsDataToCacheDocs<RxDocType, any>(this.query.collection._docCache, docsDataFromStorageInstance);\n    }\n\n\n    /**\n     * Instead of using the newResultData in the result cache,\n     * we directly use the objects that are stored in the RxDocument\n     * to ensure we do not store the same data twice and fill up the memory.\n     * @overwrites itself with the actual value\n     */\n    get docsData(): RxDocumentData<RxDocType>[] {\n        return overwriteGetterForCaching(\n            this,\n            'docsData',\n            this.documents.map(d => d._data)\n        );\n    }\n\n\n    // A key->document map, used in the event reduce optimization.\n    get docsDataMap(): Map<string, RxDocumentData<RxDocType>> {\n        const map = new Map<string, RxDocumentData<RxDocType>>();\n        this.documents.forEach(d => {\n            map.set(d.primary, d._data);\n        });\n        return overwriteGetterForCaching(\n            this,\n            'docsDataMap',\n            map\n        );\n    }\n\n    get docsMap(): Map<string, RxDocument<RxDocType>> {\n        const map = new Map<string, RxDocument<RxDocType>>();\n        const documents = this.documents;\n        for (let i = 0; i < documents.length; i++) {\n            const doc = documents[i];\n            map.set(doc.primary, doc);\n        }\n        return overwriteGetterForCaching(\n            this,\n            'docsMap',\n            map\n        );\n    }\n\n    getValue(throwIfMissing?: boolean) {\n        const op = this.query.op;\n        if (op === 'count') {\n            return this.count;\n        } else if (op === 'findOne') {\n            // findOne()-queries emit RxDocument or null\n            const doc = this.documents.length === 0 ? null : this.documents[0];\n            if (!doc && throwIfMissing) {\n                throw newRxError('QU10', {\n                    collection: this.query.collection.name,\n                    query: this.query.mangoQuery,\n                    op\n                });\n            } else {\n                return doc;\n            }\n        } else if (op === 'findByIds') {\n            return this.docsMap;\n        } else {\n            // find()-queries emit RxDocument[]\n            // Flat copy the array so it won't matter if the user modifies it.\n            return this.documents.slice(0);\n        }\n    }\n}\n", "import { TimestampProvider } from '../types';\n\ninterface PerformanceTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const performanceTimestampProvider: PerformanceTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (performanceTimestampProvider.delegate || performance).now();\n  },\n  delegate: undefined,\n};\n", "import { Subscription } from '../Subscription';\n\ninterface AnimationFrameProvider {\n  schedule(callback: FrameRequestCallback): Subscription;\n  requestAnimationFrame: typeof requestAnimationFrame;\n  cancelAnimationFrame: typeof cancelAnimationFrame;\n  delegate:\n    | {\n        requestAnimationFrame: typeof requestAnimationFrame;\n        cancelAnimationFrame: typeof cancelAnimationFrame;\n      }\n    | undefined;\n}\n\nexport const animationFrameProvider: AnimationFrameProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  schedule(callback) {\n    let request = requestAnimationFrame;\n    let cancel: typeof cancelAnimationFrame | undefined = cancelAnimationFrame;\n    const { delegate } = animationFrameProvider;\n    if (delegate) {\n      request = delegate.requestAnimationFrame;\n      cancel = delegate.cancelAnimationFrame;\n    }\n    const handle = request((timestamp) => {\n      // Clear the cancel function. The request has been fulfilled, so\n      // attempting to cancel the request upon unsubscription would be\n      // pointless.\n      cancel = undefined;\n      callback(timestamp);\n    });\n    return new Subscription(() => cancel?.(handle));\n  },\n  requestAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.requestAnimationFrame || requestAnimationFrame)(...args);\n  },\n  cancelAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.cancelAnimationFrame || cancelAnimationFrame)(...args);\n  },\n  delegate: undefined,\n};\n", "import { Observable } from '../../Observable';\nimport { TimestampProvider } from '../../types';\nimport { performanceTimestampProvider } from '../../scheduler/performanceTimestampProvider';\nimport { animationFrameProvider } from '../../scheduler/animationFrameProvider';\n\n/**\n * An observable of animation frames\n *\n * Emits the amount of time elapsed since subscription and the timestamp on each animation frame.\n * Defaults to milliseconds provided to the requestAnimationFrame's callback. Does not end on its own.\n *\n * Every subscription will start a separate animation loop. Since animation frames are always scheduled\n * by the browser to occur directly before a repaint, scheduling more than one animation frame synchronously\n * should not be much different or have more overhead than looping over an array of events during\n * a single animation frame. However, if for some reason the developer would like to ensure the\n * execution of animation-related handlers are all executed during the same task by the engine,\n * the `share` operator can be used.\n *\n * This is useful for setting up animations with RxJS.\n *\n * ## Examples\n *\n * Tweening a div to move it on the screen\n *\n * ```ts\n * import { animationFrames, map, takeWhile, endWith } from 'rxjs';\n *\n * function tween(start: number, end: number, duration: number) {\n *   const diff = end - start;\n *   return animationFrames().pipe(\n *     // Figure out what percentage of time has passed\n *     map(({ elapsed }) => elapsed / duration),\n *     // Take the vector while less than 100%\n *     takeWhile(v => v < 1),\n *     // Finish with 100%\n *     endWith(1),\n *     // Calculate the distance traveled between start and end\n *     map(v => v * diff + start)\n *   );\n * }\n *\n * // Setup a div for us to move around\n * const div = document.createElement('div');\n * document.body.appendChild(div);\n * div.style.position = 'absolute';\n * div.style.width = '40px';\n * div.style.height = '40px';\n * div.style.backgroundColor = 'lime';\n * div.style.transform = 'translate3d(10px, 0, 0)';\n *\n * tween(10, 200, 4000).subscribe(x => {\n *   div.style.transform = `translate3d(${ x }px, 0, 0)`;\n * });\n * ```\n *\n * Providing a custom timestamp provider\n *\n * ```ts\n * import { animationFrames, TimestampProvider } from 'rxjs';\n *\n * // A custom timestamp provider\n * let now = 0;\n * const customTSProvider: TimestampProvider = {\n *   now() { return now++; }\n * };\n *\n * const source$ = animationFrames(customTSProvider);\n *\n * // Log increasing numbers 0...1...2... on every animation frame.\n * source$.subscribe(({ elapsed }) => console.log(elapsed));\n * ```\n *\n * @param timestampProvider An object with a `now` method that provides a numeric timestamp\n */\nexport function animationFrames(timestampProvider?: TimestampProvider) {\n  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;\n}\n\n/**\n * Does the work of creating the observable for `animationFrames`.\n * @param timestampProvider The timestamp provider to use to create the observable\n */\nfunction animationFramesFactory(timestampProvider?: TimestampProvider) {\n  return new Observable<{ timestamp: number; elapsed: number }>((subscriber) => {\n    // If no timestamp provider is specified, use performance.now() - as it\n    // will return timestamps 'compatible' with those passed to the run\n    // callback and won't be affected by NTP adjustments, etc.\n    const provider = timestampProvider || performanceTimestampProvider;\n\n    // Capture the start time upon subscription, as the run callback can remain\n    // queued for a considerable period of time and the elapsed time should\n    // represent the time elapsed since subscription - not the time since the\n    // first rendered animation frame.\n    const start = provider.now();\n\n    let id = 0;\n    const run = () => {\n      if (!subscriber.closed) {\n        id = animationFrameProvider.requestAnimationFrame((timestamp: DOMHighResTimeStamp | number) => {\n          id = 0;\n          // Use the provider's timestamp to calculate the elapsed time. Note that\n          // this means - if the caller hasn't passed a provider - that\n          // performance.now() will be used instead of the timestamp that was\n          // passed to the run callback. The reason for this is that the timestamp\n          // passed to the callback can be earlier than the start time, as it\n          // represents the time at which the browser decided it would render any\n          // queued frames - and that time can be earlier the captured start time.\n          const now = provider.now();\n          subscriber.next({\n            timestamp: timestampProvider ? now : timestamp,\n            elapsed: now - start,\n          });\n          run();\n        });\n      }\n    };\n\n    run();\n\n    return () => {\n      if (id) {\n        animationFrameProvider.cancelAnimationFrame(id);\n      }\n    };\n  });\n}\n\n/**\n * In the common case, where the timestamp provided by the rAF API is used,\n * we use this shared observable to reduce overhead.\n */\nconst DEFAULT_ANIMATION_FRAMES = animationFramesFactory();\n", "let nextHandle = 1;\n// The promise needs to be created lazily otherwise it won't be patched by Zones\nlet resolved: Promise<any>;\nconst activeHandles: { [key: number]: any } = {};\n\n/**\n * Finds the handle in the list of active handles, and removes it.\n * Returns `true` if found, `false` otherwise. Used both to clear\n * Immediate scheduled tasks, and to identify if a task should be scheduled.\n */\nfunction findAndClearHandle(handle: number): boolean {\n  if (handle in activeHandles) {\n    delete activeHandles[handle];\n    return true;\n  }\n  return false;\n}\n\n/**\n * Helper functions to schedule and unschedule microtasks.\n */\nexport const Immediate = {\n  setImmediate(cb: () => void): number {\n    const handle = nextHandle++;\n    activeHandles[handle] = true;\n    if (!resolved) {\n      resolved = Promise.resolve();\n    }\n    resolved.then(() => findAndClearHandle(handle) && cb());\n    return handle;\n  },\n\n  clearImmediate(handle: number): void {\n    findAndClearHandle(handle);\n  },\n};\n\n/**\n * Used for internal testing purposes only. Do not export from library.\n */\nexport const TestTools = {\n  pending() {\n    return Object.keys(activeHandles).length;\n  }\n};\n", "import { Immediate } from '../util/Immediate';\nimport type { TimerHandle } from './timerHandle';\nconst { setImmediate, clearImmediate } = Immediate;\n\ntype SetImmediateFunction = (handler: () => void, ...args: any[]) => TimerHandle;\ntype ClearImmediateFunction = (handle: TimerHandle) => void;\n\ninterface ImmediateProvider {\n  setImmediate: SetImmediateFunction;\n  clearImmediate: ClearImmediateFunction;\n  delegate:\n    | {\n        setImmediate: SetImmediateFunction;\n        clearImmediate: ClearImmediateFunction;\n      }\n    | undefined;\n}\n\nexport const immediateProvider: ImmediateProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setImmediate(...args) {\n    const { delegate } = immediateProvider;\n    return (delegate?.setImmediate || setImmediate)(...args);\n  },\n  clearImmediate(handle) {\n    const { delegate } = immediateProvider;\n    return (delegate?.clearImmediate || clearImmediate)(handle as any);\n  },\n  delegate: undefined,\n};\n", "import { AsyncAction } from './AsyncAction';\nimport { AsapScheduler } from './AsapScheduler';\nimport { SchedulerAction } from '../types';\nimport { immediateProvider } from './immediateProvider';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsapAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AsapScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If a microtask has already been scheduled, don't schedule another\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n    // the current scheduled microtask id.\n    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested microtask and set the scheduled flag to undefined\n    // so the next AsapAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && actions[actions.length - 1]?.id !== id) {\n      immediateProvider.clearImmediate(id);\n      if (scheduler._scheduled === id) {\n        scheduler._scheduled = undefined;\n      }\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n", "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AsapScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n", "import { AsapAction } from './AsapAction';\nimport { AsapScheduler } from './AsapScheduler';\n\n/**\n *\n * Asap Scheduler\n *\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n *\n * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n * code to end and then it will try to execute given task as fast as possible.\n *\n * `asap` scheduler will do its best to minimize time between end of currently executing code\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n * some (although minimal) unwanted delay.\n *\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\n * as soon as possible, `asap` scheduler is your best bet.\n *\n * ## Example\n * Compare async and asap scheduler<\n * ```ts\n * import { asapScheduler, asyncScheduler } from 'rxjs';\n *\n * asyncScheduler.schedule(() => console.log('async')); // scheduling 'async' first...\n * asapScheduler.schedule(() => console.log('asap'));\n *\n * // Logs:\n * // \"asap\"\n * // \"async\"\n * // ... but 'asap' goes first!\n * ```\n */\n\nexport const asapScheduler = new AsapScheduler(AsapAction);\n\n/**\n * @deprecated Renamed to {@link asapScheduler}. Will be removed in v8.\n */\nexport const asap = asapScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { QueueScheduler } from './QueueScheduler';\nimport { SchedulerAction } from '../types';\nimport { TimerHandle } from './timerHandle';\n\nexport class QueueAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: QueueScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (delay > 0) {\n      return super.schedule(state, delay);\n    }\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  }\n\n  public execute(state: T, delay: number): any {\n    return delay > 0 || this.closed ? super.execute(state, delay) : this._execute(state, delay);\n  }\n\n  protected requestAsyncId(scheduler: QueueScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n\n    if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n\n    // Otherwise flush the scheduler starting with this action.\n    scheduler.flush(this);\n\n    // HACK: In the past, this was returning `void`. However, `void` isn't a valid\n    // `TimerHandle`, and generally the return value here isn't really used. So the\n    // compromise is to return `0` which is both \"falsy\" and a valid `TimerHandle`,\n    // as opposed to refactoring every other instanceo of `requestAsyncId`.\n    return 0;\n  }\n}\n", "import { AsyncScheduler } from './AsyncScheduler';\n\nexport class QueueScheduler extends AsyncScheduler {\n}\n", "import { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\n\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * ## Examples\n * Schedule recursively first, then do something\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(() => {\n *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n * ```\n *\n * Reschedule itself recursively\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n * ```\n */\n\nexport const queueScheduler = new QueueScheduler(QueueAction);\n\n/**\n * @deprecated Renamed to {@link queueScheduler}. Will be removed in v8.\n */\nexport const queue = queueScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nimport { SchedulerAction } from '../types';\nimport { animationFrameProvider } from './animationFrameProvider';\nimport { TimerHandle } from './timerHandle';\n\nexport class AnimationFrameAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AnimationFrameScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If an animation frame has already been requested, don't request another\n    // one. If an animation frame hasn't been requested yet, request one. Return\n    // the current animation frame request id.\n    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(() => scheduler.flush(undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested animation frame and set the scheduled flag to\n    // undefined so the next AnimationFrameAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && id === scheduler._scheduled && actions[actions.length - 1]?.id !== id) {\n      animationFrameProvider.cancelAnimationFrame(id as number);\n      scheduler._scheduled = undefined;\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n", "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AnimationFrameScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    let flushId;\n    if (action) {\n      flushId = action.id;\n    } else {\n      flushId = this._scheduled;\n      this._scheduled = undefined;\n    }\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n", "import { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\n\n/**\n *\n * Animation Frame Scheduler\n *\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n *\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler\n * behaviour.\n *\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\n * It makes sure scheduled task will happen just before next browser content repaint,\n * thus performing animations as efficiently as possible.\n *\n * ## Example\n * Schedule div height animation\n * ```ts\n * // html: <div style=\"background: #0ff;\"></div>\n * import { animationFrameScheduler } from 'rxjs';\n *\n * const div = document.querySelector('div');\n *\n * animationFrameScheduler.schedule(function(height) {\n *   div.style.height = height + \"px\";\n *\n *   this.schedule(height + 1);  // `this` references currently executing Action,\n *                               // which we reschedule with new state\n * }, 0, 0);\n *\n * // You will see a div element growing in height\n * ```\n */\n\nexport const animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);\n\n/**\n * @deprecated Renamed to {@link animationFrameScheduler}. Will be removed in v8.\n */\nexport const animationFrame = animationFrameScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { SchedulerAction } from '../types';\nimport { TimerHandle } from './timerHandle';\n\nexport class VirtualTimeScheduler extends AsyncScheduler {\n  /** @deprecated Not used in VirtualTimeScheduler directly. Will be removed in v8. */\n  static frameTimeFactor = 10;\n\n  /**\n   * The current frame for the state of the virtual scheduler instance. The difference\n   * between two \"frames\" is synonymous with the passage of \"virtual time units\". So if\n   * you record `scheduler.frame` to be `1`, then later, observe `scheduler.frame` to be at `11`,\n   * that means `10` virtual time units have passed.\n   */\n  public frame: number = 0;\n\n  /**\n   * Used internally to examine the current virtual action index being processed.\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  public index: number = -1;\n\n  /**\n   * This creates an instance of a `VirtualTimeScheduler`. Experts only. The signature of\n   * this constructor is likely to change in the long run.\n   *\n   * @param schedulerActionCtor The type of Action to initialize when initializing actions during scheduling.\n   * @param maxFrames The maximum number of frames to process before stopping. Used to prevent endless flush cycles.\n   */\n  constructor(schedulerActionCtor: typeof AsyncAction = VirtualAction as any, public maxFrames: number = Infinity) {\n    super(schedulerActionCtor, () => this.frame);\n  }\n\n  /**\n   * Prompt the Scheduler to execute all of its queued actions, therefore\n   * clearing its queue.\n   */\n  public flush(): void {\n    const { actions, maxFrames } = this;\n    let error: any;\n    let action: AsyncAction<any> | undefined;\n\n    while ((action = actions[0]) && action.delay <= maxFrames) {\n      actions.shift();\n      this.frame = action.delay;\n\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    }\n\n    if (error) {\n      while ((action = actions.shift())) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n\nexport class VirtualAction<T> extends AsyncAction<T> {\n  protected active: boolean = true;\n\n  constructor(\n    protected scheduler: VirtualTimeScheduler,\n    protected work: (this: SchedulerAction<T>, state?: T) => void,\n    protected index: number = (scheduler.index += 1)\n  ) {\n    super(scheduler, work);\n    this.index = scheduler.index = index;\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (Number.isFinite(delay)) {\n      if (!this.id) {\n        return super.schedule(state, delay);\n      }\n      this.active = false;\n      // If an action is rescheduled, we save allocations by mutating its state,\n      // pushing it to the end of the scheduler queue, and recycling the action.\n      // But since the VirtualTimeScheduler is used for testing, VirtualActions\n      // must be immutable so they can be inspected later.\n      const action = new VirtualAction(this.scheduler, this.work);\n      this.add(action);\n      return action.schedule(state, delay);\n    } else {\n      // If someone schedules something with Infinity, it'll never happen. So we\n      // don't even schedule it.\n      return Subscription.EMPTY;\n    }\n  }\n\n  protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle {\n    this.delay = scheduler.frame + delay;\n    const { actions } = scheduler;\n    actions.push(this);\n    (actions as Array<VirtualAction<T>>).sort(VirtualAction.sortActions);\n    return 1;\n  }\n\n  protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle | undefined {\n    return undefined;\n  }\n\n  protected _execute(state: T, delay: number): any {\n    if (this.active === true) {\n      return super._execute(state, delay);\n    }\n  }\n\n  private static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n}\n", "import { Observable } from './Observable';\nimport { EmptyError } from './util/EmptyError';\nimport { SafeSubscriber } from './Subscriber';\n\nexport interface FirstValueFromConfig<T> {\n  defaultValue: T;\n}\n\nexport function firstValueFrom<T, D>(source: Observable<T>, config: FirstValueFromConfig<D>): Promise<T | D>;\nexport function firstValueFrom<T>(source: Observable<T>): Promise<T>;\n\n/**\n * Converts an observable to a promise by subscribing to the observable,\n * and returning a promise that will resolve as soon as the first value\n * arrives from the observable. The subscription will then be closed.\n *\n * If the observable stream completes before any values were emitted, the\n * returned promise will reject with {@link EmptyError} or will resolve\n * with the default value if a default was specified.\n *\n * If the observable stream emits an error, the returned promise will reject\n * with that error.\n *\n * **WARNING**: Only use this with observables you *know* will emit at least one value,\n * *OR* complete. If the source observable does not emit one value or complete, you will\n * end up with a promise that is hung up, and potentially all of the state of an\n * async function hanging out in memory. To avoid this situation, look into adding\n * something like {@link timeout}, {@link take}, {@link takeWhile}, or {@link takeUntil}\n * amongst others.\n *\n * ## Example\n *\n * Wait for the first value from a stream and emit it from a promise in\n * an async function\n *\n * ```ts\n * import { interval, firstValueFrom } from 'rxjs';\n *\n * async function execute() {\n *   const source$ = interval(2000);\n *   const firstNumber = await firstValueFrom(source$);\n *   console.log(`The first number is ${ firstNumber }`);\n * }\n *\n * execute();\n *\n * // Expected output:\n * // 'The first number is 0'\n * ```\n *\n * @see {@link lastValueFrom}\n *\n * @param source the observable to convert to a promise\n * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value\n */\nexport function firstValueFrom<T, D>(source: Observable<T>, config?: FirstValueFromConfig<D>): Promise<T | D> {\n  const hasConfig = typeof config === 'object';\n  return new Promise<T | D>((resolve, reject) => {\n    const subscriber = new SafeSubscriber<T>({\n      next: (value) => {\n        resolve(value);\n        subscriber.unsubscribe();\n      },\n      error: reject,\n      complete: () => {\n        if (hasConfig) {\n          resolve(config!.defaultValue);\n        } else {\n          reject(new EmptyError());\n        }\n      },\n    });\n    source.subscribe(subscriber);\n  });\n}\n", "import { Observable } from '../Observable';\nimport { ObservableInput, ObservableInputTuple, SchedulerLike } from '../types';\nimport { mergeAll } from '../operators/mergeAll';\nimport { innerFrom } from './innerFrom';\nimport { EMPTY } from './empty';\nimport { popNumber, popScheduler } from '../util/args';\nimport { from } from './from';\n\nexport function merge<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\nexport function merge<A extends readonly unknown[]>(...sourcesAndConcurrency: [...ObservableInputTuple<A>, number?]): Observable<A[number]>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function merge<A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike?]\n): Observable<A[number]>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function merge<A extends readonly unknown[]>(\n  ...sourcesAndConcurrencyAndScheduler: [...ObservableInputTuple<A>, number?, SchedulerLike?]\n): Observable<A[number]>;\n\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * ![](merge.png)\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n *\n * Merge together two Observables: 1s interval and clicks\n *\n * ```ts\n * import { merge, fromEvent, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const timer = interval(1000);\n * const clicksOrTimer = merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // timer will emit ascending values, one every second(1000ms) to console\n * // clicks logs MouseEvents to console every time the \"document\" is clicked\n * // Since the two streams are merged you see these happening\n * // as they occur.\n * ```\n *\n * Merge together 3 Observables, but run only 2 concurrently\n *\n * ```ts\n * import { interval, take, merge } from 'rxjs';\n *\n * const timer1 = interval(1000).pipe(take(10));\n * const timer2 = interval(2000).pipe(take(6));\n * const timer3 = interval(500).pipe(take(10));\n *\n * const concurrent = 2; // the argument\n * const merged = merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - First timer1 and timer2 will run concurrently\n * // - timer1 will emit a value every 1000ms for 10 iterations\n * // - timer2 will emit a value every 2000ms for 6 iterations\n * // - after timer1 hits its max iteration, timer2 will\n * //   continue, and timer3 will start to run concurrently with timer2\n * // - when timer2 hits its max iteration it terminates, and\n * //   timer3 will continue to emit a value every 500ms until it is complete\n * ```\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param args `ObservableInput`s to merge together. If the last parameter\n * is of type number, `merge` will use it to limit number of concurrently\n * subscribed `ObservableInput`s. If the last parameter is {@link SchedulerLike},\n * it will be used for scheduling the emission of values.\n * @return An Observable that emits items that are the result of every input Observable.\n */\nexport function merge(...args: (ObservableInput<unknown> | number | SchedulerLike)[]): Observable<unknown> {\n  const scheduler = popScheduler(args);\n  const concurrent = popNumber(args, Infinity);\n  const sources = args as ObservableInput<unknown>[];\n  return !sources.length\n    ? // No source provided\n      EMPTY\n    : sources.length === 1\n    ? // One source? Just return it.\n      innerFrom(sources[0])\n    : // Merge all sources\n      mergeAll(concurrent)(from(sources, scheduler));\n}\n", "import { Observable } from '../Observable';\nimport { noop } from '../util/noop';\n\n/**\n * An Observable that emits no items to the Observer and never completes.\n *\n * ![](never.png)\n *\n * A simple Observable that emits neither values nor errors nor the completion\n * notification. It can be used for testing purposes or for composing with other\n * Observables. Please note that by never emitting a complete notification, this\n * Observable keeps the subscription from being disposed automatically.\n * Subscriptions need to be manually disposed.\n *\n * ##  Example\n *\n * Emit the number 7, then never emit anything else (not even complete)\n *\n * ```ts\n * import { NEVER, startWith } from 'rxjs';\n *\n * const info = () => console.log('Will not be called');\n *\n * const result = NEVER.pipe(startWith(7));\n * result.subscribe({\n *   next: x => console.log(x),\n *   error: info,\n *   complete: info\n * });\n * ```\n *\n * @see {@link Observable}\n * @see {@link EMPTY}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const NEVER = new Observable<never>(noop);\n\n/**\n * @deprecated Replaced with the {@link NEVER} constant. Will be removed in v8.\n */\nexport function never() {\n  return NEVER;\n}\n", "import type {\n    MongoQuery,\n    DeepReadonlyObject\n} from './types/index.js';\n\n\nexport function lastOfArray<T>(ar: T[]): T {\n    return ar[ar.length - 1];\n}\n\n/**\n * @link https://stackoverflow.com/a/5915122\n */\nexport function randomOfArray<T>(items: T[]): T {\n    return items[Math.floor(Math.random() * items.length)];\n}\n\nexport function shuffleArray<T>(arr: T[]): T[] {\n    return arr.slice().sort(() => (Math.random() - 0.5));\n}\n\n/**\n * normalizes sort-field\n * in: '-age'\n * out: 'age'\n */\nexport function normalizeSortField(field: string): string {\n    if (field.startsWith('-')) {\n        return field.substr(1);\n    } else {\n        return field;\n    }\n}\n\nexport function getSortFieldsOfQuery(query: MongoQuery): string[] {\n    if (!query.sort) {\n        // if no sort-order is set, use the primary key\n        return ['_id'];\n    }\n    return query.sort.map(maybeArray => {\n        if (Array.isArray(maybeArray)) {\n            return maybeArray[0].map((field: any) => normalizeSortField(field));\n        } else {\n            return normalizeSortField(maybeArray);\n        }\n    });\n}\n\n/**\n *  @link https://stackoverflow.com/a/1431113\n */\nexport function replaceCharAt(str: string, index: number, replacement: string) {\n    return str.substr(0, index) + replacement + str.substr(index + replacement.length);\n}\n\nexport function mapToObject<K, V>(map: Map<K, V>): {\n    [k: string]: V\n} {\n    const ret: any = {};\n    map.forEach(\n        (value: V, key: K) => {\n            ret[key as any] = value;\n        }\n    );\n    return ret;\n}\n\nexport function objectToMap<K, V>(object: {\n    [k: string]: V\n}): Map<K, V> {\n    const ret = new Map();\n    Object.entries(object).forEach(([k, v]) => {\n        ret.set(k, v);\n    });\n    return ret;\n}\n\nexport function cloneMap<K, V>(map: Map<K, V>): Map<K, V> {\n    const ret: any = new Map();\n    map.forEach(\n        (value: V, key: K) => {\n            ret[key as any] = value;\n        }\n    );\n    return ret;\n}\n\n/**\n * does a flat copy on the objects,\n * is about 3 times faster then using deepClone\n * @link https://jsperf.com/object-rest-spread-vs-clone/2\n */\nexport function flatClone<T>(obj: T | DeepReadonlyObject<T>): T {\n    return Object.assign({}, obj) as any;\n}\n\nexport function ensureNotFalsy<T>(obj: T | false | undefined | null): T {\n    if (!obj) {\n        throw new Error('ensureNotFalsy() is falsy');\n    }\n    return obj;\n}\n\nexport function mergeSets<T>(sets: Set<T>[]): Set<T> {\n    let ret: Set<T> = new Set();\n    sets.forEach(set => {\n        ret = new Set([...ret, ...set]);\n    });\n    return ret;\n}\n\n/**\n * @link https://stackoverflow.com/a/12830454/3443137\n */\nexport function roundToTwoDecimals(num: number): number {\n    return parseFloat(num.toFixed(2));\n}\n\n\nexport function isObject(value: null) {\n    const type = typeof value;\n    return value !== null && (type === 'object' || type === 'function');\n}\n\nexport function getProperty(object: any, path: string | string[], value?: any) {\n    if (Array.isArray(path)) {\n        path = path.join('.');\n    }\n\n    if (!isObject(object as any) || typeof path !== 'string') {\n        return value === undefined ? object : value;\n    }\n\n    const pathArray = path.split('.');\n    if (pathArray.length === 0) {\n        return value;\n    }\n\n    for (let index = 0; index < pathArray.length; index++) {\n        const key = pathArray[index];\n\n        if (isStringIndex(object as any, key as any)) {\n            object = index === pathArray.length - 1 ? undefined : null;\n        } else {\n            object = (object as any)[key];\n        }\n\n        if (object === undefined || object === null) {\n            // `object` is either `undefined` or `null` so we want to stop the loop, and\n            // if this is not the last bit of the path, and\n            // if it didn't return `undefined`\n            // it would return `null` if `object` is `null`\n            // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n            if (index !== pathArray.length - 1) {\n                return value;\n            }\n\n            break;\n        }\n    }\n\n    return object === undefined ? value : object;\n}\n\nfunction isStringIndex(object: any[], key: string) {\n    if (typeof key !== 'number' && Array.isArray(object)) {\n        const index = Number.parseInt(key, 10);\n        return Number.isInteger(index) && object[index] === object[key as any];\n    }\n\n    return false;\n}\n", "import type { StateResolveFunction } from '../types/index.js';\nimport { getProperty, lastOfArray } from '../util.js';\n\nexport const hasLimit: StateResolveFunction<any> = (input) => {\n    return !!input.queryParams.limit;\n};\n\nexport const isFindOne: StateResolveFunction<any> = (input) => {\n    return input.queryParams.limit === 1;\n};\n\nexport const hasSkip: StateResolveFunction<any> = (input) => {\n    if (input.queryParams.skip && input.queryParams.skip > 0) {\n        return true;\n    } else {\n        return false;\n    }\n};\n\nexport const isDelete: StateResolveFunction<any> = (input) => {\n    return input.changeEvent.operation === 'DELETE';\n};\n\nexport const isInsert: StateResolveFunction<any> = (input) => {\n    return input.changeEvent.operation === 'INSERT';\n};\n\nexport const isUpdate: StateResolveFunction<any> = (input) => {\n    return input.changeEvent.operation === 'UPDATE';\n};\n\n\nexport const wasLimitReached: StateResolveFunction<any> = (input) => {\n    return hasLimit(input) && input.previousResults.length >= (input.queryParams.limit as number);\n};\n\nexport const sortParamsChanged: StateResolveFunction<any> = (input) => {\n    const sortFields = input.queryParams.sortFields;\n    const prev = input.changeEvent.previous;\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n    if (!prev) {\n        return true;\n    }\n\n    for (let i = 0; i < sortFields.length; i++) {\n        const field = sortFields[i];\n        const beforeData = getProperty(prev, field);\n        const afterData = getProperty(doc, field);\n        if (beforeData !== afterData) {\n            return true;\n        }\n    }\n    return false;\n};\n\nexport const wasInResult: StateResolveFunction<any> = (input) => {\n    const id = input.changeEvent.id;\n    if (input.keyDocumentMap) {\n        const has = input.keyDocumentMap.has(id);\n        return has;\n    } else {\n        const primary = input.queryParams.primaryKey;\n        const results = input.previousResults;\n        for (let i = 0; i < results.length; i++) {\n            const item = results[i];\n            if (item[primary] === id) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nexport const wasFirst: StateResolveFunction<any> = (input) => {\n    const first = input.previousResults[0];\n    if (first && first[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    } else {\n        return false;\n    }\n};\n\nexport const wasLast: StateResolveFunction<any> = (input) => {\n    const last = lastOfArray(input.previousResults);\n    if (last && last[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    } else {\n        return false;\n    }\n};\n\n\nexport const wasSortedBeforeFirst: StateResolveFunction<any> = (input) => {\n    const prev = input.changeEvent.previous;\n    if (!prev) {\n        return false;\n    }\n\n    const first = input.previousResults[0];\n    if (!first) {\n        return false;\n    }\n\n    /**\n     * If the changed document is the same as the first,\n     * we cannot sort-compare them, because it might end in a non-deterministic\n     * sort order. Because both document could be equal.\n     * So instead we have to return true.\n     */\n    if (first[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n\n    const comp = input.queryParams.sortComparator(\n        prev,\n        first\n    );\n    return comp < 0;\n};\n\nexport const wasSortedAfterLast: StateResolveFunction<any> = (input) => {\n    const prev = input.changeEvent.previous;\n    if (!prev) {\n        return false;\n    }\n\n    const last = lastOfArray(input.previousResults);\n    if (!last) {\n        return false;\n    }\n\n    if (last[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n\n    const comp = input.queryParams.sortComparator(\n        prev,\n        last\n    );\n    return comp > 0;\n};\n\nexport const isSortedBeforeFirst: StateResolveFunction<any> = (input) => {\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n\n    const first = input.previousResults[0];\n    if (!first) {\n        return false;\n    }\n\n    if (first[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n\n    const comp = input.queryParams.sortComparator(\n        doc,\n        first\n    );\n    return comp < 0;\n};\n\nexport const isSortedAfterLast: StateResolveFunction<any> = (input) => {\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n\n    const last = lastOfArray(input.previousResults);\n    if (!last) {\n        return false;\n    }\n\n    if (last[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n\n    const comp = input.queryParams.sortComparator(\n        doc,\n        last\n    );\n    return comp > 0;\n};\n\n\nexport const wasMatching: StateResolveFunction<any> = (input) => {\n    const prev = input.changeEvent.previous;\n    if (!prev) {\n        return false;\n    }\n    return input.queryParams.queryMatcher(\n        prev\n    );\n};\n\nexport const doesMatchNow: StateResolveFunction<any> = (input) => {\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n    const ret = input.queryParams.queryMatcher(\n        doc\n    );\n    return ret;\n};\n\n\nexport const wasResultsEmpty: StateResolveFunction<any> = (input) => {\n    return input.previousResults.length === 0;\n};\n", "import { ResolverFunctions } from 'binary-decision-diagram';\n\nimport type {\n    StateName,\n    StateResolveFunction,\n    StateSet,\n    StateResolveFunctionInput\n} from '../types/index.js';\n\nimport {\n    hasLimit,\n    isFindOne,\n    hasSkip,\n    wasResultsEmpty,\n    isDelete,\n    isInsert,\n    isUpdate,\n    wasLimitReached,\n    sortParamsChanged,\n    wasInResult,\n    wasFirst,\n    wasLast,\n    wasSortedBeforeFirst,\n    wasSortedAfterLast,\n    isSortedBeforeFirst,\n    isSortedAfterLast,\n    wasMatching,\n    doesMatchNow\n} from './state-resolver.js';\n\nexport * from './state-resolver.js';\n\n/**\n * all states ordered by performance-cost\n * cheapest first\n * TODO run tests on which is really the fastest\n */\nexport const orderedStateList: StateName[] = [\n    'isInsert',\n    'isUpdate',\n    'isDelete',\n    'hasLimit',\n    'isFindOne',\n    'hasSkip',\n    'wasResultsEmpty',\n    'wasLimitReached',\n    'wasFirst',\n    'wasLast',\n    'sortParamsChanged',\n    'wasInResult',\n    'wasSortedBeforeFirst',\n    'wasSortedAfterLast',\n    'isSortedBeforeFirst',\n    'isSortedAfterLast',\n    'wasMatching',\n    'doesMatchNow'\n];\n\nexport const stateResolveFunctions: {\n    readonly [k in StateName]: StateResolveFunction<any>\n} = {\n    isInsert,\n    isUpdate,\n    isDelete,\n    hasLimit,\n    isFindOne,\n    hasSkip,\n    wasResultsEmpty,\n    wasLimitReached,\n    wasFirst,\n    wasLast,\n    sortParamsChanged,\n    wasInResult,\n    wasSortedBeforeFirst,\n    wasSortedAfterLast,\n    isSortedBeforeFirst,\n    isSortedAfterLast,\n    wasMatching,\n    doesMatchNow\n};\n\nexport const stateResolveFunctionByIndex: ResolverFunctions<\n    StateResolveFunctionInput<any>\n> = {\n    0: isInsert,\n    1: isUpdate,\n    2: isDelete,\n    3: hasLimit,\n    4: isFindOne,\n    5: hasSkip,\n    6: wasResultsEmpty,\n    7: wasLimitReached,\n    8: wasFirst,\n    9: wasLast,\n    10: sortParamsChanged,\n    11: wasInResult,\n    12: wasSortedBeforeFirst,\n    13: wasSortedAfterLast,\n    14: isSortedBeforeFirst,\n    15: isSortedAfterLast,\n    16: wasMatching,\n    17: doesMatchNow\n};\n\nexport function resolveState<DocType>(\n    stateName: StateName,\n    input: StateResolveFunctionInput<DocType>\n): boolean {\n    const fn: StateResolveFunction<DocType> = stateResolveFunctions[stateName];\n    if (!fn) {\n        throw new Error('resolveState() has no function for ' + stateName);\n    }\n    return fn(input);\n}\n\nexport function getStateSet<DocType>(\n    input: StateResolveFunctionInput<DocType>\n): StateSet {\n    let set: StateSet = '';\n    for (let i = 0; i < orderedStateList.length; i++) {\n        const name: StateName = orderedStateList[i];\n        const value = resolveState(name, input);\n        const add = value ? '1' : '0';\n        set += add;\n    }\n    return set;\n}\n\nexport function logStateSet(stateSet: StateSet) {\n    orderedStateList.forEach((state, index) => {\n        console.log('state: ' + state + ' : ' + stateSet[index]);\n    });\n}\n", "/**\n * copied and adapted from npm 'binary-search-insert'\n * @link https://www.npmjs.com/package/binary-search-insert\n */\nexport function pushAtSortPosition(array, item, compareFunction, low) {\n  var length = array.length;\n  var high = length - 1;\n  var mid = 0;\n\n  /**\n   * Optimization shortcut.\n   */\n  if (length === 0) {\n    array.push(item);\n    return 0;\n  }\n\n  /**\n   * So we do not have to get the ret[mid] doc again\n   * at the last we store it here.\n   */\n  var lastMidDoc;\n  while (low <= high) {\n    // https://github.com/darkskyapp/binary-search\n    // http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html\n    mid = low + (high - low >> 1);\n    lastMidDoc = array[mid];\n    if (compareFunction(lastMidDoc, item) <= 0.0) {\n      // searching too low\n      low = mid + 1;\n    } else {\n      // searching too high\n      high = mid - 1;\n    }\n  }\n  if (compareFunction(lastMidDoc, item) <= 0.0) {\n    mid++;\n  }\n\n  /**\n   * Insert at correct position\n   */\n  array.splice(mid, 0, item);\n  return mid;\n}", "import {\n    pushAtSortPosition\n} from 'array-push-at-sort-position';\n\nimport type { ActionFunction } from '../types/index.js';\n\nexport const doNothing: ActionFunction<any> = (_input) => { };\n\nexport const insertFirst: ActionFunction<any> = (input) => {\n    input.previousResults.unshift(input.changeEvent.doc);\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.set(\n            input.changeEvent.id,\n            input.changeEvent.doc\n        );\n    }\n};\nexport const insertLast: ActionFunction<any> = (input) => {\n    input.previousResults.push(input.changeEvent.doc);\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.set(\n            input.changeEvent.id,\n            input.changeEvent.doc\n        );\n    }\n};\nexport const removeFirstItem: ActionFunction<any> = (input) => {\n    const first = input.previousResults.shift();\n    if (input.keyDocumentMap && first) {\n        input.keyDocumentMap.delete(\n            first[input.queryParams.primaryKey]\n        );\n    }\n};\n\nexport const removeLastItem: ActionFunction<any> = (input) => {\n    const last = input.previousResults.pop();\n    if (input.keyDocumentMap && last) {\n        input.keyDocumentMap.delete(\n            last[input.queryParams.primaryKey]\n        );\n    }\n};\n\nexport const removeFirstInsertLast: ActionFunction<any> = (input) => {\n    removeFirstItem(input);\n    insertLast(input);\n};\n\nexport const removeLastInsertFirst: ActionFunction<any> = (input) => {\n    removeLastItem(input);\n    insertFirst(input);\n};\n\nexport const removeFirstInsertFirst: ActionFunction<any> = (input) => {\n    removeFirstItem(input);\n    insertFirst(input);\n};\n\nexport const removeLastInsertLast: ActionFunction<any> = (input) => {\n    removeLastItem(input);\n    insertLast(input);\n};\n\nexport const removeExisting: ActionFunction<any> = (input) => {\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.delete(\n            input.changeEvent.id\n        );\n    }\n\n    // find index of document\n    const primary = input.queryParams.primaryKey;\n    const results = input.previousResults;\n    for (let i = 0; i < results.length; i++) {\n        const item = results[i];\n        // remove\n        if (item[primary] === input.changeEvent.id) {\n            results.splice(i, 1);\n            break;\n        }\n    }\n};\n\nexport const replaceExisting: ActionFunction<any> = (input) => {\n    // find index of document\n    const doc = input.changeEvent.doc;\n    const primary = input.queryParams.primaryKey;\n    const results = input.previousResults;\n    for (let i = 0; i < results.length; i++) {\n        const item = results[i];\n        // replace\n        if (item[primary] === input.changeEvent.id) {\n            results[i] = doc;\n            if (input.keyDocumentMap) {\n                input.keyDocumentMap.set(\n                    input.changeEvent.id,\n                    doc\n                );\n            }\n            break;\n        }\n    }\n};\n\n/**\n * this function always returns wrong results\n * it must be later optimised out\n * otherwise there is something broken\n */\nexport const alwaysWrong: ActionFunction<any> = (input) => {\n    const wrongHuman = {\n        _id: 'wrongHuman' + new Date().getTime()\n    };\n    input.previousResults.length = 0; // clear array\n    input.previousResults.push(wrongHuman);\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.clear();\n        input.keyDocumentMap.set(\n            wrongHuman._id,\n            wrongHuman\n        );\n    }\n};\n\nexport const insertAtSortPosition: ActionFunction<any> = (input) => {\n    const docId = input.changeEvent.id;\n    const doc = input.changeEvent.doc;\n    if (input.keyDocumentMap) {\n\n        if (input.keyDocumentMap.has(docId)) {\n            /**\n             * If document is already in results,\n             * we cannot add it again because it would throw on non-deterministic ordering.\n             */\n            return;\n        }\n\n        input.keyDocumentMap.set(\n            docId,\n            doc\n        );\n    } else {\n        const isDocInResults = input.previousResults.find((d: any) => d[input.queryParams.primaryKey] === docId);\n        /**\n         * If document is already in results,\n         * we cannot add it again because it would throw on non-deterministic ordering.\n         */\n        if (isDocInResults) {\n            return;\n        }\n    }\n\n    pushAtSortPosition(\n        input.previousResults,\n        doc,\n        input.queryParams.sortComparator,\n        0\n    );\n};\n\nexport const removeExistingAndInsertAtSortPosition: ActionFunction<any> = (input) => {\n    removeExisting(input);\n    insertAtSortPosition(input);\n};\n\nexport const runFullQueryAgain: ActionFunction<any> = (_input) => {\n    throw new Error('Action runFullQueryAgain must be implemented by yourself');\n};\n\nexport const unknownAction: ActionFunction<any> = (_input) => {\n    throw new Error('Action unknownAction should never be called');\n};\n", "import type {\n    ActionName,\n    ActionFunction\n} from '../types/index.js';\n\nimport {\n    doNothing,\n    insertFirst,\n    insertLast,\n    removeFirstItem,\n    removeLastItem,\n    removeFirstInsertLast,\n    removeLastInsertFirst,\n    removeExisting,\n    replaceExisting,\n    alwaysWrong,\n    insertAtSortPosition,\n    removeExistingAndInsertAtSortPosition,\n    runFullQueryAgain,\n    unknownAction,\n    removeFirstInsertFirst,\n    removeLastInsertLast\n} from './action-functions.js';\n\nexport * from './action-functions.js';\n\n/**\n * all actions ordered by performance-cost\n * cheapest first\n * TODO run tests on which is really the fastest\n */\nexport const orderedActionList: ActionName[] = [\n    'doNothing',\n    'insertFirst',\n    'insertLast',\n    'removeFirstItem',\n    'removeLastItem',\n    'removeFirstInsertLast',\n    'removeLastInsertFirst',\n    'removeFirstInsertFirst',\n    'removeLastInsertLast',\n    'removeExisting',\n    'replaceExisting',\n    'alwaysWrong',\n    'insertAtSortPosition',\n    'removeExistingAndInsertAtSortPosition',\n    'runFullQueryAgain',\n    'unknownAction'\n];\n\n\nexport const actionFunctions: {\n    [k in ActionName]: ActionFunction<any>\n} = {\n    doNothing,\n    insertFirst,\n    insertLast,\n    removeFirstItem,\n    removeLastItem,\n    removeFirstInsertLast,\n    removeLastInsertFirst,\n    removeFirstInsertFirst,\n    removeLastInsertLast,\n    removeExisting,\n    replaceExisting,\n    alwaysWrong,\n    insertAtSortPosition,\n    removeExistingAndInsertAtSortPosition,\n    runFullQueryAgain,\n    unknownAction\n};\n", "/*\nlet t = 0;\nwhile (t < 10000) {\n    const char = String.fromCharCode(t);\n    console.log(t + ' : ' + char);\n    t++;\n}\n*/\n\n/*\n\nTo have a really small string representation, we have to hack some stuff\nwhich makes is complicated but effective.\n\nRules for the string:\n- The string starts with a number like '23' that defines how many leaf-nodes we have\n- leaf nodes consist of two chars like 'ab'\n    - the first char is the id\n    - the second the value is a number you can get via String.charCodeAt()\n- Internal nodes have four chars like 'abcd'\n    - the first char is the id\n    - the second char is the id of the 0-branch\n    - the third char is the id of the 1-branch\n    - the last char is the id of the boolean-function (= level)\n- The last 3 chars of the string is the root node like 'abc'\n    - it looks like the internal-node but without the id (first char)\n\n*/\n\n// we use this because 39 is the quotes which causes problems\nexport const CHAR_CODE_OFFSET = 40; // String.fromCharCode(33) === ')'\n\n\nexport function getCharOfLevel(level: number): string {\n    const charCode = CHAR_CODE_OFFSET + level;\n    return String.fromCharCode(charCode);\n}\n\nexport function getNumberOfChar(char: string): number {\n    const charCode = char.charCodeAt(0);\n    return charCode - CHAR_CODE_OFFSET;\n}\n\nexport function getCharOfValue(value: number): string {\n    const charCode = CHAR_CODE_OFFSET + value;\n    return String.fromCharCode(charCode);\n}\n\n\nexport const FIRST_CHAR_CODE_FOR_ID = 97; // String.fromCharCode(97) === 'a'\n\nexport function getNextCharId(lastCode: number): {\n    char: string,\n    nextCode: number\n} {\n\n    // jump these codes because they look strange\n    if (lastCode >= 128 && lastCode <= 160) {\n        lastCode = 161;\n    }\n\n    const char = String.fromCharCode(lastCode);\n    return {\n        char,\n        nextCode: lastCode + 1\n    };\n}\n", "import type { BooleanString } from './types.ts';\n\nexport function booleanStringToBoolean(str: BooleanString): boolean {\n    if (str === '1') {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nexport function booleanToBooleanString(b: boolean): BooleanString {\n    if (b) {\n        return '1';\n    } else {\n        return '0';\n    }\n}\n\nexport function oppositeBoolean(input: BooleanString): BooleanString {\n    if (input === '1') {\n        return '0';\n    } else {\n        return '1';\n    }\n}\n\nexport function lastChar(str: string): string {\n    return str.slice(-1);\n}\n\n/**\n * @link https://stackoverflow.com/a/1349426\n */\nfunction makeid(length: number = 6): string {\n    let result = '';\n    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    const charactersLength = characters.length;\n    for (let i = 0; i < length; i++) {\n        result += characters.charAt(Math.floor(Math.random() * charactersLength));\n    }\n    return result;\n}\n\nconst nodeIdPrefix = makeid(4);\nlet lastIdGen = 0;\nexport function nextNodeId(): string {\n    const ret = 'node_' + nodeIdPrefix + '_' + lastIdGen;\n    lastIdGen++;\n    return ret;\n}\n\n/**\n * @link https://stackoverflow.com/a/16155417\n */\nexport function decimalToPaddedBinary(\n    decimal: number,\n    padding: number\n) {\n    const binary = (decimal >>> 0).toString(2);\n    const padded = binary.padStart(padding, '0');\n    return padded;\n}\n\nexport function oppositeBinary(i: string): string {\n    if (i === '1') {\n        return '0';\n    } else if (i === '0') {\n        return '1';\n    } else {\n        throw new Error('non-binary given');\n    }\n}\n\nexport function binaryToDecimal(binary: string): number {\n    return parseInt(binary, 2);\n}\n\nexport function minBinaryWithLength(length: number): string {\n    return new Array(length).fill(0).map(() => '0').join('');\n}\n\nexport function maxBinaryWithLength(length: number): string {\n    return new Array(length).fill(0).map(() => '1').join('');\n}\n\nexport function getNextStateSet(\n    stateSet: string\n): string {\n    const decimal = binaryToDecimal(stateSet);\n    const increase = decimal + 1;\n    const binary = decimalToPaddedBinary(increase, stateSet.length);\n    return binary;\n}\n\nexport function firstKeyOfMap(map: Map<string, any>): string {\n    const iterator1 = map.keys();\n    return iterator1.next().value;\n}\n\n/**\n * Shuffles array in place. ES6 version\n * @link https://stackoverflow.com/a/6274381\n */\nexport function shuffleArray<T>(a: T[]): T[] {\n    for (let i = a.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [a[i], a[j]] = [a[j], a[i]];\n    }\n    return a;\n}\n\nexport function lastOfArray<T>(ar: T[]): T {\n    return ar[ar.length - 1];\n}\n\n/**\n * @link https://stackoverflow.com/a/6259536\n */\nexport function splitStringToChunks(str: string, chunkSize: number): string[] {\n    const chunks: string[] = [];\n\n    for (let i = 0, charsLength = str.length; i < charsLength; i += chunkSize) {\n        chunks.push(str.substring(i, i + chunkSize));\n    }\n    return chunks;\n}\n", "import {\n    SimpleBdd,\n    SimpleBddLeafNode\n} from '../types.js';\nimport { splitStringToChunks } from '../util.js';\nimport { getNumberOfChar } from './string-format.js';\n\nexport function minimalStringToSimpleBdd(\n    str: string\n): SimpleBdd {\n    const nodesById: Map<string, SimpleBdd | SimpleBddLeafNode> = new Map();\n\n    // parse leaf nodes\n    const leafNodeAmount = parseInt(str.charAt(0) + str.charAt(1), 10);\n    const lastLeafNodeChar = (2 + leafNodeAmount * 2);\n    const leafNodeChars = str.substring(2, lastLeafNodeChar);\n    const leafNodeChunks = splitStringToChunks(leafNodeChars, 2);\n    for (let i = 0; i < leafNodeChunks.length; i++) {\n        const chunk = leafNodeChunks[i];\n        const id = chunk.charAt(0);\n        const value: SimpleBddLeafNode = getNumberOfChar(chunk.charAt(1));\n        nodesById.set(id, value);\n    }\n\n    // parse internal nodes\n    const internalNodeChars = str.substring(lastLeafNodeChar, str.length - 3);\n    const internalNodeChunks = splitStringToChunks(internalNodeChars, 4);\n    for (let i = 0; i < internalNodeChunks.length; i++) {\n        const chunk = internalNodeChunks[i];\n        const id = chunk.charAt(0);\n        const idOf0Branch = chunk.charAt(1);\n        const idOf1Branch = chunk.charAt(2);\n        const level = getNumberOfChar(chunk.charAt(3));\n\n\n        if (!nodesById.has(idOf0Branch)) {\n            throw new Error('missing node with id ' + idOf0Branch);\n        }\n        if (!nodesById.has(idOf1Branch)) {\n            throw new Error('missing node with id ' + idOf1Branch);\n        }\n\n        const node0 = nodesById.get(idOf0Branch) as SimpleBdd;\n        const node1 = nodesById.get(idOf1Branch) as SimpleBdd;\n        const node: SimpleBdd = {\n            l: level, // level is first for prettier json output\n            0: node0,\n            1: node1\n        };\n        nodesById.set(id, node);\n    }\n\n    // parse root node\n    const last3 = str.slice(-3);\n    const idOf0 = last3.charAt(0);\n    const idOf1 = last3.charAt(1);\n    const levelOfRoot = getNumberOfChar(last3.charAt(2));\n    const nodeOf0 = nodesById.get(idOf0) as SimpleBdd;\n    const nodeOf1 = nodesById.get(idOf1) as SimpleBdd;\n    const rootNode: SimpleBdd = {\n        l: levelOfRoot,\n        0: nodeOf0,\n        1: nodeOf1,\n    };\n\n    return rootNode;\n}\n", "import {\n    SimpleBdd,\n    ResolverFunctions,\n    SimpleBddLeafNode\n} from '../types.js';\nimport { booleanToBooleanString } from '../util.js';\n\nexport function resolveWithSimpleBdd(\n    simpleBdd: SimpleBdd,\n    fns: ResolverFunctions,\n    input: any\n): number {\n    let currentNode: SimpleBdd | SimpleBddLeafNode = simpleBdd;\n    let currentLevel: number = simpleBdd.l;\n    while (true) {\n        const booleanResult = fns[currentLevel](input);\n        const branchKey = booleanToBooleanString(booleanResult);\n        currentNode = currentNode[branchKey];\n        if (typeof currentNode === 'number' || typeof currentNode === 'string') {\n            return currentNode as any;\n        } else {\n            currentLevel = currentNode.l;\n        }\n    }\n}\n", "import {\n    SimpleBdd,\n    minimalStringToSimpleBdd,\n    resolveWithSimpleBdd\n} from 'binary-decision-diagram';\nimport type { StateResolveFunctionInput } from '../types/index.js';\nimport { stateResolveFunctionByIndex } from '../states/index.js';\n\nexport const minimalBddString = '14a1b,c+d2e5f0g/h.i4j*k-l)m(n6oeh6pnm6qen6ril6snh6tin6ubo9vce9wmh9xns9yne9zmi9{cm9|ad9}cp9~aq9ae9bf9bq9cg9ck9cn9nd9np9nq9nf9ng9nm9nk9mr9ms9mt9mj9mk9ml9mn9mc8{8}888mn88m8m4z4w4z44444m4v7yn77~777n777m77m7m7m5m5m55m555m55m5m552|2u2222x222|222222n2n222n2/an/bn/cn///////////,cn,,,,,,,ac0bc00000000000m-m-----------3333(((++++11*m*.';\n\nlet simpleBdd: SimpleBdd | undefined;\nexport function getSimpleBdd() {\n    if (!simpleBdd) {\n        simpleBdd = minimalStringToSimpleBdd(minimalBddString);\n    }\n    return simpleBdd;\n}\n\nexport const resolveInput = (input: StateResolveFunctionInput<any>) => {\n    return resolveWithSimpleBdd(\n        getSimpleBdd(),\n        stateResolveFunctionByIndex,\n        input\n    );\n};\n", "import type {\n    ChangeEvent,\n    ActionName,\n    ResultKeyDocumentMap,\n    QueryParams,\n    StateSetToActionMap,\n    StateSet,\n    ActionFunction,\n    StateResolveFunctionInput\n} from './types/index.js';\nimport { getStateSet } from './states/index.js';\nimport { actionFunctions, orderedActionList } from './actions/index.js';\nimport { resolveInput } from './bdd/bdd.generated.js';\n\n/**\n * Export as type to ensure we do not\n * end with an import statement in the build output\n * which would increase the build size.\n */\nexport type {\n    ActionFunction,\n    ActionFunctionInput,\n    ActionName,\n    ChangeEvent,\n    ChangeEventBase,\n    ChangeEventDelete,\n    ChangeEventInsert,\n    ChangeEventUpdate,\n    MongoQuery,\n    QueryMatcher,\n    QueryParams,\n    ResultKeyDocumentMap,\n    DeterministicSortComparator,\n    StateName,\n    StateResolveFunction,\n    StateResolveFunctionInput,\n    StateSet,\n    StateSetToActionMap,\n    WriteOperation\n} from './types/index.js';\n\nexport * from './states/index.js';\nexport * from './util.js';\nexport * from './actions/index.js';\n\nexport function calculateActionFromMap<DocType>(\n    stateSetToActionMap: StateSetToActionMap,\n    input: StateResolveFunctionInput<DocType>\n): {\n    action: ActionName,\n    stateSet: StateSet\n} {\n    const stateSet: StateSet = getStateSet(input);\n    const actionName = stateSetToActionMap.get(stateSet);\n    if (!actionName) {\n        return {\n            action: 'runFullQueryAgain',\n            stateSet\n        };\n    } else {\n        return {\n            action: actionName,\n            stateSet\n        };\n    }\n}\n\nexport function calculateActionName<DocType>(\n    input: StateResolveFunctionInput<DocType>\n): ActionName {\n    const resolvedActionId = resolveInput(\n        input\n    );\n    return orderedActionList[resolvedActionId];\n}\n\nexport function calculateActionFunction<DocType>(\n    input: StateResolveFunctionInput<DocType>\n): ActionFunction<DocType> {\n    const actionName = calculateActionName(input);\n    return actionFunctions[actionName];\n}\n\n/**\n * for performance reasons,\n * @mutates the input\n * @returns the new results\n */\nexport function runAction<DocType>(\n    action: ActionName,\n    queryParams: QueryParams<DocType>,\n    changeEvent: ChangeEvent<DocType>,\n    previousResults: DocType[],\n    keyDocumentMap?: ResultKeyDocumentMap<DocType>\n): DocType[] {\n    const fn: ActionFunction<DocType> = actionFunctions[action];\n    fn({\n        queryParams,\n        changeEvent,\n        previousResults,\n        keyDocumentMap\n    });\n    return previousResults;\n}\n", "import {\n    ActionName,\n    calculateActionName,\n    runAction,\n    QueryParams,\n    QueryMatcher,\n    DeterministicSortComparator,\n    StateResolveFunctionInput,\n    ChangeEvent\n} from 'event-reduce-js';\nimport type {\n    RxQuery,\n    MangoQuery,\n    RxChangeEvent,\n    StringKeys,\n    RxDocumentData\n} from './types/index.d.ts';\nimport { rxChangeEventToEventReduceChangeEvent } from './rx-change-event.ts';\nimport {\n    arrayFilterNotEmpty,\n    clone,\n    ensureNotFalsy,\n    getFromMapOrCreate\n} from './plugins/utils/index.ts';\nimport { getQueryMatcher, getSortComparator, normalizeMangoQuery } from './rx-query-helper.ts';\n\nexport type EventReduceResultNeg = {\n    runFullQueryAgain: true;\n};\nexport type EventReduceResultPos<RxDocumentType> = {\n    runFullQueryAgain: false;\n    changed: boolean;\n    newResults: RxDocumentType[];\n};\nexport type EventReduceResult<RxDocumentType> = EventReduceResultNeg | EventReduceResultPos<RxDocumentType>;\n\n\nexport function getSortFieldsOfQuery<RxDocType>(\n    primaryKey: StringKeys<RxDocumentData<RxDocType>>,\n    query: MangoQuery<RxDocType>\n): (string | StringKeys<RxDocType>)[] {\n    if (!query.sort || query.sort.length === 0) {\n        return [primaryKey];\n    } else {\n        return query.sort.map(part => Object.keys(part)[0]);\n    }\n}\n\n\n\nexport const RXQUERY_QUERY_PARAMS_CACHE: WeakMap<RxQuery, QueryParams<any>> = new WeakMap();\nexport function getQueryParams<RxDocType>(\n    rxQuery: RxQuery<RxDocType>\n): QueryParams<RxDocType> {\n    return getFromMapOrCreate(\n        RXQUERY_QUERY_PARAMS_CACHE,\n        rxQuery,\n        () => {\n            const collection = rxQuery.collection;\n            const normalizedMangoQuery = normalizeMangoQuery(\n                collection.storageInstance.schema,\n                clone(rxQuery.mangoQuery)\n            );\n            const primaryKey = collection.schema.primaryPath;\n\n            /**\n             * Create a custom sort comparator\n             * that uses the hooks to ensure\n             * we send for example compressed documents to be sorted by compressed queries.\n             */\n            const sortComparator = getSortComparator(\n                collection.schema.jsonSchema,\n                normalizedMangoQuery\n            );\n\n            const useSortComparator: DeterministicSortComparator<RxDocType> = (docA: RxDocType, docB: RxDocType) => {\n                const sortComparatorData = {\n                    docA,\n                    docB,\n                    rxQuery\n                };\n                return sortComparator(sortComparatorData.docA, sortComparatorData.docB);\n            };\n\n            /**\n             * Create a custom query matcher\n             * that uses the hooks to ensure\n             * we send for example compressed documents to match compressed queries.\n             */\n            const queryMatcher = getQueryMatcher(\n                collection.schema.jsonSchema,\n                normalizedMangoQuery\n            );\n            const useQueryMatcher: QueryMatcher<RxDocumentData<RxDocType>> = (doc: RxDocumentData<RxDocType>) => {\n                const queryMatcherData = {\n                    doc,\n                    rxQuery\n                };\n                return queryMatcher(queryMatcherData.doc);\n            };\n\n            const ret: QueryParams<any> = {\n                primaryKey: rxQuery.collection.schema.primaryPath as any,\n                skip: normalizedMangoQuery.skip,\n                limit: normalizedMangoQuery.limit,\n                sortFields: getSortFieldsOfQuery(primaryKey, normalizedMangoQuery) as string[],\n                sortComparator: useSortComparator,\n                queryMatcher: useQueryMatcher\n            };\n            return ret;\n        }\n    );\n}\n\n\nexport function calculateNewResults<RxDocumentType>(\n    rxQuery: RxQuery<RxDocumentType>,\n    rxChangeEvents: RxChangeEvent<RxDocumentType>[]\n): EventReduceResult<RxDocumentType> {\n    if (!rxQuery.collection.database.eventReduce) {\n        return {\n            runFullQueryAgain: true\n        };\n    }\n    const queryParams = getQueryParams(rxQuery);\n    const previousResults: RxDocumentType[] = ensureNotFalsy(rxQuery._result).docsData.slice(0);\n    const previousResultsMap: Map<string, RxDocumentType> = ensureNotFalsy(rxQuery._result).docsDataMap;\n    let changed: boolean = false;\n\n    const eventReduceEvents: ChangeEvent<RxDocumentType>[] = rxChangeEvents\n        .map(cE => rxChangeEventToEventReduceChangeEvent(cE))\n        .filter(arrayFilterNotEmpty);\n\n    const foundNonOptimizeable = eventReduceEvents.find(eventReduceEvent => {\n        const stateResolveFunctionInput: StateResolveFunctionInput<RxDocumentType> = {\n            queryParams,\n            changeEvent: eventReduceEvent,\n            previousResults,\n            keyDocumentMap: previousResultsMap\n        };\n\n        const actionName: ActionName = calculateActionName(stateResolveFunctionInput);\n        if (actionName === 'runFullQueryAgain') {\n            return true;\n        } else if (actionName !== 'doNothing') {\n            changed = true;\n            runAction(\n                actionName,\n                queryParams,\n                eventReduceEvent,\n                previousResults,\n                previousResultsMap\n            );\n            return false;\n        }\n    });\n    if (foundNonOptimizeable) {\n        return {\n            runFullQueryAgain: true,\n        };\n    } else {\n        return {\n            runFullQueryAgain: false,\n            changed,\n            newResults: previousResults\n        };\n    }\n}\n", "import {\n    BehaviorSubject,\n    Observable,\n    merge\n} from 'rxjs';\nimport {\n    mergeMap,\n    filter,\n    map,\n    startWith,\n    distinctUntilChanged,\n    shareReplay\n} from 'rxjs/operators';\nimport {\n    sortObject,\n    pluginMissing,\n    overwriteGetterForCaching,\n    now,\n    PROMISE_RESOLVE_FALSE,\n    RXJS_SHARE_REPLAY_DEFAULTS,\n    ensureNotFalsy,\n    areRxDocumentArraysEqual,\n    appendToArray\n} from './plugins/utils/index.ts';\nimport {\n    newRxError\n} from './rx-error.ts';\nimport {\n    runPluginHooks\n} from './hooks.ts';\nimport type {\n    RxCollection,\n    RxDocument,\n    RxQueryOP,\n    RxQuery,\n    MangoQuery,\n    MangoQuerySortPart,\n    MangoQuerySelector,\n    PreparedQuery,\n    RxChangeEvent,\n    RxDocumentWriteData,\n    RxDocumentData,\n    QueryMatcher,\n    RxJsonSchema,\n    FilledMangoQuery,\n    ModifyFunction\n} from './types/index.d.ts';\nimport { calculateNewResults } from './event-reduce.ts';\nimport { triggerCacheReplacement } from './query-cache.ts';\nimport {\n    getQueryMatcher,\n    normalizeMangoQuery,\n    runQueryUpdateFunction\n\n} from './rx-query-helper.ts';\nimport { RxQuerySingleResult } from './rx-query-single-result.ts';\nimport { getQueryPlan } from './query-planner.ts';\n\nlet _queryCount = 0;\nconst newQueryID = function (): number {\n    return ++_queryCount;\n};\n\nexport class RxQueryBase<\n    RxDocType,\n    RxQueryResult,\n    OrmMethods = {},\n    Reactivity = unknown,\n> {\n\n    public id: number = newQueryID();\n\n    /**\n     * Some stats then are used for debugging and cache replacement policies\n     */\n    public _execOverDatabaseCount: number = 0;\n    public _creationTime = now();\n\n    // used in the query-cache to determine if the RxQuery can be cleaned up.\n    public _lastEnsureEqual = 0;\n\n    public uncached = false;\n\n    // used to count the subscribers to the query\n    public refCount$ = new BehaviorSubject(null);\n\n    public isFindOneByIdQuery: false | string | string[];\n\n\n    /**\n     * Contains the current result state\n     * or null if query has not run yet.\n     */\n    public _result: RxQuerySingleResult<RxDocType> | null = null;\n\n\n    constructor(\n        public op: RxQueryOP,\n        public mangoQuery: Readonly<MangoQuery<RxDocType>>,\n        public collection: RxCollection<RxDocType>,\n        // used by some plugins\n        public other: any = {}\n    ) {\n        if (!mangoQuery) {\n            this.mangoQuery = _getDefaultQuery();\n        }\n\n        this.isFindOneByIdQuery = isFindOneByIdQuery(\n            this.collection.schema.primaryPath as string,\n            mangoQuery\n        );\n    }\n    get $(): Observable<RxQueryResult> {\n        if (!this._$) {\n            const results$ = this.collection.$.pipe(\n                /**\n                 * Performance shortcut.\n                 * Changes to local documents are not relevant for the query.\n                 */\n                filter(changeEvent => !changeEvent.isLocal),\n                /**\n                 * Start once to ensure the querying also starts\n                 * when there where no changes.\n                 */\n                startWith(null),\n                // ensure query results are up to date.\n                mergeMap(() => _ensureEqual(this as any)),\n                // use the current result set, written by _ensureEqual().\n                map(() => this._result),\n                // do not run stuff above for each new subscriber, only once.\n                shareReplay(RXJS_SHARE_REPLAY_DEFAULTS),\n                // do not proceed if result set has not changed.\n                distinctUntilChanged((prev, curr) => {\n                    if (prev && prev.time === ensureNotFalsy(curr).time) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }),\n                filter(result => !!result),\n                /**\n                 * Map the result set to a single RxDocument or an array,\n                 * depending on query type\n                 */\n                map((result) => {\n                    return ensureNotFalsy(result).getValue();\n                })\n            );\n\n            this._$ = merge<any>(\n                results$,\n                /**\n                 * Also add the refCount$ to the query observable\n                 * to allow us to count the amount of subscribers.\n                 */\n                this.refCount$.pipe(\n                    filter(() => false)\n                )\n            );\n        }\n        return this._$ as any;\n    }\n\n    get $$(): Reactivity {\n        const reactivity = this.collection.database.getReactivityFactory();\n        return reactivity.fromObservable(\n            this.$,\n            undefined,\n            this.collection.database\n        ) as any;\n    }\n\n    // stores the changeEvent-number of the last handled change-event\n    public _latestChangeEvent: -1 | number = -1;\n\n    // time stamps on when the last full exec over the database has run\n    // used to properly handle events that happen while the find-query is running\n    // TODO do we still need these properties?\n    public _lastExecStart: number = 0;\n    public _lastExecEnd: number = 0;\n\n    /**\n     * ensures that the exec-runs\n     * are not run in parallel\n     */\n    public _ensureEqualQueue: Promise<boolean> = PROMISE_RESOLVE_FALSE;\n\n    /**\n     * Returns an observable that emits the results\n     * This should behave like an rxjs-BehaviorSubject which means:\n     * - Emit the current result-set on subscribe\n     * - Emit the new result-set when an RxChangeEvent comes in\n     * - Do not emit anything before the first result-set was created (no null)\n     */\n    public _$?: Observable<RxQueryResult>;\n\n    /**\n     * set the new result-data as result-docs of the query\n     * @param newResultData json-docs that were received from the storage\n     */\n    _setResultData(newResultData: RxDocumentData<RxDocType>[] | number | Map<string, RxDocumentData<RxDocType>>): void {\n        if (typeof newResultData === 'undefined') {\n            throw newRxError('QU18', {\n                database: this.collection.database.name,\n                collection: this.collection.name\n            });\n        }\n        if (typeof newResultData === 'number') {\n            this._result = new RxQuerySingleResult<RxDocType>(\n                this as any,\n                [],\n                newResultData\n            );\n            return;\n        } else if (newResultData instanceof Map) {\n            newResultData = Array.from((newResultData as Map<string, RxDocumentData<RxDocType>>).values());\n        }\n\n        const newQueryResult = new RxQuerySingleResult<RxDocType>(\n            this as any,\n            newResultData,\n            newResultData.length\n        );\n        this._result = newQueryResult;\n    }\n\n    /**\n     * executes the query on the database\n     * @return results-array with document-data\n     */\n    async _execOverDatabase(): Promise<RxDocumentData<RxDocType>[] | number> {\n        this._execOverDatabaseCount = this._execOverDatabaseCount + 1;\n        this._lastExecStart = now();\n\n\n        if (this.op === 'count') {\n            const preparedQuery = this.getPreparedQuery();\n            const result = await this.collection.storageInstance.count(preparedQuery);\n            if (result.mode === 'slow' && !this.collection.database.allowSlowCount) {\n                throw newRxError('QU14', {\n                    collection: this.collection,\n                    queryObj: this.mangoQuery\n                });\n            } else {\n                return result.count;\n            }\n        }\n\n        if (this.op === 'findByIds') {\n            const ids: string[] = ensureNotFalsy(this.mangoQuery.selector as any)[this.collection.schema.primaryPath].$in;\n            const ret = new Map<string, RxDocument<RxDocType>>();\n            const mustBeQueried: string[] = [];\n            // first try to fill from docCache\n            ids.forEach(id => {\n                const docData = this.collection._docCache.getLatestDocumentDataIfExists(id);\n                if (docData) {\n                    if (!docData._deleted) {\n                        const doc = this.collection._docCache.getCachedRxDocument(docData);\n                        ret.set(id, doc);\n                    }\n                } else {\n                    mustBeQueried.push(id);\n                }\n            });\n            // everything which was not in docCache must be fetched from the storage\n            if (mustBeQueried.length > 0) {\n                const docs = await this.collection.storageInstance.findDocumentsById(mustBeQueried, false);\n                docs.forEach(docData => {\n                    const doc = this.collection._docCache.getCachedRxDocument(docData);\n                    ret.set(doc.primary, doc);\n                });\n            }\n            return ret as any;\n        }\n\n\n        const docsPromise = queryCollection<RxDocType>(this as any);\n        return docsPromise.then(docs => {\n            this._lastExecEnd = now();\n            return docs;\n        });\n    }\n\n    /**\n     * Execute the query\n     * To have an easier implementations,\n     * just subscribe and use the first result\n     */\n    public exec(throwIfMissing: true): Promise<RxDocument<RxDocType, OrmMethods, Reactivity>>;\n    public exec(): Promise<RxQueryResult>;\n    public async exec(throwIfMissing?: boolean): Promise<any> {\n        if (throwIfMissing && this.op !== 'findOne') {\n            throw newRxError('QU9', {\n                collection: this.collection.name,\n                query: this.mangoQuery,\n                op: this.op\n            });\n        }\n\n        /**\n         * run _ensureEqual() here,\n         * this will make sure that errors in the query which throw inside of the RxStorage,\n         * will be thrown at this execution context and not in the background.\n         */\n        await _ensureEqual(this as any);\n        const useResult = ensureNotFalsy(this._result);\n        return useResult.getValue(throwIfMissing);\n    }\n\n\n\n    /**\n     * cached call to get the queryMatcher\n     * @overwrites itself with the actual value\n     */\n    get queryMatcher(): QueryMatcher<RxDocumentWriteData<RxDocType>> {\n        const schema = this.collection.schema.jsonSchema;\n        const normalizedQuery = normalizeMangoQuery(\n            this.collection.schema.jsonSchema,\n            this.mangoQuery\n        );\n        return overwriteGetterForCaching(\n            this,\n            'queryMatcher',\n            getQueryMatcher(\n                schema,\n                normalizedQuery\n            ) as any\n        );\n    }\n\n    /**\n     * returns a string that is used for equal-comparisons\n     * @overwrites itself with the actual value\n     */\n    toString(): string {\n        const stringObj = sortObject({\n            op: this.op,\n            query: this.mangoQuery,\n            other: this.other\n        }, true);\n        const value = JSON.stringify(stringObj);\n        this.toString = () => value;\n        return value;\n    }\n\n    /**\n     * returns the prepared query\n     * which can be send to the storage instance to query for documents.\n     * @overwrites itself with the actual value.\n     */\n    getPreparedQuery(): PreparedQuery<RxDocType> {\n        const hookInput = {\n            rxQuery: this,\n            // can be mutated by the hooks so we have to deep clone first.\n            mangoQuery: normalizeMangoQuery<RxDocType>(\n                this.collection.schema.jsonSchema,\n                this.mangoQuery\n            )\n        };\n        (hookInput.mangoQuery.selector as any)._deleted = { $eq: false };\n        if (hookInput.mangoQuery.index) {\n            hookInput.mangoQuery.index.unshift('_deleted');\n        }\n        runPluginHooks('prePrepareQuery', hookInput);\n\n        const value = prepareQuery(\n            this.collection.schema.jsonSchema,\n            hookInput.mangoQuery as any\n        );\n\n        this.getPreparedQuery = () => value;\n        return value;\n    }\n\n    /**\n     * returns true if the document matches the query,\n     * does not use the 'skip' and 'limit'\n     */\n    doesDocumentDataMatch(docData: RxDocType | any): boolean {\n        // if doc is deleted, it cannot match\n        if (docData._deleted) {\n            return false;\n        }\n\n        return this.queryMatcher(docData);\n    }\n\n    /**\n     * deletes all found documents\n     * @return promise with deleted documents\n     */\n    remove(): Promise<RxQueryResult> {\n        return this\n            .exec()\n            .then(docs => {\n                if (Array.isArray(docs)) {\n                    // TODO use a bulk operation instead of running .remove() on each document\n                    return Promise.all(docs.map(doc => doc.remove()));\n                } else {\n                    return (docs as any).remove();\n                }\n            });\n    }\n    incrementalRemove(): Promise<RxQueryResult> {\n        return runQueryUpdateFunction(\n            this.asRxQuery,\n            (doc) => doc.incrementalRemove(),\n        );\n    }\n\n\n    /**\n     * helper function to transform RxQueryBase to RxQuery type\n     */\n    get asRxQuery(): RxQuery<RxDocType, RxQueryResult> {\n        return this as any;\n    }\n\n    /**\n     * updates all found documents\n     * @overwritten by plugin (optional)\n     */\n    update(_updateObj: any): Promise<RxQueryResult> {\n        throw pluginMissing('update');\n    }\n\n    patch(patch: Partial<RxDocType>): Promise<RxQueryResult> {\n        return runQueryUpdateFunction(\n            this.asRxQuery,\n            (doc) => doc.patch(patch),\n        );\n    }\n    incrementalPatch(patch: Partial<RxDocType>): Promise<RxQueryResult> {\n        return runQueryUpdateFunction(\n            this.asRxQuery,\n            (doc) => doc.incrementalPatch(patch),\n        );\n    }\n    modify(mutationFunction: ModifyFunction<RxDocType>): Promise<RxQueryResult> {\n        return runQueryUpdateFunction(\n            this.asRxQuery,\n            (doc) => doc.modify(mutationFunction),\n        );\n    }\n    incrementalModify(mutationFunction: ModifyFunction<RxDocType>): Promise<RxQueryResult> {\n        return runQueryUpdateFunction(\n            this.asRxQuery,\n            (doc) => doc.incrementalModify(mutationFunction),\n        );\n    }\n\n\n    // we only set some methods of query-builder here\n    // because the others depend on these ones\n    where(_queryObj: MangoQuerySelector<RxDocType> | keyof RxDocType | string): RxQuery<RxDocType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n    sort(_params: string | MangoQuerySortPart<RxDocType>): RxQuery<RxDocType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n    skip(_amount: number | null): RxQuery<RxDocType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n    limit(_amount: number | null): RxQuery<RxDocType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n}\n\n\nexport function _getDefaultQuery<RxDocType>(): MangoQuery<RxDocType> {\n    return {\n        selector: {}\n    };\n}\n\n/**\n * run this query through the QueryCache\n */\nexport function tunnelQueryCache<RxDocumentType, RxQueryResult>(\n    rxQuery: RxQueryBase<RxDocumentType, RxQueryResult>\n): RxQuery<RxDocumentType, RxQueryResult> {\n    return rxQuery.collection._queryCache.getByQuery(rxQuery as any);\n}\n\nexport function createRxQuery<RxDocType>(\n    op: RxQueryOP,\n    queryObj: MangoQuery<RxDocType>,\n    collection: RxCollection<RxDocType>,\n    other?: any\n) {\n    runPluginHooks('preCreateRxQuery', {\n        op,\n        queryObj,\n        collection,\n        other\n    });\n\n    let ret = new RxQueryBase<RxDocType, any>(op, queryObj, collection, other);\n\n    // ensure when created with same params, only one is created\n    ret = tunnelQueryCache(ret);\n    triggerCacheReplacement(collection);\n\n    return ret;\n}\n\n/**\n * Check if the current results-state is in sync with the database\n * which means that no write event happened since the last run.\n * @return false if not which means it should re-execute\n */\nfunction _isResultsInSync(rxQuery: RxQueryBase<any, any>): boolean {\n    const currentLatestEventNumber = rxQuery.asRxQuery.collection._changeEventBuffer.getCounter();\n    if (rxQuery._latestChangeEvent >= currentLatestEventNumber) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n/**\n * wraps __ensureEqual()\n * to ensure it does not run in parallel\n * @return true if has changed, false if not\n */\nasync function _ensureEqual(rxQuery: RxQueryBase<any, any>): Promise<boolean> {\n    if (rxQuery.collection.awaitBeforeReads.size > 0) {\n        await Promise.all(Array.from(rxQuery.collection.awaitBeforeReads).map(fn => fn()));\n    }\n\n    // Optimisation shortcut\n    if (\n        rxQuery.collection.database.destroyed ||\n        _isResultsInSync(rxQuery)\n    ) {\n        return false;\n    }\n\n    rxQuery._ensureEqualQueue = rxQuery._ensureEqualQueue\n        .then(() => __ensureEqual(rxQuery));\n    return rxQuery._ensureEqualQueue;\n}\n\n/**\n * ensures that the results of this query is equal to the results which a query over the database would give\n * @return true if results have changed\n */\nfunction __ensureEqual<RxDocType>(rxQuery: RxQueryBase<RxDocType, any>): Promise<boolean> {\n    rxQuery._lastEnsureEqual = now();\n\n    /**\n     * Optimisation shortcuts\n     */\n    if (\n        // db is closed\n        rxQuery.collection.database.destroyed ||\n        // nothing happened since last run\n        _isResultsInSync(rxQuery)\n    ) {\n        return PROMISE_RESOLVE_FALSE;\n    }\n\n    let ret = false;\n    let mustReExec = false; // if this becomes true, a whole execution over the database is made\n    if (rxQuery._latestChangeEvent === -1) {\n        // have not executed yet -> must run\n        mustReExec = true;\n    }\n\n    /**\n     * try to use EventReduce to calculate the new results\n     */\n    if (!mustReExec) {\n        const missedChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.getFrom(rxQuery._latestChangeEvent + 1);\n        if (missedChangeEvents === null) {\n            // changeEventBuffer is of bounds -> we must re-execute over the database\n            mustReExec = true;\n        } else {\n            rxQuery._latestChangeEvent = rxQuery.asRxQuery.collection._changeEventBuffer.getCounter();\n\n            const runChangeEvents: RxChangeEvent<RxDocType>[] = rxQuery.asRxQuery.collection\n                ._changeEventBuffer\n                .reduceByLastOfDoc(missedChangeEvents);\n\n            if (rxQuery.op === 'count') {\n                // 'count' query\n                const previousCount = ensureNotFalsy(rxQuery._result).count;\n                let newCount = previousCount;\n                runChangeEvents.forEach(cE => {\n                    const didMatchBefore = cE.previousDocumentData && rxQuery.doesDocumentDataMatch(cE.previousDocumentData);\n                    const doesMatchNow = rxQuery.doesDocumentDataMatch(cE.documentData);\n\n                    if (!didMatchBefore && doesMatchNow) {\n                        newCount++;\n                    }\n                    if (didMatchBefore && !doesMatchNow) {\n                        newCount--;\n                    }\n                });\n                if (newCount !== previousCount) {\n                    ret = true; // true because results changed\n                    rxQuery._setResultData(newCount as any);\n                }\n            } else {\n                // 'find' or 'findOne' query\n                const eventReduceResult = calculateNewResults(\n                    rxQuery as any,\n                    runChangeEvents\n                );\n                if (eventReduceResult.runFullQueryAgain) {\n                    // could not calculate the new results, execute must be done\n                    mustReExec = true;\n                } else if (eventReduceResult.changed) {\n                    // we got the new results, we do not have to re-execute, mustReExec stays false\n                    ret = true; // true because results changed\n                    rxQuery._setResultData(eventReduceResult.newResults as any);\n                }\n            }\n        }\n    }\n\n    // oh no we have to re-execute the whole query over the database\n    if (mustReExec) {\n        return rxQuery._execOverDatabase()\n            .then(newResultData => {\n\n                /**\n                 * The RxStorage is defined to always first emit events and then return\n                 * on bulkWrite() calls. So here we have to use the counter AFTER the execOverDatabase()\n                 * has been run, not the one from before.\n                 */\n                rxQuery._latestChangeEvent = rxQuery.collection._changeEventBuffer.getCounter();\n\n                // A count query needs a different has-changed check.\n                if (typeof newResultData === 'number') {\n                    if (\n                        !rxQuery._result ||\n                        newResultData !== rxQuery._result.count\n                    ) {\n                        ret = true;\n                        rxQuery._setResultData(newResultData as any);\n                    }\n                    return ret;\n                }\n                if (\n                    !rxQuery._result ||\n                    !areRxDocumentArraysEqual(\n                        rxQuery.collection.schema.primaryPath,\n                        newResultData,\n                        rxQuery._result.docsData\n                    )\n                ) {\n                    ret = true; // true because results changed\n                    rxQuery._setResultData(newResultData as any);\n                }\n                return ret;\n            });\n    }\n    return Promise.resolve(ret); // true if results have changed\n}\n\n/**\n * @returns a format of the query that can be used with the storage\n * when calling RxStorageInstance().query()\n */\nexport function prepareQuery<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    mutateableQuery: FilledMangoQuery<RxDocType>\n): PreparedQuery<RxDocType> {\n    if (!mutateableQuery.sort) {\n        throw newRxError('SNH', {\n            query: mutateableQuery\n        });\n    }\n\n    /**\n     * Store the query plan together with the\n     * prepared query to save performance.\n     */\n    const queryPlan = getQueryPlan(\n        schema,\n        mutateableQuery\n    );\n\n    return {\n        query: mutateableQuery,\n        queryPlan\n    };\n}\n\n/**\n * Runs the query over the storage instance\n * of the collection.\n * Does some optimizations to ensure findById is used\n * when specific queries are used.\n */\nexport async function queryCollection<RxDocType>(\n    rxQuery: RxQuery<RxDocType> | RxQueryBase<RxDocType, any>\n): Promise<RxDocumentData<RxDocType>[]> {\n    let docs: RxDocumentData<RxDocType>[] = [];\n    const collection = rxQuery.collection;\n\n    /**\n     * Optimizations shortcut.\n     * If query is find-one-document-by-id,\n     * then we do not have to use the slow query() method\n     * but instead can use findDocumentsById()\n     */\n    if (rxQuery.isFindOneByIdQuery) {\n        if (Array.isArray(rxQuery.isFindOneByIdQuery)) {\n            let docIds = rxQuery.isFindOneByIdQuery;\n            docIds = docIds.filter(docId => {\n                // first try to fill from docCache\n                const docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n                if (docData) {\n                    if (!docData._deleted) {\n                        docs.push(docData);\n                    }\n                    return false;\n                } else {\n                    return true;\n                }\n            });\n            // otherwise get from storage\n            if (docIds.length > 0) {\n                const docsFromStorage = await collection.storageInstance.findDocumentsById(docIds, false);\n                appendToArray(docs, docsFromStorage);\n            }\n        } else {\n            const docId = rxQuery.isFindOneByIdQuery;\n\n            // first try to fill from docCache\n            let docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n            if (!docData) {\n                // otherwise get from storage\n                const fromStorageList = await collection.storageInstance.findDocumentsById([docId], false);\n                if (fromStorageList[0]) {\n                    docData = fromStorageList[0];\n                }\n            }\n            if (docData && !docData._deleted) {\n                docs.push(docData);\n            }\n        }\n    } else {\n        const preparedQuery = rxQuery.getPreparedQuery();\n        const queryResult = await collection.storageInstance.query(preparedQuery);\n        docs = queryResult.documents;\n    }\n    return docs;\n\n}\n\n/**\n * Returns true if the given query\n * selects exactly one document by its id.\n * Used to optimize performance because these kind of\n * queries do not have to run over an index and can use get-by-id instead.\n * Returns false if no query of that kind.\n * Returns the document id otherwise.\n */\nexport function isFindOneByIdQuery(\n    primaryPath: string,\n    query: MangoQuery<any>\n): false | string | string[] {\n    // must have exactly one operator which must be $eq || $in\n    if (\n        !query.skip &&\n        query.selector &&\n        Object.keys(query.selector).length === 1 &&\n        query.selector[primaryPath]\n    ) {\n        const value: any = query.selector[primaryPath];\n        if (typeof value === 'string') {\n            return value;\n        } else if (\n            Object.keys(value).length === 1 &&\n            typeof value.$eq === 'string'\n        ) {\n            return value.$eq;\n        }\n\n        // same with $in string arrays\n        if (\n            Object.keys(value).length === 1 &&\n            Array.isArray(value.$eq) &&\n            // must only contain strings\n            !(value.$eq as any[]).find(r => typeof r !== 'string')\n        ) {\n            return value.$eq;\n        }\n    }\n    return false;\n}\n\n\n\nexport function isRxQuery(obj: any): boolean {\n    return obj instanceof RxQueryBase;\n}\n", "/**\n * Helper functions for accessing the RxStorage instances.\n */\n\nimport { overwritable } from './overwritable.ts';\nimport { newRxError } from './rx-error.ts';\nimport {\n    getPrimaryFieldOfPrimaryKey\n} from './rx-schema-helper.ts';\nimport type {\n    BulkWriteRow,\n    BulkWriteRowProcessed,\n    CategorizeBulkWriteRowsOutput,\n    EventBulk,\n    RxAttachmentData,\n    RxAttachmentWriteData,\n    RxCollection,\n    RxDatabase,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxJsonSchema,\n    RxStorageWriteError,\n    RxStorageChangeEvent,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams,\n    StringKeys,\n    RxStorageWriteErrorConflict,\n    RxStorageWriteErrorAttachment,\n    RxStorage,\n    RxStorageDefaultCheckpoint,\n    FilledMangoQuery,\n    RxStorageBulkWriteResponse\n} from './types/index.d.ts';\nimport {\n    PROMISE_RESOLVE_TRUE,\n    RXDB_VERSION,\n    RX_META_LWT_MINIMUM,\n    appendToArray,\n    createRevision,\n    ensureNotFalsy,\n    flatClone,\n    getDefaultRevision,\n    getDefaultRxDocumentMeta,\n    lastOfArray,\n    now,\n    promiseWait,\n    randomCouchString\n} from './plugins/utils/index.ts';\nimport { Observable, filter, map, startWith, switchMap } from 'rxjs';\nimport { prepareQuery } from './rx-query.ts';\nimport { normalizeMangoQuery } from './rx-query-helper.ts';\nimport { runPluginHooks } from './hooks.ts';\n\nexport const INTERNAL_STORAGE_NAME = '_rxdb_internal';\nexport const RX_DATABASE_LOCAL_DOCS_STORAGE_NAME = 'rxdatabase_storage_local';\n\nexport async function getSingleDocument<RxDocType>(\n    storageInstance: RxStorageInstance<RxDocType, any, any>,\n    documentId: string\n): Promise<RxDocumentData<RxDocType> | undefined> {\n    const results = await storageInstance.findDocumentsById([documentId], false);\n    const doc = results[0];\n    if (doc) {\n        return doc;\n    } else {\n        return undefined;\n    }\n}\n\n/**\n * Writes a single document,\n * throws RxStorageBulkWriteError on failure\n */\nexport async function writeSingle<RxDocType>(\n    instance: RxStorageInstance<RxDocType, any, any>,\n    writeRow: BulkWriteRow<RxDocType>,\n    context: string\n): Promise<RxDocumentData<RxDocType>> {\n    const writeResult = await instance.bulkWrite(\n        [writeRow],\n        context\n    );\n    if (writeResult.error.length > 0) {\n        const error = writeResult.error[0];\n        throw error;\n    } else {\n        const primaryPath = getPrimaryFieldOfPrimaryKey(instance.schema.primaryKey);\n        const success = getWrittenDocumentsFromBulkWriteResponse(primaryPath, [writeRow], writeResult);\n        const ret = success[0];\n        return ret;\n    }\n}\n\n/**\n * Observe the plain document data of a single document.\n * Do not forget to unsubscribe.\n */\nexport function observeSingle<RxDocType>(\n    storageInstance: RxStorageInstance<RxDocType, any, any>,\n    documentId: string\n): Observable<RxDocumentData<RxDocType>> {\n    const firstFindPromise = getSingleDocument(storageInstance, documentId);\n    const ret = storageInstance\n        .changeStream()\n        .pipe(\n            map(evBulk => evBulk.events.find(ev => ev.documentId === documentId)),\n            filter(ev => !!ev),\n            map(ev => Promise.resolve(ensureNotFalsy(ev).documentData)),\n            startWith(firstFindPromise),\n            switchMap(v => v),\n            filter(v => !!v)\n        ) as any;\n    return ret;\n}\n\n/**\n * Checkpoints must be stackable over another.\n * This is required form some RxStorage implementations\n * like the sharding plugin, where a checkpoint only represents\n * the document state from some, but not all shards.\n */\nexport function stackCheckpoints<CheckpointType>(\n    checkpoints: CheckpointType[]\n): CheckpointType {\n    return Object.assign(\n        {},\n        ...checkpoints\n    );\n}\n\nexport function throwIfIsStorageWriteError<RxDocType>(\n    collection: RxCollection<RxDocType, any, any>,\n    documentId: string,\n    writeData: RxDocumentWriteData<RxDocType> | RxDocType,\n    error: RxStorageWriteError<RxDocType> | undefined\n) {\n    if (error) {\n        if (error.status === 409) {\n            throw newRxError('CONFLICT', {\n                collection: collection.name,\n                id: documentId,\n                writeError: error,\n                data: writeData\n            });\n        } else if (error.status === 422) {\n            throw newRxError('VD2', {\n                collection: collection.name,\n                id: documentId,\n                writeError: error,\n                data: writeData\n            });\n        } else {\n            throw error;\n        }\n    }\n}\n\n\n/**\n * Analyzes a list of BulkWriteRows and determines\n * which documents must be inserted, updated or deleted\n * and which events must be emitted and which documents cause a conflict\n * and must not be written.\n * Used as helper inside of some RxStorage implementations.\n * @hotPath The performance of this function is critical\n */\nexport function categorizeBulkWriteRows<RxDocType>(\n    storageInstance: RxStorageInstance<any, any, any>,\n    primaryPath: StringKeys<RxDocType>,\n    /**\n     * Current state of the documents\n     * inside of the storage. Used to determine\n     * which writes cause conflicts.\n     * This must be a Map for better performance.\n     */\n    docsInDb: Map<RxDocumentData<RxDocType>[StringKeys<RxDocType>] | string, RxDocumentData<RxDocType>>,\n    /**\n     * The write rows that are passed to\n     * RxStorageInstance().bulkWrite().\n     */\n    bulkWriteRows: BulkWriteRow<RxDocType>[],\n    context: string,\n    /**\n     * Used by some storages for better performance.\n     * For example when get-by-id and insert/update can run in parallel.\n     */\n    onInsert?: (docData: RxDocumentData<RxDocType>) => void,\n    onUpdate?: (docData: RxDocumentData<RxDocType>) => void\n): CategorizeBulkWriteRowsOutput<RxDocType> {\n    const hasAttachments = !!storageInstance.schema.attachments;\n    const bulkInsertDocs: BulkWriteRowProcessed<RxDocType>[] = [];\n    const bulkUpdateDocs: BulkWriteRowProcessed<RxDocType>[] = [];\n    const errors: RxStorageWriteError<RxDocType>[] = [];\n    const eventBulkId = randomCouchString(10);\n    const eventBulk: EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, any> = {\n        id: eventBulkId,\n        events: [],\n        checkpoint: null,\n        context,\n        startTime: now(),\n        endTime: 0\n    };\n    const eventBulkEvents = eventBulk.events;\n\n    const attachmentsAdd: {\n        documentId: string;\n        attachmentId: string;\n        attachmentData: RxAttachmentWriteData;\n        digest: string;\n    }[] = [];\n    const attachmentsRemove: {\n        documentId: string;\n        attachmentId: string;\n        digest: string;\n    }[] = [];\n    const attachmentsUpdate: {\n        documentId: string;\n        attachmentId: string;\n        attachmentData: RxAttachmentWriteData;\n        digest: string;\n    }[] = [];\n\n    const hasDocsInDb = docsInDb.size > 0;\n    let newestRow: BulkWriteRowProcessed<RxDocType> | undefined;\n\n    /**\n     * @performance is really important in this loop!\n     */\n    const rowAmount = bulkWriteRows.length;\n    for (let rowId = 0; rowId < rowAmount; rowId++) {\n        const writeRow = bulkWriteRows[rowId];\n\n        // use these variables to have less property accesses\n        const document = writeRow.document;\n        const previous = writeRow.previous;\n        const docId = document[primaryPath] as string;\n        const documentDeleted = document._deleted;\n        const previousDeleted = previous && previous._deleted;\n\n        let documentInDb: RxDocumentData<RxDocType> | undefined = undefined as any;\n        if (hasDocsInDb) {\n            documentInDb = docsInDb.get(docId);\n        }\n        let attachmentError: RxStorageWriteErrorAttachment<RxDocType> | undefined;\n\n        if (!documentInDb) {\n            /**\n             * It is possible to insert already deleted documents,\n             * this can happen on replication.\n             */\n            const insertedIsDeleted = documentDeleted ? true : false;\n            if (hasAttachments) {\n                Object\n                    .entries(document._attachments)\n                    .forEach(([attachmentId, attachmentData]) => {\n                        if (\n                            !(attachmentData as RxAttachmentWriteData).data\n                        ) {\n                            attachmentError = {\n                                documentId: docId,\n                                isError: true,\n                                status: 510,\n                                writeRow,\n                                attachmentId\n                            };\n                            errors.push(attachmentError);\n                        } else {\n                            attachmentsAdd.push({\n                                documentId: docId,\n                                attachmentId,\n                                attachmentData: attachmentData as any,\n                                digest: attachmentData.digest\n                            });\n                        }\n                    });\n            }\n            if (!attachmentError) {\n                if (hasAttachments) {\n                    bulkInsertDocs.push(stripAttachmentsDataFromRow(writeRow));\n                    if (onInsert) {\n                        onInsert(document);\n                    }\n                } else {\n                    bulkInsertDocs.push(writeRow as any);\n                    if (onInsert) {\n                        onInsert(document);\n                    }\n                }\n\n                newestRow = writeRow as any;\n            }\n\n            if (!insertedIsDeleted) {\n                const event = {\n                    documentId: docId,\n                    operation: 'INSERT' as const,\n                    documentData: hasAttachments ? stripAttachmentsDataFromDocument(document) : document as any,\n                    previousDocumentData: hasAttachments && previous ? stripAttachmentsDataFromDocument(previous) : previous as any\n                };\n                eventBulkEvents.push(event);\n            }\n        } else {\n            // update existing document\n            const revInDb: string = documentInDb._rev;\n\n            /**\n             * Check for conflict\n             */\n            if (\n                (\n                    !previous\n                ) ||\n                (\n                    !!previous &&\n                    revInDb !== previous._rev\n                )\n            ) {\n                // is conflict error\n                const err: RxStorageWriteError<RxDocType> = {\n                    isError: true,\n                    status: 409,\n                    documentId: docId,\n                    writeRow: writeRow,\n                    documentInDb\n                };\n                errors.push(err);\n                continue;\n            }\n\n            // handle attachments data\n\n            const updatedRow: BulkWriteRowProcessed<RxDocType> = hasAttachments ? stripAttachmentsDataFromRow(writeRow) : writeRow as any;\n            if (hasAttachments) {\n                if (documentDeleted) {\n                    /**\n                     * Deleted documents must have cleared all their attachments.\n                     */\n                    if (previous) {\n                        Object\n                            .keys(previous._attachments)\n                            .forEach(attachmentId => {\n                                attachmentsRemove.push({\n                                    documentId: docId,\n                                    attachmentId,\n                                    digest: ensureNotFalsy(previous)._attachments[attachmentId].digest\n                                });\n                            });\n                    }\n                } else {\n                    // first check for errors\n                    Object\n                        .entries(document._attachments)\n                        .find(([attachmentId, attachmentData]) => {\n                            const previousAttachmentData = previous ? previous._attachments[attachmentId] : undefined;\n                            if (\n                                !previousAttachmentData &&\n                                !(attachmentData as RxAttachmentWriteData).data\n                            ) {\n                                attachmentError = {\n                                    documentId: docId,\n                                    documentInDb: documentInDb as any,\n                                    isError: true,\n                                    status: 510,\n                                    writeRow,\n                                    attachmentId\n                                };\n                            }\n                            return true;\n                        });\n                    if (!attachmentError) {\n                        Object\n                            .entries(document._attachments)\n                            .forEach(([attachmentId, attachmentData]) => {\n                                const previousAttachmentData = previous ? previous._attachments[attachmentId] : undefined;\n                                if (!previousAttachmentData) {\n                                    attachmentsAdd.push({\n                                        documentId: docId,\n                                        attachmentId,\n                                        attachmentData: attachmentData as any,\n                                        digest: attachmentData.digest\n                                    });\n                                } else {\n                                    const newDigest = updatedRow.document._attachments[attachmentId].digest;\n                                    if (\n                                        (attachmentData as RxAttachmentWriteData).data &&\n                                        /**\n                                         * Performance shortcut,\n                                         * do not update the attachment data if it did not change.\n                                         */\n                                        previousAttachmentData.digest !== newDigest\n                                    ) {\n                                        attachmentsUpdate.push({\n                                            documentId: docId,\n                                            attachmentId,\n                                            attachmentData: attachmentData as RxAttachmentWriteData,\n                                            digest: attachmentData.digest\n                                        });\n                                    }\n                                }\n                            });\n                    }\n                }\n            }\n\n            if (attachmentError) {\n                errors.push(attachmentError);\n            } else {\n                if (hasAttachments) {\n                    bulkUpdateDocs.push(stripAttachmentsDataFromRow(updatedRow));\n                    if (onUpdate) {\n                        onUpdate(document);\n                    }\n                } else {\n                    bulkUpdateDocs.push(updatedRow);\n                    if (onUpdate) {\n                        onUpdate(document);\n                    }\n                }\n                newestRow = updatedRow as any;\n            }\n\n            let eventDocumentData: RxDocumentData<RxDocType> | undefined = null as any;\n            let previousEventDocumentData: RxDocumentData<RxDocType> | undefined = null as any;\n            let operation: 'INSERT' | 'UPDATE' | 'DELETE' = null as any;\n\n            if (previousDeleted && !documentDeleted) {\n                operation = 'INSERT';\n                eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(document) : document as any;\n            } else if (previous && !previousDeleted && !documentDeleted) {\n                operation = 'UPDATE';\n                eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(document) : document as any;\n                previousEventDocumentData = previous;\n            } else if (documentDeleted) {\n                operation = 'DELETE';\n                eventDocumentData = ensureNotFalsy(document) as any;\n                previousEventDocumentData = previous;\n            } else {\n                throw newRxError('SNH', { args: { writeRow } });\n            }\n\n            const event = {\n                documentId: docId,\n                documentData: eventDocumentData as RxDocumentData<RxDocType>,\n                previousDocumentData: previousEventDocumentData,\n                operation: operation\n            };\n            eventBulkEvents.push(event);\n        }\n    }\n\n    return {\n        bulkInsertDocs,\n        bulkUpdateDocs,\n        newestRow,\n        errors,\n        eventBulk,\n        attachmentsAdd,\n        attachmentsRemove,\n        attachmentsUpdate\n    };\n}\n\nexport function stripAttachmentsDataFromRow<RxDocType>(writeRow: BulkWriteRow<RxDocType>): BulkWriteRowProcessed<RxDocType> {\n    return {\n        previous: writeRow.previous,\n        document: stripAttachmentsDataFromDocument(writeRow.document)\n    };\n}\n\nexport function getAttachmentSize(\n    attachmentBase64String: string\n): number {\n    return atob(attachmentBase64String).length;\n}\n\n/**\n * Used in custom RxStorage implementations.\n */\nexport function attachmentWriteDataToNormalData(writeData: RxAttachmentData | RxAttachmentWriteData): RxAttachmentData {\n    const data = (writeData as RxAttachmentWriteData).data;\n    if (!data) {\n        return writeData as any;\n    }\n    const ret: RxAttachmentData = {\n        length: getAttachmentSize(data),\n        digest: writeData.digest,\n        type: writeData.type\n    };\n    return ret;\n}\n\nexport function stripAttachmentsDataFromDocument<RxDocType>(doc: RxDocumentWriteData<RxDocType>): RxDocumentData<RxDocType> {\n    if (!doc._attachments || Object.keys(doc._attachments).length === 0) {\n        return doc;\n    }\n\n    const useDoc: RxDocumentData<RxDocType> = flatClone(doc) as any;\n    useDoc._attachments = {};\n    Object\n        .entries(doc._attachments)\n        .forEach(([attachmentId, attachmentData]) => {\n            useDoc._attachments[attachmentId] = attachmentWriteDataToNormalData(attachmentData);\n        });\n    return useDoc;\n}\n\n/**\n * Flat clone the document data\n * and also the _meta field.\n * Used many times when we want to change the meta\n * during replication etc.\n */\nexport function flatCloneDocWithMeta<RxDocType>(\n    doc: RxDocumentData<RxDocType>\n): RxDocumentData<RxDocType> {\n    return Object.assign(\n        {},\n        doc,\n        {\n            _meta: flatClone(doc._meta)\n        }\n    );\n}\n\nexport type WrappedRxStorageInstance<RxDocumentType, Internals, InstanceCreationOptions> = RxStorageInstance<RxDocumentType, any, InstanceCreationOptions> & {\n    originalStorageInstance: RxStorageInstance<RxDocumentType, Internals, InstanceCreationOptions>;\n};\n\n\nconst BULK_WRITE_SUCCESS_MAP = new WeakMap<RxStorageBulkWriteResponse<any>, RxDocumentData<any>>();\n\n/**\n * Wraps the normal storageInstance of a RxCollection\n * to ensure that all access is properly using the hooks\n * and other data transformations and also ensure that database.lockedRun()\n * is used properly.\n */\nexport function getWrappedStorageInstance<\n    RxDocType,\n    Internals,\n    InstanceCreationOptions,\n    CheckpointType\n>(\n    database: RxDatabase<{}, Internals, InstanceCreationOptions, any>,\n    storageInstance: RxStorageInstance<RxDocType, Internals, InstanceCreationOptions, CheckpointType>,\n    /**\n     * The original RxJsonSchema\n     * before it was mutated by hooks.\n     */\n    rxJsonSchema: RxJsonSchema<RxDocumentData<RxDocType>>\n): WrappedRxStorageInstance<RxDocType, Internals, InstanceCreationOptions> {\n    overwritable.deepFreezeWhenDevMode(rxJsonSchema);\n\n    const primaryPath = getPrimaryFieldOfPrimaryKey(storageInstance.schema.primaryKey);\n\n    const ret: WrappedRxStorageInstance<RxDocType, Internals, InstanceCreationOptions> = {\n        originalStorageInstance: storageInstance,\n        schema: storageInstance.schema,\n        internals: storageInstance.internals,\n        collectionName: storageInstance.collectionName,\n        databaseName: storageInstance.databaseName,\n        options: storageInstance.options,\n        bulkWrite(\n            rows: BulkWriteRow<RxDocType>[],\n            context: string\n        ) {\n            const databaseToken = database.token;\n            const toStorageWriteRows: BulkWriteRow<RxDocType>[] = new Array(rows.length);\n            /**\n             * Use the same timestamp for all docs of this rows-set.\n             * This improves performance because calling Date.now() inside of the now() function\n             * is too costly.\n             */\n            const time = now();\n            for (let index = 0; index < rows.length; index++) {\n                const writeRow = rows[index];\n                const document = flatCloneDocWithMeta(writeRow.document);\n                document._meta.lwt = time;\n\n                /**\n                 * Yes we really want to set the revision here.\n                 * If you make a plugin that relies on having its own revision\n                 * stored into the storage, use this.originalStorageInstance.bulkWrite() instead.\n                 */\n                const previous = writeRow.previous;\n                document._rev = createRevision(\n                    databaseToken,\n                    previous\n                );\n                toStorageWriteRows[index] = {\n                    document,\n                    previous\n                };\n            }\n\n            runPluginHooks('preStorageWrite', {\n                storageInstance: this.originalStorageInstance,\n                rows: toStorageWriteRows\n            });\n\n            return database.lockedRun(\n                () => storageInstance.bulkWrite(\n                    toStorageWriteRows,\n                    context\n                )\n            )\n                /**\n                 * The RxStorageInstance MUST NOT allow to insert already _deleted documents,\n                 * without sending the previous document version.\n                 * But for better developer experience, RxDB does allow to re-insert deleted documents.\n                 * We do this by automatically fixing the conflict errors for that case\n                 * by running another bulkWrite() and merging the results.\n                 * @link https://github.com/pubkey/rxdb/pull/3839\n                 */\n                .then(writeResult => {\n                    const useWriteResult: typeof writeResult = {\n                        error: []\n                    };\n\n                    /**\n                     * TODO do we really have to build up the successArray\n                     * here directly? Maybe we only need it when it is really accessed.\n                     */\n                    const successArray = getWrittenDocumentsFromBulkWriteResponse(\n                        primaryPath,\n                        toStorageWriteRows,\n                        writeResult\n                    );\n                    BULK_WRITE_SUCCESS_MAP.set(useWriteResult, successArray);\n\n                    const reInsertErrors: RxStorageWriteErrorConflict<RxDocType>[] = writeResult.error.length === 0\n                        ? []\n                        : writeResult.error\n                            .filter((error) => {\n                                if (\n                                    error.status === 409 &&\n                                    !error.writeRow.previous &&\n                                    !error.writeRow.document._deleted &&\n                                    ensureNotFalsy(error.documentInDb)._deleted\n                                ) {\n                                    return true;\n                                }\n\n                                // add the \"normal\" errors to the parent error array.\n                                useWriteResult.error.push(error);\n                                return false;\n                            }) as any;\n                    if (reInsertErrors.length > 0) {\n                        const reInserts: BulkWriteRow<RxDocType>[] = reInsertErrors\n                            .map((error) => {\n                                return {\n                                    previous: error.documentInDb,\n                                    document: Object.assign(\n                                        {},\n                                        error.writeRow.document,\n                                        {\n                                            _rev: createRevision(\n                                                database.token,\n                                                error.documentInDb\n                                            )\n                                        }\n                                    )\n                                };\n                            });\n\n                        return database.lockedRun(\n                            () => storageInstance.bulkWrite(\n                                reInserts,\n                                context\n                            )\n                        ).then(subResult => {\n                            appendToArray(useWriteResult.error, subResult.error);\n\n                            const subSuccess = getWrittenDocumentsFromBulkWriteResponse(\n                                primaryPath,\n                                reInserts,\n                                subResult\n                            );\n                            appendToArray(successArray, subSuccess);\n\n                            return useWriteResult;\n                        });\n                    }\n                    return useWriteResult;\n                });\n        },\n        query(preparedQuery) {\n            return database.lockedRun(\n                () => storageInstance.query(preparedQuery)\n            );\n        },\n        count(preparedQuery) {\n            return database.lockedRun(\n                () => storageInstance.count(preparedQuery)\n            );\n        },\n        findDocumentsById(ids, deleted) {\n            return database.lockedRun(\n                () => storageInstance.findDocumentsById(ids, deleted)\n            );\n        },\n        getAttachmentData(\n            documentId: string,\n            attachmentId: string,\n            digest: string\n        ) {\n            return database.lockedRun(\n                () => storageInstance.getAttachmentData(documentId, attachmentId, digest)\n            );\n        },\n        getChangedDocumentsSince: !storageInstance.getChangedDocumentsSince ? undefined : (limit: number, checkpoint?: any) => {\n            return database.lockedRun(\n                () => ((storageInstance as any).getChangedDocumentsSince)(ensureNotFalsy(limit), checkpoint)\n            );\n        },\n        cleanup(minDeletedTime: number) {\n            return database.lockedRun(\n                () => storageInstance.cleanup(minDeletedTime)\n            );\n        },\n        remove() {\n            database.storageInstances.delete(ret);\n            return database.lockedRun(\n                () => storageInstance.remove()\n            );\n        },\n        close() {\n            database.storageInstances.delete(ret);\n            return database.lockedRun(\n                () => storageInstance.close()\n            );\n        },\n        changeStream() {\n            return storageInstance.changeStream();\n        },\n        conflictResultionTasks() {\n            return storageInstance.conflictResultionTasks();\n        },\n        resolveConflictResultionTask(taskSolution) {\n            if (taskSolution.output.isEqual) {\n                return storageInstance.resolveConflictResultionTask(taskSolution);\n            }\n\n            const doc = Object.assign(\n                {},\n                taskSolution.output.documentData,\n                {\n                    _meta: getDefaultRxDocumentMeta(),\n                    _rev: getDefaultRevision(),\n                    _attachments: {}\n                }\n            );\n\n            const documentData = flatClone(doc);\n            delete (documentData as any)._meta;\n            delete (documentData as any)._rev;\n            delete (documentData as any)._attachments;\n\n            return storageInstance.resolveConflictResultionTask({\n                id: taskSolution.id,\n                output: {\n                    isEqual: false,\n                    documentData\n                }\n            });\n        }\n    };\n\n    database.storageInstances.add(ret);\n    return ret;\n}\n\n/**\n * Each RxStorage implementation should\n * run this method at the first step of createStorageInstance()\n * to ensure that the configuration is correct.\n */\nexport function ensureRxStorageInstanceParamsAreCorrect(\n    params: RxStorageInstanceCreationParams<any, any>\n) {\n    if (params.schema.keyCompression) {\n        throw newRxError('UT5', { args: { params } });\n    }\n    if (hasEncryption(params.schema)) {\n        throw newRxError('UT6', { args: { params } });\n    }\n    if (\n        params.schema.attachments &&\n        params.schema.attachments.compression\n    ) {\n        throw newRxError('UT7', { args: { params } });\n    }\n}\n\nexport function hasEncryption(jsonSchema: RxJsonSchema<any>): boolean {\n    if (\n        (!!jsonSchema.encrypted && jsonSchema.encrypted.length > 0) ||\n        (jsonSchema.attachments && jsonSchema.attachments.encrypted)\n    ) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nexport function getChangedDocumentsSinceQuery<RxDocType, CheckpointType>(\n    storageInstance: RxStorageInstance<RxDocType, any, any, CheckpointType>,\n    limit: number,\n    checkpoint?: CheckpointType\n): FilledMangoQuery<RxDocType> {\n    const primaryPath = getPrimaryFieldOfPrimaryKey(storageInstance.schema.primaryKey);\n    const sinceLwt = checkpoint ? (checkpoint as unknown as RxStorageDefaultCheckpoint).lwt : RX_META_LWT_MINIMUM;\n    const sinceId = checkpoint ? (checkpoint as unknown as RxStorageDefaultCheckpoint).id : '';\n    return normalizeMangoQuery(storageInstance.schema, {\n        selector: {\n            $or: [\n                {\n                    '_meta.lwt': {\n                        $gt: sinceLwt\n                    }\n                },\n                {\n                    '_meta.lwt': {\n                        $eq: sinceLwt\n                    },\n                    [primaryPath]: {\n                        $gt: checkpoint ? sinceId : ''\n                    }\n                }\n            ],\n            // add this hint for better index usage\n            '_meta.lwt': {\n                $gte: sinceLwt\n            }\n        } as any,\n        sort: [\n            { '_meta.lwt': 'asc' },\n            { [primaryPath]: 'asc' }\n        ] as any,\n        skip: 0,\n        limit,\n        /**\n         * DO NOT SET A SPECIFIC INDEX HERE!\n         * The query might be modified by some plugin\n         * before sending it to the storage.\n         * We can be sure that in the end the query planner\n         * will find the best index.\n         */\n        // index: ['_meta.lwt', primaryPath]\n    });\n}\n\nexport async function getChangedDocumentsSince<RxDocType, CheckpointType>(\n    storageInstance: RxStorageInstance<RxDocType, any, any, CheckpointType>,\n    limit: number,\n    checkpoint?: CheckpointType\n): Promise<{\n    documents: RxDocumentData<RxDocType>[];\n    /**\n     * The checkpoint contains data so that another\n     * call to getChangedDocumentsSince() will continue\n     * from exactly the last document that was returned before.\n     */\n    checkpoint: CheckpointType;\n}> {\n    if (storageInstance.getChangedDocumentsSince) {\n        return storageInstance.getChangedDocumentsSince(limit, checkpoint);\n    }\n\n    const primaryPath = getPrimaryFieldOfPrimaryKey(storageInstance.schema.primaryKey);\n    const query = prepareQuery<RxDocumentData<any>>(\n        storageInstance.schema,\n        getChangedDocumentsSinceQuery(\n            storageInstance,\n            limit,\n            checkpoint\n        )\n    );\n\n    const result = await storageInstance.query(query);\n    const documents = result.documents;\n    const lastDoc = lastOfArray(documents);\n\n    return {\n        documents: documents,\n        checkpoint: lastDoc ? {\n            id: (lastDoc as any)[primaryPath],\n            lwt: lastDoc._meta.lwt\n        } as any : checkpoint ? checkpoint : {\n            id: '',\n            lwt: 0\n        }\n    };\n}\n\n\nexport function getWrittenDocumentsFromBulkWriteResponse<RxDocType>(\n    primaryPath: string,\n    writeRows: BulkWriteRow<RxDocType>[],\n    response: RxStorageBulkWriteResponse<RxDocType>\n): RxDocumentData<RxDocType>[] {\n    const fromMap = BULK_WRITE_SUCCESS_MAP.get(response);\n    if (fromMap) {\n        return fromMap;\n    }\n\n    const ret: RxDocumentData<RxDocType>[] = [];\n    if (response.error.length > 0) {\n        const errorIds = new Set();\n        for (let index = 0; index < response.error.length; index++) {\n            const error = response.error[index];\n            errorIds.add(error.documentId);\n        }\n\n        for (let index = 0; index < writeRows.length; index++) {\n            const doc = writeRows[index].document;\n            if (!errorIds.has((doc as any)[primaryPath])) {\n                ret.push(stripAttachmentsDataFromDocument(doc));\n            }\n        }\n    } else {\n        // pre-set array size for better performance\n        ret.length = writeRows.length - response.error.length;\n        for (let index = 0; index < writeRows.length; index++) {\n            const doc = writeRows[index].document;\n            ret[index] = stripAttachmentsDataFromDocument(doc);\n        }\n    }\n\n    return ret;\n}\n\n\n/**\n * Wraps the storage and simluates\n * delays. Mostly used in tests.\n */\nexport function randomDelayStorage<Internals, InstanceCreationOptions>(\n    input: {\n        storage: RxStorage<Internals, InstanceCreationOptions>;\n        delayTimeBefore: () => number;\n        delayTimeAfter: () => number;\n    }\n): RxStorage<Internals, InstanceCreationOptions> {\n    /**\n     * Ensure writes to a delay storage\n     * are still correctly run in order.\n     */\n    let randomDelayStorageWriteQueue: Promise<any> = PROMISE_RESOLVE_TRUE;\n\n    const retStorage: RxStorage<Internals, InstanceCreationOptions> = {\n        name: 'random-delay-' + input.storage.name,\n        rxdbVersion: RXDB_VERSION,\n        async createStorageInstance(params) {\n            await promiseWait(input.delayTimeBefore());\n            const storageInstance = await input.storage.createStorageInstance(params);\n            await promiseWait(input.delayTimeAfter());\n\n            return {\n                databaseName: storageInstance.databaseName,\n                internals: storageInstance.internals,\n                options: storageInstance.options,\n                schema: storageInstance.schema,\n                collectionName: storageInstance.collectionName,\n                bulkWrite(a, b) {\n                    randomDelayStorageWriteQueue = randomDelayStorageWriteQueue.then(async () => {\n                        await promiseWait(input.delayTimeBefore());\n                        const response = await storageInstance.bulkWrite(a, b);\n                        await promiseWait(input.delayTimeAfter());\n                        return response;\n                    });\n                    const ret = randomDelayStorageWriteQueue;\n                    return ret;\n                },\n                async findDocumentsById(a, b) {\n                    await promiseWait(input.delayTimeBefore());\n                    const ret = await storageInstance.findDocumentsById(a, b);\n                    await promiseWait(input.delayTimeAfter());\n                    return ret;\n                },\n                async query(a) {\n                    await promiseWait(input.delayTimeBefore());\n                    const ret = await storageInstance.query(a);\n                    return ret;\n                },\n                async count(a) {\n                    await promiseWait(input.delayTimeBefore());\n                    const ret = await storageInstance.count(a);\n                    await promiseWait(input.delayTimeAfter());\n                    return ret;\n\n                },\n                async getAttachmentData(a, b, c) {\n                    await promiseWait(input.delayTimeBefore());\n                    const ret = await storageInstance.getAttachmentData(a, b, c);\n                    await promiseWait(input.delayTimeAfter());\n                    return ret;\n\n                },\n                getChangedDocumentsSince: !storageInstance.getChangedDocumentsSince ? undefined : async (a, b) => {\n                    await promiseWait(input.delayTimeBefore());\n                    const ret = await ensureNotFalsy(storageInstance.getChangedDocumentsSince)(a, b);\n                    await promiseWait(input.delayTimeAfter());\n                    return ret;\n\n                },\n                changeStream() {\n                    return storageInstance.changeStream();\n                },\n                conflictResultionTasks() {\n                    return storageInstance.conflictResultionTasks();\n                },\n                resolveConflictResultionTask(a) {\n                    return storageInstance.resolveConflictResultionTask(a);\n                },\n                async cleanup(a) {\n                    await promiseWait(input.delayTimeBefore());\n                    const ret = await storageInstance.cleanup(a);\n                    await promiseWait(input.delayTimeAfter());\n                    return ret;\n\n                },\n                async close() {\n                    await promiseWait(input.delayTimeBefore());\n                    const ret = await storageInstance.close();\n                    await promiseWait(input.delayTimeAfter());\n                    return ret;\n\n                },\n                async remove() {\n                    await promiseWait(input.delayTimeBefore());\n                    const ret = await storageInstance.remove();\n                    await promiseWait(input.delayTimeAfter());\n                    return ret;\n                },\n            };\n\n\n        }\n    };\n    return retStorage;\n}\n", "/**\n * returns true if the given object is a promise\n */\nexport function isPromise(obj) {\n  return obj && typeof obj.then === 'function';\n}\nexport var PROMISE_RESOLVED_FALSE = Promise.resolve(false);\nexport var PROMISE_RESOLVED_TRUE = Promise.resolve(true);\nexport var PROMISE_RESOLVED_VOID = Promise.resolve();\nexport function sleep(time, resolveWith) {\n  if (!time) time = 0;\n  return new Promise(function (res) {\n    return setTimeout(function () {\n      return res(resolveWith);\n    }, time);\n  });\n}\nexport function randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\n/**\n * https://stackoverflow.com/a/8084248\n */\nexport function randomToken() {\n  return Math.random().toString(36).substring(2);\n}\nvar lastMs = 0;\n\n/**\n * Returns the current unix time in micro-seconds,\n * WARNING: This is a pseudo-function\n * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.\n * This is enough in browsers, and this function will not be used in nodejs.\n * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.\n */\nexport function microSeconds() {\n  var ret = Date.now() * 1000; // milliseconds to microseconds\n  if (ret <= lastMs) {\n    ret = lastMs + 1;\n  }\n  lastMs = ret;\n  return ret;\n}\n\n/**\n * Check if WebLock API is supported.\n * @link https://developer.mozilla.org/en-US/docs/Web/API/Web_Locks_API\n */\nexport function supportsWebLockAPI() {\n  if (typeof navigator !== 'undefined' && typeof navigator.locks !== 'undefined' && typeof navigator.locks.request === 'function') {\n    return true;\n  } else {\n    return false;\n  }\n}", "import { microSeconds as micro, PROMISE_RESOLVED_VOID } from '../util.js';\nexport var microSeconds = micro;\nexport var type = 'native';\nexport function create(channelName) {\n  var state = {\n    time: micro(),\n    messagesCallback: null,\n    bc: new BroadcastChannel(channelName),\n    subFns: [] // subscriberFunctions\n  };\n\n  state.bc.onmessage = function (msgEvent) {\n    if (state.messagesCallback) {\n      state.messagesCallback(msgEvent.data);\n    }\n  };\n  return state;\n}\nexport function close(channelState) {\n  channelState.bc.close();\n  channelState.subFns = [];\n}\nexport function postMessage(channelState, messageJson) {\n  try {\n    channelState.bc.postMessage(messageJson, false);\n    return PROMISE_RESOLVED_VOID;\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\nexport function onMessage(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  // Deno runtime\n  // eslint-disable-next-line\n  if (typeof globalThis !== 'undefined' && globalThis.Deno && globalThis.Deno.args) {\n    return true;\n  }\n\n  // Browser runtime\n  if ((typeof window !== 'undefined' || typeof self !== 'undefined') && typeof BroadcastChannel === 'function') {\n    if (BroadcastChannel._pubkey) {\n      throw new Error('BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill');\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function averageResponseTime() {\n  return 150;\n}\nexport var NativeMethod = {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};", "\n/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n */\nexport class ObliviousSet<T = any> {\n    public readonly map = new Map();\n\n    /**\n     * Creating calls to setTimeout() is expensive,\n     * so we only do that if there is not timeout already open.\n     */\n    public _to: boolean = false;\n    constructor(\n        public readonly ttl: number\n    ) { }\n\n    has(value: T): boolean {\n        return this.map.has(value);\n    }\n\n    add(value: T): void {\n        this.map.set(value, now());\n\n        /**\n         * When a new value is added,\n         * start the cleanup at the next tick\n         * to not block the cpu for more important stuff\n         * that might happen.\n         */\n        if (!this._to) {\n            this._to = true;\n            setTimeout(() => {\n                this._to = false;\n                removeTooOldValues(this);\n            }, 0);\n        }\n    }\n\n    clear() {\n        this.map.clear();\n    }\n}\n\n\n/**\n * Removes all entries from the set\n * where the TTL has expired\n */\nexport function removeTooOldValues(\n    obliviousSet: ObliviousSet\n) {\n    const olderThen = now() - obliviousSet.ttl;\n    const iterator = obliviousSet.map[Symbol.iterator]();\n\n    /**\n     * Because we can assume the new values are added at the bottom,\n     * we start from the top and stop as soon as we reach a non-too-old value.\n     */\n    while (true) {\n\n        const next = iterator.next().value;\n\n        if (!next) {\n            return; // no more elements\n        }\n        const value = next[0];\n        const time = next[1];\n        if (time < olderThen) {\n            obliviousSet.map.delete(value);\n        } else {\n            // We reached a value that is not old enough\n            return;\n        }\n    }\n}\n\nexport function now(): number {\n    return Date.now();\n}\n\n\n", "export function fillOptionsWithDefaults() {\n  var originalOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var options = JSON.parse(JSON.stringify(originalOptions));\n\n  // main\n  if (typeof options.webWorkerSupport === 'undefined') options.webWorkerSupport = true;\n\n  // indexed-db\n  if (!options.idb) options.idb = {};\n  //  after this time the messages get deleted\n  if (!options.idb.ttl) options.idb.ttl = 1000 * 45;\n  if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150;\n  //  handles abrupt db onclose events.\n  if (originalOptions.idb && typeof originalOptions.idb.onclose === 'function') options.idb.onclose = originalOptions.idb.onclose;\n\n  // localstorage\n  if (!options.localstorage) options.localstorage = {};\n  if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60;\n\n  // custom methods\n  if (originalOptions.methods) options.methods = originalOptions.methods;\n\n  // node\n  if (!options.node) options.node = {};\n  if (!options.node.ttl) options.node.ttl = 1000 * 60 * 2; // 2 minutes;\n  /**\n   * On linux use 'ulimit -Hn' to get the limit of open files.\n   * On ubuntu this was 4096 for me, so we use half of that as maxParallelWrites default.\n   */\n  if (!options.node.maxParallelWrites) options.node.maxParallelWrites = 2048;\n  if (typeof options.node.useFastPath === 'undefined') options.node.useFastPath = true;\n  return options;\n}", "/**\n * this method uses indexeddb to store the messages\n * There is currently no observerAPI for idb\n * @link https://github.com/w3c/IndexedDB/issues/51\n * \n * When working on this, ensure to use these performance optimizations:\n * @link https://rxdb.info/slow-indexeddb.html\n */\n\nimport { sleep, randomInt, randomToken, microSeconds as micro, PROMISE_RESOLVED_VOID } from '../util.js';\nexport var microSeconds = micro;\nimport { ObliviousSet } from 'oblivious-set';\nimport { fillOptionsWithDefaults } from '../options.js';\nvar DB_PREFIX = 'pubkey.broadcast-channel-0-';\nvar OBJECT_STORE_ID = 'messages';\n\n/**\n * Use relaxed durability for faster performance on all transactions.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */\nexport var TRANSACTION_SETTINGS = {\n  durability: 'relaxed'\n};\nexport var type = 'idb';\nexport function getIdb() {\n  if (typeof indexedDB !== 'undefined') return indexedDB;\n  if (typeof window !== 'undefined') {\n    if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;\n    if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;\n    if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;\n  }\n  return false;\n}\n\n/**\n * If possible, we should explicitly commit IndexedDB transactions\n * for better performance.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */\nexport function commitIndexedDBTransaction(tx) {\n  if (tx.commit) {\n    tx.commit();\n  }\n}\nexport function createDatabase(channelName) {\n  var IndexedDB = getIdb();\n\n  // create table\n  var dbName = DB_PREFIX + channelName;\n\n  /**\n   * All IndexedDB databases are opened without version\n   * because it is a bit faster, especially on firefox\n   * @link http://nparashuram.com/IndexedDB/perf/#Open%20Database%20with%20version\n   */\n  var openRequest = IndexedDB.open(dbName);\n  openRequest.onupgradeneeded = function (ev) {\n    var db = ev.target.result;\n    db.createObjectStore(OBJECT_STORE_ID, {\n      keyPath: 'id',\n      autoIncrement: true\n    });\n  };\n  return new Promise(function (res, rej) {\n    openRequest.onerror = function (ev) {\n      return rej(ev);\n    };\n    openRequest.onsuccess = function () {\n      res(openRequest.result);\n    };\n  });\n}\n\n/**\n * writes the new message to the database\n * so other readers can find it\n */\nexport function writeMessage(db, readerUuid, messageJson) {\n  var time = Date.now();\n  var writeObject = {\n    uuid: readerUuid,\n    time: time,\n    data: messageJson\n  };\n  var tx = db.transaction([OBJECT_STORE_ID], 'readwrite', TRANSACTION_SETTINGS);\n  return new Promise(function (res, rej) {\n    tx.oncomplete = function () {\n      return res();\n    };\n    tx.onerror = function (ev) {\n      return rej(ev);\n    };\n    var objectStore = tx.objectStore(OBJECT_STORE_ID);\n    objectStore.add(writeObject);\n    commitIndexedDBTransaction(tx);\n  });\n}\nexport function getAllMessages(db) {\n  var tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  var objectStore = tx.objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n      if (cursor) {\n        ret.push(cursor.value);\n        //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n        cursor[\"continue\"]();\n      } else {\n        commitIndexedDBTransaction(tx);\n        res(ret);\n      }\n    };\n  });\n}\nexport function getMessagesHigherThan(db, lastCursorId) {\n  var tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  var objectStore = tx.objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n\n  /**\n   * Optimization shortcut,\n   * if getAll() can be used, do not use a cursor.\n   * @link https://rxdb.info/slow-indexeddb.html\n   */\n  if (objectStore.getAll) {\n    var getAllRequest = objectStore.getAll(keyRangeValue);\n    return new Promise(function (res, rej) {\n      getAllRequest.onerror = function (err) {\n        return rej(err);\n      };\n      getAllRequest.onsuccess = function (e) {\n        res(e.target.result);\n      };\n    });\n  }\n  function openCursor() {\n    // Occasionally Safari will fail on IDBKeyRange.bound, this\n    // catches that error, having it open the cursor to the first\n    // item. When it gets data it will advance to the desired key.\n    try {\n      keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n      return objectStore.openCursor(keyRangeValue);\n    } catch (e) {\n      return objectStore.openCursor();\n    }\n  }\n  return new Promise(function (res, rej) {\n    var openCursorRequest = openCursor();\n    openCursorRequest.onerror = function (err) {\n      return rej(err);\n    };\n    openCursorRequest.onsuccess = function (ev) {\n      var cursor = ev.target.result;\n      if (cursor) {\n        if (cursor.value.id < lastCursorId + 1) {\n          cursor[\"continue\"](lastCursorId + 1);\n        } else {\n          ret.push(cursor.value);\n          cursor[\"continue\"]();\n        }\n      } else {\n        commitIndexedDBTransaction(tx);\n        res(ret);\n      }\n    };\n  });\n}\nexport function removeMessagesById(channelState, ids) {\n  if (channelState.closed) {\n    return Promise.resolve([]);\n  }\n  var tx = channelState.db.transaction(OBJECT_STORE_ID, 'readwrite', TRANSACTION_SETTINGS);\n  var objectStore = tx.objectStore(OBJECT_STORE_ID);\n  return Promise.all(ids.map(function (id) {\n    var deleteRequest = objectStore[\"delete\"](id);\n    return new Promise(function (res) {\n      deleteRequest.onsuccess = function () {\n        return res();\n      };\n    });\n  }));\n}\nexport function getOldMessages(db, ttl) {\n  var olderThen = Date.now() - ttl;\n  var tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  var objectStore = tx.objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n      if (cursor) {\n        var msgObk = cursor.value;\n        if (msgObk.time < olderThen) {\n          ret.push(msgObk);\n          //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n          cursor[\"continue\"]();\n        } else {\n          // no more old messages,\n          commitIndexedDBTransaction(tx);\n          res(ret);\n        }\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nexport function cleanOldMessages(channelState) {\n  return getOldMessages(channelState.db, channelState.options.idb.ttl).then(function (tooOld) {\n    return removeMessagesById(channelState, tooOld.map(function (msg) {\n      return msg.id;\n    }));\n  });\n}\nexport function create(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  return createDatabase(channelName).then(function (db) {\n    var state = {\n      closed: false,\n      lastCursorId: 0,\n      channelName: channelName,\n      options: options,\n      uuid: randomToken(),\n      /**\n       * emittedMessagesIds\n       * contains all messages that have been emitted before\n       * @type {ObliviousSet}\n       */\n      eMIs: new ObliviousSet(options.idb.ttl * 2),\n      // ensures we do not read messages in parallel\n      writeBlockPromise: PROMISE_RESOLVED_VOID,\n      messagesCallback: null,\n      readQueuePromises: [],\n      db: db\n    };\n\n    /**\n     * Handle abrupt closes that do not originate from db.close().\n     * This could happen, for example, if the underlying storage is\n     * removed or if the user clears the database in the browser's\n     * history preferences.\n     */\n    db.onclose = function () {\n      state.closed = true;\n      if (options.idb.onclose) options.idb.onclose();\n    };\n\n    /**\n     * if service-workers are used,\n     * we have no 'storage'-event if they post a message,\n     * therefore we also have to set an interval\n     */\n    _readLoop(state);\n    return state;\n  });\n}\nfunction _readLoop(state) {\n  if (state.closed) return;\n  readNewMessages(state).then(function () {\n    return sleep(state.options.idb.fallbackInterval);\n  }).then(function () {\n    return _readLoop(state);\n  });\n}\nfunction _filterMessage(msgObj, state) {\n  if (msgObj.uuid === state.uuid) return false; // send by own\n  if (state.eMIs.has(msgObj.id)) return false; // already emitted\n  if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\n  return true;\n}\n\n/**\n * reads all new messages from the database and emits them\n */\nfunction readNewMessages(state) {\n  // channel already closed\n  if (state.closed) return PROMISE_RESOLVED_VOID;\n\n  // if no one is listening, we do not need to scan for new messages\n  if (!state.messagesCallback) return PROMISE_RESOLVED_VOID;\n  return getMessagesHigherThan(state.db, state.lastCursorId).then(function (newerMessages) {\n    var useMessages = newerMessages\n    /**\n     * there is a bug in iOS where the msgObj can be undefined sometimes\n     * so we filter them out\n     * @link https://github.com/pubkey/broadcast-channel/issues/19\n     */.filter(function (msgObj) {\n      return !!msgObj;\n    }).map(function (msgObj) {\n      if (msgObj.id > state.lastCursorId) {\n        state.lastCursorId = msgObj.id;\n      }\n      return msgObj;\n    }).filter(function (msgObj) {\n      return _filterMessage(msgObj, state);\n    }).sort(function (msgObjA, msgObjB) {\n      return msgObjA.time - msgObjB.time;\n    }); // sort by time\n    useMessages.forEach(function (msgObj) {\n      if (state.messagesCallback) {\n        state.eMIs.add(msgObj.id);\n        state.messagesCallback(msgObj.data);\n      }\n    });\n    return PROMISE_RESOLVED_VOID;\n  });\n}\nexport function close(channelState) {\n  channelState.closed = true;\n  channelState.db.close();\n}\nexport function postMessage(channelState, messageJson) {\n  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function () {\n    return writeMessage(channelState.db, channelState.uuid, messageJson);\n  }).then(function () {\n    if (randomInt(0, 10) === 0) {\n      /* await (do not await) */\n      cleanOldMessages(channelState);\n    }\n  });\n  return channelState.writeBlockPromise;\n}\nexport function onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n  readNewMessages(channelState);\n}\nexport function canBeUsed() {\n  return !!getIdb();\n}\nexport function averageResponseTime(options) {\n  return options.idb.fallbackInterval * 2;\n}\nexport var IndexedDBMethod = {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};", "/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside webworkers because they have no access to localstorage\n * This is basically implemented to support IE9 or your grandmother's toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */\n\nimport { ObliviousSet } from 'oblivious-set';\nimport { fillOptionsWithDefaults } from '../options.js';\nimport { sleep, randomToken, microSeconds as micro } from '../util.js';\nexport var microSeconds = micro;\nvar KEY_PREFIX = 'pubkey.broadcastChannel-';\nexport var type = 'localstorage';\n\n/**\n * copied from crosstab\n * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32\n */\nexport function getLocalStorage() {\n  var localStorage;\n  if (typeof window === 'undefined') return null;\n  try {\n    localStorage = window.localStorage;\n    localStorage = window['ie8-eventlistener/storage'] || window.localStorage;\n  } catch (e) {\n    // New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n  }\n  return localStorage;\n}\nexport function storageKey(channelName) {\n  return KEY_PREFIX + channelName;\n}\n\n/**\n* writes the new message to the storage\n* and fires the storage-event so other readers can find it\n*/\nexport function postMessage(channelState, messageJson) {\n  return new Promise(function (res) {\n    sleep().then(function () {\n      var key = storageKey(channelState.channelName);\n      var writeObj = {\n        token: randomToken(),\n        time: Date.now(),\n        data: messageJson,\n        uuid: channelState.uuid\n      };\n      var value = JSON.stringify(writeObj);\n      getLocalStorage().setItem(key, value);\n\n      /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */\n      var ev = document.createEvent('Event');\n      ev.initEvent('storage', true, true);\n      ev.key = key;\n      ev.newValue = value;\n      window.dispatchEvent(ev);\n      res();\n    });\n  });\n}\nexport function addStorageEventListener(channelName, fn) {\n  var key = storageKey(channelName);\n  var listener = function listener(ev) {\n    if (ev.key === key) {\n      fn(JSON.parse(ev.newValue));\n    }\n  };\n  window.addEventListener('storage', listener);\n  return listener;\n}\nexport function removeStorageEventListener(listener) {\n  window.removeEventListener('storage', listener);\n}\nexport function create(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  if (!canBeUsed()) {\n    throw new Error('BroadcastChannel: localstorage cannot be used');\n  }\n  var uuid = randomToken();\n\n  /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */\n  var eMIs = new ObliviousSet(options.localstorage.removeTimeout);\n  var state = {\n    channelName: channelName,\n    uuid: uuid,\n    eMIs: eMIs // emittedMessagesIds\n  };\n\n  state.listener = addStorageEventListener(channelName, function (msgObj) {\n    if (!state.messagesCallback) return; // no listener\n    if (msgObj.uuid === uuid) return; // own message\n    if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted\n    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n\n    eMIs.add(msgObj.token);\n    state.messagesCallback(msgObj.data);\n  });\n  return state;\n}\nexport function close(channelState) {\n  removeStorageEventListener(channelState.listener);\n}\nexport function onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  var ls = getLocalStorage();\n  if (!ls) return false;\n  try {\n    var key = '__broadcastchannel_check';\n    ls.setItem(key, 'works');\n    ls.removeItem(key);\n  } catch (e) {\n    // Safari 10 in private mode will not allow write access to local\n    // storage and fail with a QuotaExceededError. See\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes\n    return false;\n  }\n  return true;\n}\nexport function averageResponseTime() {\n  var defaultTime = 120;\n  var userAgent = navigator.userAgent.toLowerCase();\n  if (userAgent.includes('safari') && !userAgent.includes('chrome')) {\n    // safari is much slower so this time is higher\n    return defaultTime * 2;\n  }\n  return defaultTime;\n}\nexport var LocalstorageMethod = {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};", "import { microSeconds as micro } from '../util.js';\nexport var microSeconds = micro;\nexport var type = 'simulate';\nvar SIMULATE_CHANNELS = new Set();\nexport function create(channelName) {\n  var state = {\n    time: microSeconds(),\n    name: channelName,\n    messagesCallback: null\n  };\n  SIMULATE_CHANNELS.add(state);\n  return state;\n}\nexport function close(channelState) {\n  SIMULATE_CHANNELS[\"delete\"](channelState);\n}\nexport var SIMULATE_DELAY_TIME = 5;\nexport function postMessage(channelState, messageJson) {\n  return new Promise(function (res) {\n    return setTimeout(function () {\n      var channelArray = Array.from(SIMULATE_CHANNELS);\n      channelArray.forEach(function (channel) {\n        if (channel.name === channelState.name &&\n        // has same name\n        channel !== channelState &&\n        // not own channel\n        !!channel.messagesCallback &&\n        // has subscribers\n        channel.time < messageJson.time // channel not created after postMessage() call\n        ) {\n          channel.messagesCallback(messageJson);\n        }\n      });\n      res();\n    }, SIMULATE_DELAY_TIME);\n  });\n}\nexport function onMessage(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  return true;\n}\nexport function averageResponseTime() {\n  return SIMULATE_DELAY_TIME;\n}\nexport var SimulateMethod = {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};", "import { NativeMethod } from './methods/native.js';\nimport { IndexedDBMethod } from './methods/indexed-db.js';\nimport { LocalstorageMethod } from './methods/localstorage.js';\nimport { SimulateMethod } from './methods/simulate.js';\n// the line below will be removed from es5/browser builds\n\n// order is important\nvar METHODS = [NativeMethod,\n// fastest\nIndexedDBMethod, LocalstorageMethod];\nexport function chooseMethod(options) {\n  var chooseMethods = [].concat(options.methods, METHODS).filter(Boolean);\n\n  // the line below will be removed from es5/browser builds\n\n  // directly chosen\n  if (options.type) {\n    if (options.type === 'simulate') {\n      // only use simulate-method if directly chosen\n      return SimulateMethod;\n    }\n    var ret = chooseMethods.find(function (m) {\n      return m.type === options.type;\n    });\n    if (!ret) throw new Error('method-type ' + options.type + ' not found');else return ret;\n  }\n\n  /**\n   * if no webworker support is needed,\n   * remove idb from the list so that localstorage will be chosen\n   */\n  if (!options.webWorkerSupport) {\n    chooseMethods = chooseMethods.filter(function (m) {\n      return m.type !== 'idb';\n    });\n  }\n  var useMethod = chooseMethods.find(function (method) {\n    return method.canBeUsed();\n  });\n  if (!useMethod) {\n    throw new Error(\"No usable method found in \" + JSON.stringify(METHODS.map(function (m) {\n      return m.type;\n    })));\n  } else {\n    return useMethod;\n  }\n}", "import { isPromise, PROMISE_RESOLVED_FALSE, PROMISE_RESOLVED_VOID } from './util.js';\nimport { chooseMethod } from './method-chooser.js';\nimport { fillOptionsWithDefaults } from './options.js';\n\n/**\n * Contains all open channels,\n * used in tests to ensure everything is closed.\n */\nexport var OPEN_BROADCAST_CHANNELS = new Set();\nvar lastId = 0;\nexport var BroadcastChannel = function BroadcastChannel(name, options) {\n  // identifier of the channel to debug stuff\n  this.id = lastId++;\n  OPEN_BROADCAST_CHANNELS.add(this);\n  this.name = name;\n  if (ENFORCED_OPTIONS) {\n    options = ENFORCED_OPTIONS;\n  }\n  this.options = fillOptionsWithDefaults(options);\n  this.method = chooseMethod(this.options);\n\n  // isListening\n  this._iL = false;\n\n  /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */\n  this._onML = null;\n\n  /**\n   * _addEventListeners\n   */\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n\n  /**\n   * Unsent message promises\n   * where the sending is still in progress\n   * @type {Set<Promise>}\n   */\n  this._uMP = new Set();\n\n  /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */\n  this._befC = [];\n\n  /**\n   * _preparePromise\n   */\n  this._prepP = null;\n  _prepareChannel(this);\n};\n\n// STATICS\n\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */\nBroadcastChannel._pubkey = true;\n\n/**\n * clears the tmp-folder if is node\n * @return {Promise<boolean>} true if has run, false if not node\n */\nexport function clearNodeFolder(options) {\n  options = fillOptionsWithDefaults(options);\n  var method = chooseMethod(options);\n  if (method.type === 'node') {\n    return method.clearNodeFolder().then(function () {\n      return true;\n    });\n  } else {\n    return PROMISE_RESOLVED_FALSE;\n  }\n}\n\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */\nvar ENFORCED_OPTIONS;\nexport function enforceOptions(options) {\n  ENFORCED_OPTIONS = options;\n}\n\n// PROTOTYPE\nBroadcastChannel.prototype = {\n  postMessage: function postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed ' +\n      /**\n       * In the past when this error appeared, it was really hard to debug.\n       * So now we log the msg together with the error so it at least\n       * gives some clue about where in your application this happens.\n       */\n      JSON.stringify(msg));\n    }\n    return _post(this, 'message', msg);\n  },\n  postInternal: function postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n  set onmessage(fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n    _removeListenerObject(this, 'message', this._onML);\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n  addEventListener: function addEventListener(type, fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener: function removeEventListener(type, fn) {\n    var obj = this._addEL[type].find(function (obj) {\n      return obj.fn === fn;\n    });\n    _removeListenerObject(this, type, obj);\n  },\n  close: function close() {\n    var _this = this;\n    if (this.closed) {\n      return;\n    }\n    OPEN_BROADCAST_CHANNELS[\"delete\"](this);\n    this.closed = true;\n    var awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare\n    // wait until all current sending are processed\n    .then(function () {\n      return Promise.all(Array.from(_this._uMP));\n    })\n    // run before-close hooks\n    .then(function () {\n      return Promise.all(_this._befC.map(function (fn) {\n        return fn();\n      }));\n    })\n    // close the channel\n    .then(function () {\n      return _this.method.close(_this._state);\n    });\n  },\n  get type() {\n    return this.method.type;\n  },\n  get isClosed() {\n    return this.closed;\n  }\n};\n\n/**\n * Post a message over the channel\n * @returns {Promise} that resolved when the message sending is done\n */\nfunction _post(broadcastChannel, type, msg) {\n  var time = broadcastChannel.method.microSeconds();\n  var msgObj = {\n    time: time,\n    type: type,\n    data: msg\n  };\n  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID;\n  return awaitPrepare.then(function () {\n    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);\n\n    // add/remove to unsent messages list\n    broadcastChannel._uMP.add(sendPromise);\n    sendPromise[\"catch\"]().then(function () {\n      return broadcastChannel._uMP[\"delete\"](sendPromise);\n    });\n    return sendPromise;\n  });\n}\nfunction _prepareChannel(channel) {\n  var maybePromise = channel.method.create(channel.name, channel.options);\n  if (isPromise(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(function (s) {\n      // used in tests to simulate slow runtime\n      /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n  _startListening(channel);\n}\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(function (o) {\n    return o !== obj;\n  });\n  _stopListening(channel);\n}\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n\n    var listenerFn = function listenerFn(msgObj) {\n      channel._addEL[msgObj.type].forEach(function (listenerObject) {\n        if (msgObj.time >= listenerObject.time) {\n          listenerObject.fn(msgObj.data);\n        }\n      });\n    };\n    var time = channel.method.microSeconds();\n    if (channel._prepP) {\n      channel._prepP.then(function () {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // no one is listening, stop subscribing\n    channel._iL = false;\n    var time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}", "/* global WorkerGlobalScope */\n\nexport function addBrowser(fn) {\n  if (typeof WorkerGlobalScope === 'function' && self instanceof WorkerGlobalScope) {\n    /**\n     * Because killing a worker does directly stop the excution\n     * of the code, our only chance is to overwrite the close function\n     * which could work some times.\n     * @link https://stackoverflow.com/q/72903255/3443137\n     */\n    var oldClose = self.close.bind(self);\n    self.close = function () {\n      fn();\n      return oldClose();\n    };\n  } else {\n    /**\n     * if we are on react-native, there is no window.addEventListener\n     * @link https://github.com/pubkey/unload/issues/6\n     */\n    if (typeof window.addEventListener !== 'function') {\n      return;\n    }\n\n    /**\n     * for normal browser-windows, we use the beforeunload-event\n     */\n    window.addEventListener('beforeunload', function () {\n      fn();\n    }, true);\n\n    /**\n     * for iframes, we have to use the unload-event\n     * @link https://stackoverflow.com/q/47533670/3443137\n     */\n    window.addEventListener('unload', function () {\n      fn();\n    }, true);\n  }\n\n  /**\n   * TODO add fallback for safari-mobile\n   * @link https://stackoverflow.com/a/26193516/3443137\n   */\n}", "export function addNode(fn) {\n  process.on('exit', function () {\n    return fn();\n  });\n\n  /**\n   * on the following events,\n   * the process will not end if there are\n   * event-handlers attached,\n   * therefore we have to call process.exit()\n   */\n  process.on('beforeExit', function () {\n    return fn().then(function () {\n      return process.exit();\n    });\n  });\n  // catches ctrl+c event\n  process.on('SIGINT', function () {\n    return fn().then(function () {\n      return process.exit();\n    });\n  });\n  // catches uncaught exceptions\n  process.on('uncaughtException', function (err) {\n    return fn().then(function () {\n      console.trace(err);\n      process.exit(101);\n    });\n  });\n}", "import { addBrowser } from './browser.js';\nimport { addNode } from './node.js';\n\n/**\n * Use the code directly to prevent import problems\n * with the detect-node package.\n * @link https://github.com/iliakan/detect-node/blob/master/index.js\n */\nvar isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';\nvar USE_METHOD = isNode ? addNode : addBrowser;\nvar LISTENERS = new Set();\nvar startedListening = false;\nfunction startListening() {\n  if (startedListening) {\n    return;\n  }\n  startedListening = true;\n  USE_METHOD(runAll);\n}\nexport function add(fn) {\n  startListening();\n  if (typeof fn !== 'function') {\n    throw new Error('Listener is no function');\n  }\n  LISTENERS.add(fn);\n  var addReturn = {\n    remove: function remove() {\n      return LISTENERS[\"delete\"](fn);\n    },\n    run: function run() {\n      LISTENERS[\"delete\"](fn);\n      return fn();\n    }\n  };\n  return addReturn;\n}\nexport function runAll() {\n  var promises = [];\n  LISTENERS.forEach(function (fn) {\n    promises.push(fn());\n    LISTENERS[\"delete\"](fn);\n  });\n  return Promise.all(promises);\n}\nexport function removeAll() {\n  LISTENERS.clear();\n}\nexport function getSize() {\n  return LISTENERS.size;\n}", "import { add as unloadAdd } from 'unload';\n\n/**\n * sends and internal message over the broadcast-channel\n */\nexport function sendLeaderMessage(leaderElector, action) {\n  var msgJson = {\n    context: 'leader',\n    action: action,\n    token: leaderElector.token\n  };\n  return leaderElector.broadcastChannel.postInternal(msgJson);\n}\nexport function beLeader(leaderElector) {\n  leaderElector.isLeader = true;\n  leaderElector._hasLeader = true;\n  var unloadFn = unloadAdd(function () {\n    return leaderElector.die();\n  });\n  leaderElector._unl.push(unloadFn);\n  var isLeaderListener = function isLeaderListener(msg) {\n    if (msg.context === 'leader' && msg.action === 'apply') {\n      sendLeaderMessage(leaderElector, 'tell');\n    }\n    if (msg.context === 'leader' && msg.action === 'tell' && !leaderElector._dpLC) {\n      /**\n       * another instance is also leader!\n       * This can happen on rare events\n       * like when the CPU is at 100% for long time\n       * or the tabs are open very long and the browser throttles them.\n       * @link https://github.com/pubkey/broadcast-channel/issues/414\n       * @link https://github.com/pubkey/broadcast-channel/issues/385\n       */\n      leaderElector._dpLC = true;\n      leaderElector._dpL(); // message the lib user so the app can handle the problem\n      sendLeaderMessage(leaderElector, 'tell'); // ensure other leader also knows the problem\n    }\n  };\n\n  leaderElector.broadcastChannel.addEventListener('internal', isLeaderListener);\n  leaderElector._lstns.push(isLeaderListener);\n  return sendLeaderMessage(leaderElector, 'tell');\n}", "import { randomToken } from './util.js';\nimport { sendLeaderMessage, beLeader } from './leader-election-util.js';\n\n/**\n * A faster version of the leader elector that uses the WebLock API\n * @link https://developer.mozilla.org/en-US/docs/Web/API/Web_Locks_API\n */\nexport var LeaderElectionWebLock = function LeaderElectionWebLock(broadcastChannel, options) {\n  var _this = this;\n  this.broadcastChannel = broadcastChannel;\n  broadcastChannel._befC.push(function () {\n    return _this.die();\n  });\n  this._options = options;\n  this.isLeader = false;\n  this.isDead = false;\n  this.token = randomToken();\n  this._lstns = [];\n  this._unl = [];\n  this._dpL = function () {}; // onduplicate listener\n  this._dpLC = false; // true when onduplicate called\n\n  this._wKMC = {}; // stuff for cleanup\n\n  // lock name\n  this.lN = 'pubkey-bc||' + broadcastChannel.method.type + '||' + broadcastChannel.name;\n};\nLeaderElectionWebLock.prototype = {\n  hasLeader: function hasLeader() {\n    var _this2 = this;\n    return navigator.locks.query().then(function (locks) {\n      var relevantLocks = locks.held ? locks.held.filter(function (lock) {\n        return lock.name === _this2.lN;\n      }) : [];\n      if (relevantLocks && relevantLocks.length > 0) {\n        return true;\n      } else {\n        return false;\n      }\n    });\n  },\n  awaitLeadership: function awaitLeadership() {\n    var _this3 = this;\n    if (!this._wLMP) {\n      this._wKMC.c = new AbortController();\n      var returnPromise = new Promise(function (res, rej) {\n        _this3._wKMC.res = res;\n        _this3._wKMC.rej = rej;\n      });\n      this._wLMP = new Promise(function (res) {\n        navigator.locks.request(_this3.lN, {\n          signal: _this3._wKMC.c.signal\n        }, function () {\n          // if the lock resolved, we can drop the abort controller\n          _this3._wKMC.c = undefined;\n          beLeader(_this3);\n          res();\n          return returnPromise;\n        })[\"catch\"](function () {});\n      });\n    }\n    return this._wLMP;\n  },\n  set onduplicate(_fn) {\n    // Do nothing because there are no duplicates in the WebLock version\n  },\n  die: function die() {\n    var _this4 = this;\n    this._lstns.forEach(function (listener) {\n      return _this4.broadcastChannel.removeEventListener('internal', listener);\n    });\n    this._lstns = [];\n    this._unl.forEach(function (uFn) {\n      return uFn.remove();\n    });\n    this._unl = [];\n    if (this.isLeader) {\n      this.isLeader = false;\n    }\n    this.isDead = true;\n    if (this._wKMC.res) {\n      this._wKMC.res();\n    }\n    if (this._wKMC.c) {\n      this._wKMC.c.abort('LeaderElectionWebLock.die() called');\n    }\n    return sendLeaderMessage(this, 'death');\n  }\n};", "import { sleep, randomToken, PROMISE_RESOLVED_VOID, PROMISE_RESOLVED_TRUE, supportsWebLockAPI } from './util.js';\nimport { sendLeaderMessage, beLeader } from './leader-election-util.js';\nimport { LeaderElectionWebLock } from './leader-election-web-lock.js';\nvar LeaderElection = function LeaderElection(broadcastChannel, options) {\n  var _this = this;\n  this.broadcastChannel = broadcastChannel;\n  this._options = options;\n  this.isLeader = false;\n  this._hasLeader = false;\n  this.isDead = false;\n  this.token = randomToken();\n\n  /**\n   * Apply Queue,\n   * used to ensure we do not run applyOnce()\n   * in parallel.\n   */\n  this._aplQ = PROMISE_RESOLVED_VOID;\n  // amount of unfinished applyOnce() calls\n  this._aplQC = 0;\n\n  // things to clean up\n  this._unl = []; // _unloads\n  this._lstns = []; // _listeners\n  this._dpL = function () {}; // onduplicate listener\n  this._dpLC = false; // true when onduplicate called\n\n  /**\n   * Even when the own instance is not applying,\n   * we still listen to messages to ensure the hasLeader flag\n   * is set correctly.\n   */\n  var hasLeaderListener = function hasLeaderListener(msg) {\n    if (msg.context === 'leader') {\n      if (msg.action === 'death') {\n        _this._hasLeader = false;\n      }\n      if (msg.action === 'tell') {\n        _this._hasLeader = true;\n      }\n    }\n  };\n  this.broadcastChannel.addEventListener('internal', hasLeaderListener);\n  this._lstns.push(hasLeaderListener);\n};\nLeaderElection.prototype = {\n  hasLeader: function hasLeader() {\n    return Promise.resolve(this._hasLeader);\n  },\n  /**\n   * Returns true if the instance is leader,\n   * false if not.\n   * @async\n   */\n  applyOnce: function applyOnce(\n  // true if the applyOnce() call came from the fallbackInterval cycle\n  isFromFallbackInterval) {\n    var _this2 = this;\n    if (this.isLeader) {\n      return sleep(0, true);\n    }\n    if (this.isDead) {\n      return sleep(0, false);\n    }\n\n    /**\n     * Already applying more than once,\n     * -> wait for the apply queue to be finished.\n     */\n    if (this._aplQC > 1) {\n      return this._aplQ;\n    }\n\n    /**\n     * Add a new apply-run\n     */\n    var applyRun = function applyRun() {\n      /**\n       * Optimization shortcuts.\n       * Directly return if a previous run\n       * has already elected a leader.\n       */\n      if (_this2.isLeader) {\n        return PROMISE_RESOLVED_TRUE;\n      }\n      var stopCriteria = false;\n      var stopCriteriaPromiseResolve;\n      /**\n       * Resolves when a stop criteria is reached.\n       * Uses as a performance shortcut so we do not\n       * have to await the responseTime when it is already clear\n       * that the election failed.\n       */\n      var stopCriteriaPromise = new Promise(function (res) {\n        stopCriteriaPromiseResolve = function stopCriteriaPromiseResolve() {\n          stopCriteria = true;\n          res();\n        };\n      });\n      var handleMessage = function handleMessage(msg) {\n        if (msg.context === 'leader' && msg.token != _this2.token) {\n          if (msg.action === 'apply') {\n            // other is applying\n            if (msg.token > _this2.token) {\n              /**\n               * other has higher token\n               * -> stop applying and let other become leader.\n               */\n              stopCriteriaPromiseResolve();\n            }\n          }\n          if (msg.action === 'tell') {\n            // other is already leader\n            stopCriteriaPromiseResolve();\n            _this2._hasLeader = true;\n          }\n        }\n      };\n      _this2.broadcastChannel.addEventListener('internal', handleMessage);\n\n      /**\n       * If the applyOnce() call came from the fallbackInterval,\n       * we can assume that the election runs in the background and\n       * not critical process is waiting for it.\n       * When this is true, we give the other instances\n       * more time to answer to messages in the election cycle.\n       * This makes it less likely to elect duplicate leaders.\n       * But also it takes longer which is not a problem because we anyway\n       * run in the background.\n       */\n      var waitForAnswerTime = isFromFallbackInterval ? _this2._options.responseTime * 4 : _this2._options.responseTime;\n      return sendLeaderMessage(_this2, 'apply') // send out that this one is applying\n      .then(function () {\n        return Promise.race([sleep(waitForAnswerTime), stopCriteriaPromise.then(function () {\n          return Promise.reject(new Error());\n        })]);\n      })\n      // send again in case another instance was just created\n      .then(function () {\n        return sendLeaderMessage(_this2, 'apply');\n      })\n      // let others time to respond\n      .then(function () {\n        return Promise.race([sleep(waitForAnswerTime), stopCriteriaPromise.then(function () {\n          return Promise.reject(new Error());\n        })]);\n      })[\"catch\"](function () {}).then(function () {\n        _this2.broadcastChannel.removeEventListener('internal', handleMessage);\n        if (!stopCriteria) {\n          // no stop criteria -> own is leader\n          return beLeader(_this2).then(function () {\n            return true;\n          });\n        } else {\n          // other is leader\n          return false;\n        }\n      });\n    };\n    this._aplQC = this._aplQC + 1;\n    this._aplQ = this._aplQ.then(function () {\n      return applyRun();\n    }).then(function () {\n      _this2._aplQC = _this2._aplQC - 1;\n    });\n    return this._aplQ.then(function () {\n      return _this2.isLeader;\n    });\n  },\n  awaitLeadership: function awaitLeadership() {\n    if ( /* _awaitLeadershipPromise */\n    !this._aLP) {\n      this._aLP = _awaitLeadershipOnce(this);\n    }\n    return this._aLP;\n  },\n  set onduplicate(fn) {\n    this._dpL = fn;\n  },\n  die: function die() {\n    var _this3 = this;\n    this._lstns.forEach(function (listener) {\n      return _this3.broadcastChannel.removeEventListener('internal', listener);\n    });\n    this._lstns = [];\n    this._unl.forEach(function (uFn) {\n      return uFn.remove();\n    });\n    this._unl = [];\n    if (this.isLeader) {\n      this._hasLeader = false;\n      this.isLeader = false;\n    }\n    this.isDead = true;\n    return sendLeaderMessage(this, 'death');\n  }\n};\n\n/**\n * @param leaderElector {LeaderElector}\n */\nfunction _awaitLeadershipOnce(leaderElector) {\n  if (leaderElector.isLeader) {\n    return PROMISE_RESOLVED_VOID;\n  }\n  return new Promise(function (res) {\n    var resolved = false;\n    function finish() {\n      if (resolved) {\n        return;\n      }\n      resolved = true;\n      leaderElector.broadcastChannel.removeEventListener('internal', whenDeathListener);\n      res(true);\n    }\n\n    // try once now\n    leaderElector.applyOnce().then(function () {\n      if (leaderElector.isLeader) {\n        finish();\n      }\n    });\n\n    /**\n     * Try on fallbackInterval\n     * @recursive\n     */\n    var tryOnFallBack = function tryOnFallBack() {\n      return sleep(leaderElector._options.fallbackInterval).then(function () {\n        if (leaderElector.isDead || resolved) {\n          return;\n        }\n        if (leaderElector.isLeader) {\n          finish();\n        } else {\n          return leaderElector.applyOnce(true).then(function () {\n            if (leaderElector.isLeader) {\n              finish();\n            } else {\n              tryOnFallBack();\n            }\n          });\n        }\n      });\n    };\n    tryOnFallBack();\n\n    // try when other leader dies\n    var whenDeathListener = function whenDeathListener(msg) {\n      if (msg.context === 'leader' && msg.action === 'death') {\n        leaderElector._hasLeader = false;\n        leaderElector.applyOnce().then(function () {\n          if (leaderElector.isLeader) {\n            finish();\n          }\n        });\n      }\n    };\n    leaderElector.broadcastChannel.addEventListener('internal', whenDeathListener);\n    leaderElector._lstns.push(whenDeathListener);\n  });\n}\nfunction fillOptionsWithDefaults(options, channel) {\n  if (!options) options = {};\n  options = JSON.parse(JSON.stringify(options));\n  if (!options.fallbackInterval) {\n    options.fallbackInterval = 3000;\n  }\n  if (!options.responseTime) {\n    options.responseTime = channel.method.averageResponseTime(channel.options);\n  }\n  return options;\n}\nexport function createLeaderElection(channel, options) {\n  if (channel._leaderElector) {\n    throw new Error('BroadcastChannel already has a leader-elector');\n  }\n  options = fillOptionsWithDefaults(options, channel);\n  var elector = supportsWebLockAPI() ? new LeaderElectionWebLock(channel, options) : new LeaderElection(channel, options);\n  channel._befC.push(function () {\n    return elector.die();\n  });\n  channel._leaderElector = elector;\n  return elector;\n}", "/**\n * When a persistent RxStorage is used in more the one JavaScript process,\n * the even stream of the changestream() function must be broadcasted to the other\n * RxStorageInstances of the same databaseName+collectionName.\n *\n * In the past this was done by RxDB but it makes more sense to do this\n * at the RxStorage level so that the broadcasting etc can all happen inside of a WebWorker\n * and not on the main thread.\n * Also it makes it less complex to stack up different RxStorages onto each other\n * like what we do with the in-memory plugin.\n *\n * This is intended to be used inside of createStorageInstance() of a storage.\n * Do not use this if the storage anyway broadcasts the events like when using MongoDB\n * or in the future W3C might introduce a way to listen to IndexedDB changes.\n */\n\nimport { Observable, Subject } from 'rxjs';\nimport { mergeWith } from 'rxjs/operators';\nimport type {\n    EventBulk,\n    RxStorageChangeEvent,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams\n} from './types/index.d.ts';\n\nimport {\n    BroadcastChannel\n} from 'broadcast-channel';\n\n/**\n * The broadcast-channel is reused by the databaseInstanceToken.\n * This is required so that it is easy to simulate multi-tab usage\n * in the test where different instances of the same RxDatabase must\n * have different broadcast channels.\n * But also it ensures that for each RxDatabase we only create a single\n * broadcast channel that can even be reused in the leader election plugin.\n *\n * TODO at the end of the unit tests,\n * we should ensure that all channels are closed and cleaned up.\n * Otherwise we have forgot something.\n */\nexport const BROADCAST_CHANNEL_BY_TOKEN: Map<string, {\n    bc: BroadcastChannel<RxStorageMultiInstanceBroadcastType>;\n    /**\n     * Contains all context objects that currently use the channel.\n     * If this becomes empty, we can close the channel\n     */\n    refs: Set<any>;\n}> = new Map();\n\n\nexport type RxStorageMultiInstanceBroadcastType = {\n    storageName: string;\n    collectionName: string;\n    /**\n     * collection.schema.version\n     */\n    version: number;\n    databaseName: string;\n    eventBulk: EventBulk<any, any>;\n};\n\nexport function getBroadcastChannelReference(\n    storageName: string,\n    databaseInstanceToken: string,\n    databaseName: string,\n    refObject: any\n): BroadcastChannel<RxStorageMultiInstanceBroadcastType> {\n    let state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);\n    if (!state) {\n        state = {\n            /**\n             * We have to use the databaseName instead of the databaseInstanceToken\n             * in the BroadcastChannel name because different instances must end with the same\n             * channel name to be able to broadcast messages between each other.\n             */\n            bc: new BroadcastChannel(['RxDB:', storageName, databaseName].join('|')),\n            refs: new Set<any>()\n        };\n        BROADCAST_CHANNEL_BY_TOKEN.set(databaseInstanceToken, state);\n    }\n    state.refs.add(refObject);\n    return state.bc;\n}\n\nexport function removeBroadcastChannelReference(\n    databaseInstanceToken: string,\n    refObject: any\n) {\n    const state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);\n    if (!state) {\n        return;\n    }\n    state.refs.delete(refObject);\n    if (state.refs.size === 0) {\n        BROADCAST_CHANNEL_BY_TOKEN.delete(databaseInstanceToken);\n        return state.bc.close();\n    }\n}\n\n\nexport function addRxStorageMultiInstanceSupport<RxDocType>(\n    storageName: string,\n    instanceCreationParams: RxStorageInstanceCreationParams<RxDocType, any>,\n    instance: RxStorageInstance<RxDocType, any, any>,\n    /**\n     * If provided, that channel will be used\n     * instead of an own one.\n     */\n    providedBroadcastChannel?: BroadcastChannel<any>\n) {\n    if (!instanceCreationParams.multiInstance) {\n        return;\n    }\n\n    type Emit = EventBulk<RxStorageChangeEvent<RxDocType>, any>;\n\n    const broadcastChannel = providedBroadcastChannel ?\n        providedBroadcastChannel :\n        getBroadcastChannelReference(\n            storageName,\n            instanceCreationParams.databaseInstanceToken,\n            instance.databaseName,\n            instance\n        );\n\n    const changesFromOtherInstances$: Subject<Emit> = new Subject();\n\n\n    const eventListener = (msg: RxStorageMultiInstanceBroadcastType) => {\n        if (\n            msg.storageName === storageName &&\n            msg.databaseName === instanceCreationParams.databaseName &&\n            msg.collectionName === instanceCreationParams.collectionName &&\n            msg.version === instanceCreationParams.schema.version\n        ) {\n            changesFromOtherInstances$.next(msg.eventBulk);\n        }\n    };\n\n    broadcastChannel.addEventListener('message', eventListener);\n\n    const oldChangestream$ = instance.changeStream();\n\n    let closed = false;\n    const sub = oldChangestream$.subscribe(eventBulk => {\n        if (closed) {\n            return;\n        }\n        broadcastChannel.postMessage({\n            storageName: storageName,\n            databaseName: instanceCreationParams.databaseName,\n            collectionName: instanceCreationParams.collectionName,\n            version: instanceCreationParams.schema.version,\n            eventBulk\n        });\n    });\n\n    instance.changeStream = function (): Observable<Emit> {\n        return changesFromOtherInstances$.asObservable().pipe(\n            mergeWith(oldChangestream$)\n        );\n    };\n\n    const oldClose = instance.close.bind(instance);\n    instance.close = async function () {\n        closed = true;\n        sub.unsubscribe();\n        broadcastChannel.removeEventListener('message', eventListener);\n        if (!providedBroadcastChannel) {\n            await removeBroadcastChannelReference(\n                instanceCreationParams.databaseInstanceToken,\n                instance\n            );\n        }\n        return oldClose();\n    };\n\n    const oldRemove = instance.remove.bind(instance);\n    instance.remove = async function () {\n        closed = true;\n        sub.unsubscribe();\n        broadcastChannel.removeEventListener('message', eventListener);\n        if (!providedBroadcastChannel) {\n            await removeBroadcastChannelReference(\n                instanceCreationParams.databaseInstanceToken,\n                instance\n            );\n        }\n        return oldRemove();\n    };\n}\n"],
  "mappings": "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",
  "names": ["HOOKS", "preAddRxPlugin", "preCreateRxDatabase", "createRxDatabase", "preCreateRxCollection", "createRxCollection", "createRxState", "postDestroyRxCollection", "postRemoveRxCollection", "preCreateRxSchema", "createRxSchema", "preCreateRxQuery", "prePrepareQuery", "createRxDocument", "postCreateRxDocument", "preCreateRxStorageInstance", "preStorageWrite", "preMigrateDocument", "postMigrateDocument", "preDestroyRxDatabase", "postRemoveRxDatabase", "postCleanup", "preReplicationMasterWrite", "preReplicationMasterWriteDocumentsHandle", "runPluginHooks", "hookKey", "obj", "length", "forEach", "fun", "runAsyncPluginHooks", "Promise", "all", "map", "_clearHook", "type", "filter", "h", "getDocumentDataOfRxChangeEvent", "rxChangeEvent", "documentData", "previousDocumentData", "rxChangeEventToEventReduceChangeEvent", "operation", "id", "documentId", "doc", "previous", "overwritable", "deepFreezeWhenDevMode", "flattenEvents", "input", "output", "Array", "isArray", "forEach", "inputItem", "add", "appendToArray", "events", "ev", "push", "usedIds", "Set", "nonDuplicate", "getEventId", "_rev", "join", "eventId", "has", "QueryCache", "_map", "Map", "_proto", "prototype", "getByQuery", "rxQuery", "stringRep", "toString", "getFromMapOrCreate", "createQueryCache", "uncacheRxQuery", "queryCache", "uncached", "delete", "countRxQuerySubscribers", "refCount$", "observers", "length", "DEFAULT_TRY_TO_KEEP_MAX", "DEFAULT_UNEXECUTED_LIFETIME", "defaultCacheReplacementPolicyMonad", "tryToKeepMax", "unExecutedLifetime", "_collection", "size", "minUnExecutedLifetime", "now", "maybeUncache", "queriesInCache", "Array", "from", "values", "_lastEnsureEqual", "_creationTime", "push", "mustUncache", "sortedByLastUsage", "sort", "a", "b", "toRemove", "slice", "forEach", "defaultCacheReplacementPolicy", "COLLECTIONS_WITH_RUNNING_CLEANUP", "WeakSet", "triggerCacheReplacement", "rxCollection", "has", "add", "nextTick", "then", "requestIdlePromise", "destroyed", "cacheReplacementPolicy", "_queryCache", "DocumentCache", "primaryPath", "changes$", "documentCreator", "cacheItemByDocId", "Map", "tasks", "Set", "registry", "FinalizationRegistry", "docMeta", "docId", "cacheItem", "get", "delete", "revisionHeight", "size", "undefined", "subscribe", "events", "add", "index", "length", "event", "documentId", "documentData", "previousDocumentData", "requestIdlePromiseNoQueue", "then", "processTasks", "_proto", "prototype", "Array", "from", "forEach", "task", "clear", "getLatestDocumentData", "getFromMapOrThrow", "getLatestDocumentDataIfExists", "_createClass", "key", "fn", "getCachedRxDocumentMonad", "overwriteGetterForCaching", "doc", "docCache", "deepFreezeWhenDevMode", "overwritable", "docsData", "ret", "registryTasks", "docData", "getHeightOfRevision", "_rev", "byRev", "cachedRxDocumentWeakRef", "set", "cachedRxDocument", "deref", "createWeakRefWithFallback", "push", "register", "primary", "revision", "mapDocumentsDataToCacheDocs", "getCachedRxDocuments", "HAS_WEAK_REF", "WeakRef", "createWeakRef", "createWeakRefFallback", "obj", "RxQuerySingleResult", "query", "docsDataFromStorageInstance", "count", "time", "now", "documents", "mapDocumentsDataToCacheDocs", "collection", "_docCache", "_proto", "prototype", "getValue", "throwIfMissing", "op", "doc", "length", "newRxError", "name", "mangoQuery", "docsMap", "slice", "_createClass", "key", "get", "overwriteGetterForCaching", "map", "d", "_data", "Map", "forEach", "set", "primary", "i", "timestamp", "timestamp", "now", "AsapAction", "delay", "AsapScheduler", "QueueAction", "delay", "QueueScheduler", "AnimationFrameAction", "delay", "AnimationFrameScheduler", "VirtualTimeScheduler", "VirtualAction", "delay", "config", "lastOfArray", "type", "first", "last", "lastOfArray", "first", "last", "simpleBdd", "getSortFieldsOfQuery", "primaryKey", "query", "sort", "length", "map", "part", "Object", "keys", "RXQUERY_QUERY_PARAMS_CACHE", "WeakMap", "getQueryParams", "rxQuery", "getFromMapOrCreate", "collection", "normalizedMangoQuery", "normalizeMangoQuery", "storageInstance", "schema", "clone", "mangoQuery", "primaryPath", "sortComparator", "getSortComparator", "jsonSchema", "useSortComparator", "docA", "docB", "sortComparatorData", "queryMatcher", "getQueryMatcher", "useQueryMatcher", "doc", "queryMatcherData", "ret", "skip", "limit", "sortFields", "calculateNewResults", "rxChangeEvents", "database", "eventReduce", "runFullQueryAgain", "queryParams", "previousResults", "ensureNotFalsy", "_result", "docsData", "slice", "previousResultsMap", "docsDataMap", "changed", "eventReduceEvents", "cE", "rxChangeEventToEventReduceChangeEvent", "filter", "arrayFilterNotEmpty", "foundNonOptimizeable", "find", "eventReduceEvent", "stateResolveFunctionInput", "changeEvent", "keyDocumentMap", "actionName", "calculateActionName", "runAction", "newResults", "_queryCount", "newQueryID", "RxQueryBase", "op", "mangoQuery", "collection", "other", "id", "_execOverDatabaseCount", "_creationTime", "now", "_lastEnsureEqual", "uncached", "refCount$", "BehaviorSubject", "_result", "_latestChangeEvent", "_lastExecStart", "_lastExecEnd", "_ensureEqualQueue", "PROMISE_RESOLVE_FALSE", "_getDefaultQuery", "isFindOneByIdQuery", "schema", "primaryPath", "_proto", "prototype", "_setResultData", "newResultData", "newRxError", "database", "name", "RxQuerySingleResult", "Map", "Array", "from", "values", "newQueryResult", "length", "_execOverDatabase", "preparedQuery", "getPreparedQuery", "result", "storageInstance", "count", "mode", "allowSlowCount", "queryObj", "ids", "ensureNotFalsy", "selector", "$in", "ret", "mustBeQueried", "forEach", "docData", "_docCache", "getLatestDocumentDataIfExists", "_deleted", "doc", "getCachedRxDocument", "set", "push", "docs", "findDocumentsById", "primary", "docsPromise", "queryCollection", "then", "exec", "throwIfMissing", "query", "_ensureEqual", "useResult", "getValue", "toString", "stringObj", "sortObject", "value", "JSON", "stringify", "hookInput", "rxQuery", "normalizeMangoQuery", "jsonSchema", "$eq", "index", "unshift", "runPluginHooks", "prepareQuery", "doesDocumentDataMatch", "queryMatcher", "remove", "isArray", "Promise", "all", "map", "incrementalRemove", "runQueryUpdateFunction", "asRxQuery", "update", "_updateObj", "pluginMissing", "patch", "incrementalPatch", "modify", "mutationFunction", "incrementalModify", "where", "_queryObj", "sort", "_params", "skip", "_amount", "limit", "_createClass", "key", "get", "_$", "results$", "$", "pipe", "filter", "changeEvent", "isLocal", "startWith", "mergeMap", "shareReplay", "RXJS_SHARE_REPLAY_DEFAULTS", "distinctUntilChanged", "prev", "curr", "time", "merge", "reactivity", "getReactivityFactory", "fromObservable", "undefined", "normalizedQuery", "overwriteGetterForCaching", "getQueryMatcher", "tunnelQueryCache", "_queryCache", "getByQuery", "createRxQuery", "triggerCacheReplacement", "_isResultsInSync", "currentLatestEventNumber", "_changeEventBuffer", "getCounter", "awaitBeforeReads", "size", "fn", "destroyed", "__ensureEqual", "mustReExec", "missedChangeEvents", "getFrom", "runChangeEvents", "reduceByLastOfDoc", "previousCount", "newCount", "cE", "didMatchBefore", "previousDocumentData", "doesMatchNow", "documentData", "eventReduceResult", "calculateNewResults", "runFullQueryAgain", "changed", "newResults", "areRxDocumentArraysEqual", "docsData", "resolve", "mutateableQuery", "queryPlan", "getQueryPlan", "docIds", "docId", "docsFromStorage", "appendToArray", "fromStorageList", "queryResult", "documents", "Object", "keys", "find", "r", "isRxQuery", "obj", "INTERNAL_STORAGE_NAME", "RX_DATABASE_LOCAL_DOCS_STORAGE_NAME", "getSingleDocument", "storageInstance", "documentId", "results", "findDocumentsById", "doc", "undefined", "writeSingle", "instance", "writeRow", "context", "writeResult", "bulkWrite", "error", "length", "primaryPath", "getPrimaryFieldOfPrimaryKey", "schema", "primaryKey", "success", "getWrittenDocumentsFromBulkWriteResponse", "ret", "observeSingle", "firstFindPromise", "changeStream", "pipe", "map", "evBulk", "events", "find", "ev", "filter", "Promise", "resolve", "ensureNotFalsy", "documentData", "startWith", "switchMap", "v", "stackCheckpoints", "checkpoints", "Object", "assign", "throwIfIsStorageWriteError", "collection", "writeData", "status", "newRxError", "name", "id", "writeError", "data", "categorizeBulkWriteRows", "docsInDb", "bulkWriteRows", "onInsert", "onUpdate", "hasAttachments", "attachments", "bulkInsertDocs", "bulkUpdateDocs", "errors", "eventBulkId", "randomCouchString", "eventBulk", "checkpoint", "startTime", "now", "endTime", "eventBulkEvents", "attachmentsAdd", "attachmentsRemove", "attachmentsUpdate", "hasDocsInDb", "size", "newestRow", "rowAmount", "_loop", "rowId", "document", "previous", "docId", "documentDeleted", "_deleted", "previousDeleted", "documentInDb", "get", "attachmentError", "insertedIsDeleted", "entries", "_attachments", "forEach", "attachmentId", "attachmentData", "isError", "push", "digest", "stripAttachmentsDataFromRow", "event", "operation", "stripAttachmentsDataFromDocument", "previousDocumentData", "revInDb", "_rev", "err", "updatedRow", "keys", "previousAttachmentData", "newDigest", "eventDocumentData", "previousEventDocumentData", "args", "getAttachmentSize", "attachmentBase64String", "atob", "attachmentWriteDataToNormalData", "type", "useDoc", "flatClone", "flatCloneDocWithMeta", "_meta", "BULK_WRITE_SUCCESS_MAP", "WeakMap", "getWrappedStorageInstance", "database", "rxJsonSchema", "overwritable", "deepFreezeWhenDevMode", "originalStorageInstance", "internals", "collectionName", "databaseName", "options", "rows", "databaseToken", "token", "toStorageWriteRows", "Array", "time", "index", "lwt", "createRevision", "runPluginHooks", "lockedRun", "then", "useWriteResult", "successArray", "set", "reInsertErrors", "reInserts", "subResult", "appendToArray", "subSuccess", "query", "preparedQuery", "count", "ids", "deleted", "getAttachmentData", "getChangedDocumentsSince", "limit", "cleanup", "minDeletedTime", "remove", "storageInstances", "delete", "close", "conflictResultionTasks", "resolveConflictResultionTask", "taskSolution", "output", "isEqual", "getDefaultRxDocumentMeta", "getDefaultRevision", "add", "ensureRxStorageInstanceParamsAreCorrect", "params", "keyCompression", "hasEncryption", "compression", "jsonSchema", "encrypted", "getChangedDocumentsSinceQuery", "sinceLwt", "RX_META_LWT_MINIMUM", "sinceId", "normalizeMangoQuery", "selector", "$or", "$gt", "$eq", "$gte", "sort", "skip", "prepareQuery", "result", "documents", "lastDoc", "lastOfArray", "writeRows", "response", "fromMap", "errorIds", "Set", "has", "randomDelayStorage", "input", "randomDelayStorageWriteQueue", "PROMISE_RESOLVE_TRUE", "retStorage", "storage", "rxdbVersion", "RXDB_VERSION", "createStorageInstance", "promiseWait", "delayTimeBefore", "delayTimeAfter", "a", "b", "c", "min", "max", "microSeconds", "now", "microSeconds", "type", "create", "close", "postMessage", "onMessage", "canBeUsed", "averageResponseTime", "type", "microSeconds", "microSeconds", "type", "postMessage", "listener", "create", "canBeUsed", "close", "onMessage", "averageResponseTime", "microSeconds", "type", "create", "close", "postMessage", "onMessage", "canBeUsed", "averageResponseTime", "BroadcastChannel", "BroadcastChannel", "postMessage", "type", "obj", "close", "listenerFn", "isLeaderListener", "LeaderElectionWebLock", "LeaderElection", "hasLeaderListener", "hasLeader", "applyRun", "stopCriteriaPromiseResolve", "handleMessage", "awaitLeadership", "die", "resolved", "tryOnFallBack", "whenDeathListener", "BROADCAST_CHANNEL_BY_TOKEN", "Map", "getBroadcastChannelReference", "storageName", "databaseInstanceToken", "databaseName", "refObject", "state", "get", "bc", "BroadcastChannel", "join", "refs", "Set", "set", "add", "removeBroadcastChannelReference", "delete", "size", "close", "addRxStorageMultiInstanceSupport", "instanceCreationParams", "instance", "providedBroadcastChannel", "multiInstance", "broadcastChannel", "changesFromOtherInstances$", "Subject", "eventListener", "msg", "collectionName", "version", "schema", "next", "eventBulk", "addEventListener", "oldChangestream$", "changeStream", "closed", "sub", "subscribe", "postMessage", "asObservable", "pipe", "mergeWith", "oldClose", "bind", "unsubscribe", "removeEventListener", "oldRemove", "remove"]
}
